{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>wraps</code>","text":"<p>Meaningful and safe wrapping types.</p>"},{"location":"#installing","title":"Installing","text":"<p>Python 3.8 or above is required.</p>"},{"location":"#pip","title":"<code>pip</code>","text":"<p>Installing the library with <code>pip</code> is quite simple:</p> <pre><code>$ pip install wraps\n</code></pre> <p>Alternatively, the library can be installed from the source:</p> <pre><code>$ pip install git+https://github.com/nekitdev/wraps.git\n</code></pre> <p>Or via cloning the repository:</p> <pre><code>$ git clone https://github.com/nekitdev/wraps.git\n$ cd wraps\n$ pip install .\n</code></pre>"},{"location":"#uv","title":"<code>uv</code>","text":"<p>You can add <code>wraps</code> as a dependency with the following command:</p> <pre><code>$ uv add wraps\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>TODO</p>"},{"location":"#documentation","title":"Documentation","text":"<p>You can find the documentation here.</p>"},{"location":"#support","title":"Support","text":"<p>If you need support with the library, you can send us an email or refer to the official Discord server.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>You can find the changelog here.</p>"},{"location":"#security-policy","title":"Security Policy","text":"<p>You can find the Security Policy of <code>wraps</code> here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you are interested in contributing to <code>wraps</code>, make sure to take a look at the Contributing Guide, as well as the Code of Conduct.</p>"},{"location":"#license","title":"License","text":"<p><code>wraps</code> is licensed under the MIT License terms. See License for details.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#0141-2024-08-16","title":"0.14.1 (2024-08-16)","text":"<p>No significant changes.</p>"},{"location":"changelog/#0140-2024-08-13","title":"0.14.0 (2024-08-13)","text":"<p>No significant changes.</p>"},{"location":"changelog/#0130-2024-06-21","title":"0.13.0 (2024-06-21)","text":""},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Error types are now truly forced to be non-empty.   (#55)</li> </ul>"},{"location":"changelog/#0120-2024-04-30","title":"0.12.0 (2024-04-30)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Added <code>or_raise</code>, <code>or_raise_with</code> and <code>or_raise_with_await</code> for   <code>Option[T]</code>, <code>Result[T, E]</code> and their future counterparts.</li> </ul>"},{"location":"changelog/#0110-2024-04-23","title":"0.11.0 (2024-04-23)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Added <code>wrap_option_on</code>, <code>wrap_option_await_on</code>, <code>wrap_result_on</code> and <code>wrap_result_await_on</code>.</li> </ul>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li> <p><code>wrap_option</code>, <code>wrap_option_await</code>, <code>wrap_result</code> and <code>wrap_result_await</code> are no longer   subscriptable: their <code>wrap_on</code> counterparts should be used to specify error types to handle.</p> </li> <li> <p><code>reawaitable</code> was renamed to <code>wrap_reawaitable</code> for consistency.</p> </li> </ul>"},{"location":"changelog/#0100-2024-04-22","title":"0.10.0 (2024-04-22)","text":""},{"location":"changelog/#changes_2","title":"Changes","text":"<ul> <li>The entire library was refactored.</li> </ul>"},{"location":"changelog/#092-2024-03-16","title":"0.9.2 (2024-03-16)","text":""},{"location":"changelog/#changes_3","title":"Changes","text":"<ul> <li>Improved type narrowing via using <code>TypeIs</code> instead of <code>TypeGuard</code>.</li> </ul>"},{"location":"changelog/#091-2024-02-26","title":"0.9.1 (2024-02-26)","text":"<p>No significant changes.</p>"},{"location":"changelog/#090-2024-02-25","title":"0.9.0 (2024-02-25)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Added <code>map_either</code> and <code>map_either_await</code> to <code>Either[L, R]</code>.</li> <li>Updated <code>FutureEither[L, R]</code> to be in sync with <code>Either[L, R]</code>.</li> </ul>"},{"location":"changelog/#080-2024-01-08","title":"0.8.0 (2024-01-08)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Added <code>NULL</code> for convenience:</li> </ul> <pre><code>NULL = Null()\n</code></pre>"},{"location":"changelog/#070-2024-01-07","title":"0.7.0 (2024-01-07)","text":""},{"location":"changelog/#changes_4","title":"Changes","text":"<ul> <li>Renamed functions in <code>Future[T]</code>; <code>name_future</code> is now <code>base_name</code>.</li> </ul>"},{"location":"changelog/#internal","title":"Internal","text":"<ul> <li>Migrated to Python 3.8.</li> </ul>"},{"location":"changelog/#061-2023-05-24","title":"0.6.1 (2023-05-24)","text":""},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>Fixed <code>final</code> import to be compatible with Python 3.7.</li> </ul>"},{"location":"changelog/#060-2023-05-21","title":"0.6.0 (2023-05-21)","text":""},{"location":"changelog/#internal_1","title":"Internal","text":"<ul> <li>Migrated to using <code>typing-aliases</code> library.</li> </ul>"},{"location":"changelog/#050-2023-05-12","title":"0.5.0 (2023-05-12)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Implement missing methods in future variants of options and results.</li> </ul>"},{"location":"changelog/#040-2023-04-24","title":"0.4.0 (2023-04-24)","text":""},{"location":"changelog/#internal_2","title":"Internal","text":"<ul> <li>Internal improvements.</li> </ul>"},{"location":"changelog/#030-2023-01-28","title":"0.3.0 (2023-01-28)","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Implemented <code>Either[L, R]</code> type.</li> </ul>"},{"location":"changelog/#020-2022-10-03","title":"0.2.0 (2022-10-03)","text":""},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>Renamed <code>convert_optional -&gt; wrap_optional</code>, added <code>extract</code> method.   This allows users to defer back to <code>Optional[T]</code>, along with wrapping   <code>Optional[T]</code> into <code>Option[T]</code> in a clear and concise way.   (#1)</li> </ul>"},{"location":"changelog/#010-2022-09-09","title":"0.1.0 (2022-09-09)","text":"<p>Initial release.</p>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct.</p> <p>Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq. Translations are available at https://contributor-covenant.org/translations.</p>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#reporting","title":"Reporting","text":"<p>Thank you for taking the time to responsibly disclose any problems you find.</p> <p>Do not file public issues as they are open for everyone to see!</p> <p>All security vulnerabilities in <code>wraps</code> should be reported by email to security@nekit.dev. Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report.</p> <p>You can encrypt your report using our public key: <code>6AF9DDF87B37BBE6E83F5DF2B8F5B86F98F12F5E</code>. This key is also available on MIT's Key Server and reproduced below.</p> <p>After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.</p>"},{"location":"security/#disclosure-policy","title":"Disclosure Policy","text":"<p><code>wraps</code> has a 5-step disclosure process:</p> <ol> <li> <p>The security report is received and is assigned a primary handler.    This person will coordinate the fix and release process.</p> </li> <li> <p>The problem is confirmed and a list of all affected versions is determined.</p> </li> <li> <p>Code is audited to find any potential similar problems.</p> </li> <li> <p>Fixes are prepared for all releases which are still under maintenance.    These fixes are not committed to the public repository but rather    held locally pending the announcement.</p> </li> <li> <p>On the embargo date, the changes are pushed to the public repository    and new builds are deployed.</p> </li> </ol> <p>This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.</p>"},{"location":"security/#security-key","title":"Security Key","text":"<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBGVV4JcBEAC7PTswfzA2iMTVSig51NVDV08XABrR01qslTfhIVw6Uwr2iCoY\nF+hkNn3++pgoF95Fx/iREDFV/AG4GGKl1GbAI3YD6aOoh0FGWtxg3MMa3oHjRUZs\nf0VwKk8sA5d21V05OiMuptAqxXuLrdR5SINtxKE10H6K9o22988VOmWUCIEaxKM5\nM5HCfhe8fl5pKpdIf3i1F073qset4DXGkvm/v+dWYHPvv0NlHhnJ5Lcaq4aTvkEg\ny2NhDobR4VpdP1aQZbEONussUaKLxBTBJN5NNnf7SI1qVYcaglYrXM7uQGXuL32X\nXAILtOCM0LO2059Z7ZMkI6lkkbei1j08j2Tha/1GvN2rIClNyV912GvAQhzlwhdT\nWmk+ymrwbed7MkRW3IB3b1zFb7Dhz6a5yBS8iT5ikkrGaR/i7O3V/DS02j7Rao2k\nnfXIncuBuXSXb1pIhCuYuV6VYBgFWfpKDjOzEy83h3DSI/jrR31e6aiBes+fyFRG\nIuoFRTsaMq2T9M5F6pDvmtoexHxXevYoSt+7DURY1pSWnk4MjZUj7yDFPSyfPleZ\naNq/3aGQt7vnY5QgyGjKaX5jSVuNEKsUlhrKUWt9weoJrF5ZyYHY0RPg1q1Fz0mY\nZ7QWeaKA0uOeziG0bHf6yNEzxnaYCfi09/WOL4GH0pBsdubNHpWno/D6PwARAQAB\ntC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2\nPokCTgQTAQoAOBYhBGr53fh7N7vm6D9d8rj1uG+Y8S9eBQJlVeCXAhsDBQsJCAcC\nBhUKCQgLAgQWAgMBAh4BAheAAAoJELj1uG+Y8S9ed4kP+wYE1OZtcWoRSK2Xqvaf\nP5+YcXC1vdCZ16depb6kGOR91G9eEMJhSDlSzzUzOmkvT4TknZi/Y17m9TvQccET\nSwgWvDs9XwMby24mkxD1iYu2uIZXXhRbIKJPi4EpGgamEveYLLTd0L8yX2l/YXuq\nVcM4vqgRtnovlW+cCUmmtpRcb+Ldfxu2RixjnG4fznzzlMOnU0zpWUMBqH+mSyfH\nRmY5vgOR/adgQcIviQdhRPMC4TAa3GNdTd2Qpxo3xelum15yLKxkm/EvBSPsL1fj\nJQBYnZFk4KBKNiXXYwWuU0mpOx1TMtYPVnHer17QL0vXfsmVNkXVzucvrNfHpFc9\nhXzmm5wHwMrGClyQBA6sDWDfQOKYibQTcKzyJr2Gl31luNPSRchzC4lbosLzRkqh\nYh5dco+ITiKDe7g54w+Fy+KdumwN/GvBlQptGIpaxA1+xAbNVs+fDo+WrQEL+AZO\nOQR91YUsjIdvVdk5BcgUYvEe2YyyMZ7LSqWACpRknqz5FNcdmO2bz7jl732EYLRm\nQ90oSG6xcIFuPZRNVIUJds9Gg2u1PBV5z0vnFGiJ6NK6DrYYecMKU9uAQUZcSW8v\n+fn92V0DkVeOfeMbq4yytZx5W4VrsWT1XyfjTzg867jzmo1JmZQeZ4KXh7AYRlC6\nn8NwYZ13+pUFeTPm9jCwJMrGuQINBGVV4JcBEACg5zXucth9KIdryYUxyBgA7Ist\nhJmyxtSHSiKRFOiQBmQqHeQgDdCnBeDw+cb+8wB4NL3PNw5xHKRvQGTWaBTV1IPf\nCV3P2c/sZLDCU8PNMu3lsmEbN2ippOiJi1fw478EGlNity8ktI+TEhsdniypKoiw\nDNf3wdawWiraODM9KuYplcsnFHl5r97BjHR0EbOOKkTc4PwysQ7WVHZ/nwGzNb5T\nCI7A/TF0RTL/Wkdz7WZM7r5BELz+z0ksjsS8eMObtm/uG4lfAmbIGohPTlir4WWL\n/GYZpAjvv/6zNaydMpY3uQKrdqN05j10uYnkbsclwSBBbRovFBRWEInbO0cqpzc0\nJiWt4U91F6UNbSDPo3KaiDjJXDb7cr4gQv0C1T9LtmKSfY/JVcUj7csGXslOAvXf\nz08iDCJu3zj7QjZPKA1/MxmTo88hAvhHlOYrXaaRjzXt6r9+qdDxVYJGe9K3LkJS\n9Yc0U9xBGAfzw9Ebs/ZPDtjgupPHJXq6VBSndU3c53jr7SEZBIFMPg75CeJJ6IgH\nA4zwW1uzalZi3mYWWCKiGhDBPOo5yGwKocxMzSuerlMW21fjhOMymSKVksteJlmZ\nAy6ExDNOK663V6iFnsn4iIFbE1jOznHhSsbyKqQ/QukpMqAyrQVSNyutXVl0VuW0\nZsZeFff7ScnrTgB7/QARAQABiQI2BBgBCgAgFiEEavnd+Hs3u+boP13yuPW4b5jx\nL14FAmVV4JcCGwwACgkQuPW4b5jxL15jNw/9EQkahEieTABEKAKxGetODA7HTiNR\ncM3aKgDU0msYjfgfAi+wQzx/8k8Yf/Kjma6JqsksCj0ygFkXS87tOAUfJTpgmKVS\nV3XaDXFwTcdG0+/Cx5RllduJmnLTLSuvm2uxu7ErPGtnYWBw88nmQ/8f9nkmvCsY\nCuF6DHAUNzTLgerFKSGNMwOv6kKBCgNkstclcHp5YbzssN1w34dPV/swuCjc+6JM\nnW5WuPD3R2Y9522Ov/bEwr9raFf3R5A6ETK4GOZUqNmPG4MJgbyiJlk96TuF06mO\nnFpKnBtxD+t20jAFTMRokyiQT65X8KnrpT8CpTJ6xzmBO5IYGhUSqt3CH/YzwqRa\nv9FTJ/qSPM5OXPH4pK7VzNDVhEPQhLAGENLwOnasnXXGvj/MQIRYyjGAXQfB34a7\nz0x4rQ+fyaody6BW10KJBQuRrB3dPaOPU3LU/4TxzyudDxiOJGiWAlw56a2lviEG\nJExMJrSvP5kiCfPlLZiLfqaw2ZYeyosnv8bmC4H2Sr9IEggtCyrzNOoJQx+w/f/L\n6a14Cshc3UYLC+0yh74Mc5vUu2SfwI6zSevjI1LWj4qc592J/q3QNHiJN9F60tyP\nr46uNM25Y+C5qgVneqRjHmWSIdOvYXcBTLj03eDiQHCJz3ZT6ztLwQxQ800MS1Yd\npbmAGLbBB2TBok4=\n=Ir8m\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"security/#attribution","title":"Attribution","text":"<p>This Security Policy is adapted from Rust's Security Policy.</p>"},{"location":"reference/either/","title":"Either","text":"<p>Either values.</p> <p>The <code>Either[L, R]</code> type is symmetric and treats its variants the same way, without preference. For representing results (values and errors), use the <code>Result[T, E]</code> instead.</p>"},{"location":"reference/either/#wraps.either.Either","title":"<code>Either = Union[Left[L], Right[R]]</code>  <code>module-attribute</code>","text":"<p>Either value, expressed as the union of <code>Left[L]</code> and <code>Right[R]</code>.</p>"},{"location":"reference/either/#wraps.either.Left","title":"<code>Left</code>","text":"<p>               Bases: <code>EitherProtocol[L, Never]</code></p> <p><code>Left[L]</code> variant of <code>Either[L, R]</code>.</p> Source code in <code>src/wraps/either.py</code> <pre><code>@final\n@frozen()\nclass Left(EitherProtocol[L, Never]):\n    \"\"\"[`Left[L]`][wraps.either.Left] variant of [`Either[L, R]`][wraps.either.Either].\"\"\"\n\n    value: L\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, value: M) -&gt; Left[M]:\n        return cls(value)  # type: ignore[arg-type, return-value]\n\n    def is_left(self) -&gt; Literal[True]:\n        return True\n\n    def is_left_and(self, predicate: Predicate[L]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_left_and_await(self, predicate: AsyncPredicate[L]) -&gt; bool:\n        return await predicate(self.value)\n\n    def is_right(self) -&gt; Literal[False]:\n        return False\n\n    def is_right_and(self, predicate: Predicate[R]) -&gt; Literal[False]:\n        return False\n\n    async def is_right_and_await(self, predicate: AsyncPredicate[R]) -&gt; Literal[False]:\n        return False\n\n    def left(self) -&gt; Some[L]:\n        return Some(self.value)\n\n    def left_or(self, default: L) -&gt; L:  # type: ignore[misc]\n        return self.value\n\n    def left_or_else(self, default: Nullary[L]) -&gt; L:\n        return self.value\n\n    async def left_or_else_await(self, default: AsyncNullary[L]) -&gt; L:\n        return self.value\n\n    def right(self) -&gt; Null:\n        return NULL\n\n    def right_or(self, default: R) -&gt; R:  # type: ignore[misc]\n        return default\n\n    def right_or_else(self, default: Nullary[R]) -&gt; R:\n        return default()\n\n    async def right_or_else_await(self, default: AsyncNullary[R]) -&gt; R:\n        return await default()\n\n    def expect_left(self, message: str) -&gt; L:\n        return self.value\n\n    def expect_right(self, message: str) -&gt; Never:\n        panic(message)\n\n    def unwrap_left(self) -&gt; L:\n        return self.value\n\n    def unwrap_right(self) -&gt; Never:\n        panic(UNWRAP_RIGHT_ON_LEFT)\n\n    def into_either(self: Left[T]) -&gt; T:\n        return self.value\n\n    def inspect_left(self, function: Inspect[L]) -&gt; Left[L]:\n        function(self.value)\n\n        return self\n\n    def inspect_right(self, function: Inspect[R]) -&gt; Left[L]:\n        return self\n\n    async def inspect_left_await(self, function: AsyncInspect[L]) -&gt; Left[L]:\n        await function(self.value)\n\n        return self\n\n    async def inspect_right_await(self, function: AsyncInspect[R]) -&gt; Left[L]:\n        return self\n\n    def flip(self) -&gt; Right[L]:\n        return Right(self.value)\n\n    def map_left(self, function: Unary[L, M]) -&gt; Left[M]:\n        return self.create(function(self.value))\n\n    async def map_left_await(self, function: AsyncUnary[L, M]) -&gt; Left[M]:\n        return self.create(await function(self.value))\n\n    def map_right(self, function: Unary[R, S]) -&gt; Left[L]:\n        return self\n\n    async def map_right_await(self, function: AsyncUnary[R, S]) -&gt; Left[L]:\n        return self\n\n    def map(self: Left[T], function: Unary[T, U]) -&gt; Left[U]:\n        return self.create(function(self.value))\n\n    async def map_await(self: Left[T], function: AsyncUnary[T, U]) -&gt; Left[U]:\n        return self.create(await function(self.value))\n\n    def map_either(self, left: Unary[L, M], right: Unary[R, S]) -&gt; Left[M]:\n        return self.create(left(self.value))\n\n    async def map_either_await(self, left: AsyncUnary[L, M], right: Unary[R, S]) -&gt; Left[M]:\n        return self.create(await left(self.value))\n\n    def either(self, left: Unary[L, T], right: Unary[R, T]) -&gt; T:\n        return left(self.value)\n\n    async def either_await(self, left: AsyncUnary[L, T], right: AsyncUnary[R, T]) -&gt; T:\n        return await left(self.value)\n\n    def left_and_then(self, function: Unary[L, Either[M, R]]) -&gt; Either[M, R]:\n        return function(self.value)\n\n    async def left_and_then_await(self, function: AsyncUnary[L, Either[M, R]]) -&gt; Either[M, R]:\n        return await function(self.value)\n\n    def right_and_then(self, function: Unary[R, Either[L, S]]) -&gt; Left[L]:\n        return self\n\n    async def right_and_then_await(self, function: AsyncUnary[R, Either[L, S]]) -&gt; Left[L]:\n        return self\n\n    def iter_left(self) -&gt; Iterator[L]:\n        return once(self.value)\n\n    def iter_right(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def iter_either(self: Left[T]) -&gt; Iterator[T]:\n        return once(self.value)\n\n    def async_iter_left(self) -&gt; AsyncIterator[L]:\n        return async_once(self.value)\n\n    def async_iter_right(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def async_iter_either(self: Left[T]) -&gt; AsyncIterator[T]:\n        return async_once(self.value)\n\n    def contains_left(self, value: M) -&gt; bool:\n        return self.value == value\n\n    def contains_right(self, value: S) -&gt; Literal[False]:\n        return False\n\n    def contains(self: Left[T], value: U) -&gt; bool:\n        return self.value == value\n\n    def into_result(self) -&gt; Ok[L]:\n        return Ok(self.value)\n</code></pre>"},{"location":"reference/either/#wraps.either.Right","title":"<code>Right</code>","text":"<p>               Bases: <code>EitherProtocol[Never, R]</code></p> <p><code>Right[R]</code> variant of <code>Either[L, R]</code>.</p> Source code in <code>src/wraps/either.py</code> <pre><code>@final\n@frozen()\nclass Right(EitherProtocol[Never, R]):\n    \"\"\"[`Right[R]`][wraps.either.Right] variant of [`Either[L, R]`][wraps.either.Either].\"\"\"\n\n    value: R\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, value: S) -&gt; Right[S]:\n        return cls(value)  # type: ignore[arg-type, return-value]\n\n    def is_left(self) -&gt; Literal[False]:\n        return False\n\n    def is_left_and(self, predicate: Predicate[L]) -&gt; Literal[False]:\n        return False\n\n    async def is_left_and_await(self, predicate: AsyncPredicate[L]) -&gt; Literal[False]:\n        return False\n\n    def is_right(self) -&gt; Literal[True]:\n        return True\n\n    def is_right_and(self, predicate: Predicate[R]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_right_and_await(self, predicate: AsyncPredicate[R]) -&gt; bool:\n        return await predicate(self.value)\n\n    def left(self) -&gt; Null:\n        return NULL\n\n    def left_or(self, default: L) -&gt; L:  # type: ignore[misc]\n        return default\n\n    def left_or_else(self, default: Nullary[L]) -&gt; L:\n        return default()\n\n    async def left_or_else_await(self, default: AsyncNullary[L]) -&gt; L:\n        return await default()\n\n    def right(self) -&gt; Some[R]:\n        return Some(self.value)\n\n    def right_or(self, default: R) -&gt; R:  # type: ignore[misc]\n        return self.value\n\n    def right_or_else(self, default: Nullary[R]) -&gt; R:\n        return self.value\n\n    async def right_or_else_await(self, default: AsyncNullary[R]) -&gt; R:\n        return self.value\n\n    def expect_left(self, message: str) -&gt; Never:\n        panic(message)\n\n    def expect_right(self, message: str) -&gt; R:\n        return self.value\n\n    def unwrap_left(self) -&gt; Never:\n        panic(UNWRAP_LEFT_ON_RIGHT)\n\n    def unwrap_right(self) -&gt; R:\n        return self.value\n\n    def into_either(self: Right[T]) -&gt; T:\n        return self.value\n\n    def inspect_left(self, function: Inspect[L]) -&gt; Right[R]:\n        return self\n\n    def inspect_right(self, function: Inspect[R]) -&gt; Right[R]:\n        function(self.value)\n\n        return self\n\n    async def inspect_left_await(self, function: AsyncInspect[L]) -&gt; Right[R]:\n        return self\n\n    async def inspect_right_await(self, function: AsyncInspect[R]) -&gt; Right[R]:\n        await function(self.value)\n\n        return self\n\n    def flip(self) -&gt; Left[R]:\n        return Left(self.value)\n\n    def map_left(self, function: Unary[L, M]) -&gt; Right[R]:\n        return self\n\n    async def map_left_await(self, function: AsyncUnary[L, M]) -&gt; Right[R]:\n        return self\n\n    def map_right(self, function: Unary[R, S]) -&gt; Right[S]:\n        return self.create(function(self.value))\n\n    async def map_right_await(self, function: AsyncUnary[R, S]) -&gt; Right[S]:\n        return self.create(await function(self.value))\n\n    def map(self: Right[T], function: Unary[T, U]) -&gt; Right[U]:\n        return self.create(function(self.value))\n\n    async def map_await(self: Right[T], function: AsyncUnary[T, U]) -&gt; Right[U]:\n        return self.create(await function(self.value))\n\n    def map_either(self, left: Unary[L, M], right: Unary[R, S]) -&gt; Right[S]:\n        return self.create(right(self.value))\n\n    async def map_either_await(self, left: AsyncUnary[L, M], right: AsyncUnary[R, S]) -&gt; Right[S]:\n        return self.create(await right(self.value))\n\n    def either(self, left: Unary[L, T], right: Unary[R, T]) -&gt; T:\n        return right(self.value)\n\n    async def either_await(self, left: AsyncUnary[L, T], right: AsyncUnary[R, T]) -&gt; T:\n        return await right(self.value)\n\n    def left_and_then(self, function: Unary[L, Either[M, R]]) -&gt; Right[R]:\n        return self\n\n    async def left_and_then_await(self, function: AsyncUnary[L, Either[M, R]]) -&gt; Right[R]:\n        return self\n\n    def right_and_then(self, function: Unary[R, Either[L, S]]) -&gt; Either[L, S]:\n        return function(self.value)\n\n    async def right_and_then_await(self, function: AsyncUnary[R, Either[L, S]]) -&gt; Either[L, S]:\n        return await function(self.value)\n\n    def iter_left(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def iter_right(self) -&gt; Iterator[R]:\n        return once(self.value)\n\n    def iter_either(self: Right[T]) -&gt; Iterator[T]:\n        return once(self.value)\n\n    def async_iter_left(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def async_iter_right(self) -&gt; AsyncIterator[R]:\n        return async_once(self.value)\n\n    def async_iter_either(self: Right[T]) -&gt; AsyncIterator[T]:\n        return async_once(self.value)\n\n    def contains_left(self, value: M) -&gt; Literal[False]:\n        return False\n\n    def contains_right(self, value: S) -&gt; bool:\n        return self.value == value\n\n    def contains(self: Right[T], value: U) -&gt; bool:\n        return self.value == value\n\n    def into_result(self) -&gt; Err[R]:\n        return Err(self.value)\n</code></pre>"},{"location":"reference/errors/","title":"Errors","text":""},{"location":"reference/errors/#wraps.errors.RawErrorTypes","title":"<code>RawErrorTypes = DynamicTuple[Type[E]]</code>  <code>module-attribute</code>","text":"<p>Represents error types. <code>E</code> is bound to <code>AnyError</code>.</p>"},{"location":"reference/errors/#wraps.errors.ErrorTypes","title":"<code>ErrorTypes</code>","text":"<p>               Bases: <code>Generic[E]</code></p> <p>Represents non-empty error types. <code>E</code> is bound to <code>AnyError</code>.</p> Source code in <code>src/wraps/errors.py</code> <pre><code>@final\n@frozen()\nclass ErrorTypes(Generic[E]):\n    \"\"\"Represents non-empty error types. `E` is bound to [`AnyError`][typing_aliases.AnyError].\"\"\"\n\n    raw: RawErrorTypes[E] = field()\n    \"\"\"Raw error types.\"\"\"\n\n    @raw.validator\n    def check_raw(self, attribute: Attribute[RawErrorTypes[E]], value: RawErrorTypes[E]) -&gt; None:\n        if is_empty_tuple(value):\n            panic(expected_error_types(value))\n\n    @classmethod\n    def from_head_and_tail(cls, head: Type[E], *tail: Type[E]) -&gt; Self:\n        raw = (head, *tail)\n\n        return cls(raw)\n\n    def extract(self) -&gt; RawErrorTypes[E]:\n        return self.raw\n</code></pre>"},{"location":"reference/errors/#wraps.errors.ErrorTypes.raw","title":"<code>raw: RawErrorTypes[E] = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Raw error types.</p>"},{"location":"reference/markers/","title":"Markers","text":"<p>Various markers.</p>"},{"location":"reference/markers/#wraps.markers.UNREACHABLE","title":"<code>UNREACHABLE = 'code marked as `unreachable` was reached'</code>  <code>module-attribute</code>","text":"<p>The default <code>unreachable</code> panic message.</p>"},{"location":"reference/markers/#wraps.markers.unreachable","title":"<code>unreachable(message: Optional[str] = None) -&gt; Never</code>","text":"<p>Marks points in code as unreachable.</p> <p>Panics with the message given. If not provided, <code>UNREACHABLE</code> is used.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>The message to panic with.</p> <code>None</code> <p>Raises:</p> Type Description <code>Panic</code> <p>Always raised when calling.</p> Source code in <code>src/wraps/markers.py</code> <pre><code>def unreachable(message: Optional[str] = None) -&gt; Never:\n    \"\"\"Marks points in code as unreachable.\n\n    Panics with the message given. If not provided,\n    [`UNREACHABLE`][wraps.markers.UNREACHABLE] is used.\n\n    Arguments:\n        message: The message to panic with.\n\n    Raises:\n        Panic: Always raised when calling.\n    \"\"\"\n    if message is None:\n        message = UNREACHABLE\n\n    panic(message)\n</code></pre>"},{"location":"reference/option/","title":"Option","text":"<p>Optional values.</p> <p><code>Option[T]</code> represents an optional value: every <code>Option[T]</code> is either <code>Some[T]</code> and contains a value, or <code>Null</code>, and does not.</p> <p><code>Option[T]</code> types can be very common in python code, as they have a number of uses:</p> <ul> <li>Initial values (see <code>ReAwaitable[T]</code>);</li> <li>Return values for functions not defined over their entire input range (partial functions);</li> <li>Return value for otherwise reporting simple errors, where <code>Null</code>   is returned on error;</li> <li>Optional function arguments (albeit slightly unergonomic).</li> </ul> <p><code>Option[T]</code> is commonly paired with pattern matching to query the presence of <code>Some[T]</code> value (<code>T</code>) and take action, always accounting for the <code>Null</code> case:</p> <pre><code># option.py\n\nfrom wraps import NULL, Option, Some\n\n\ndef divide(numerator: float, denominator: float) -&gt; Option[float]:\n    return Some(numerator / denominator) if denominator else NULL\n</code></pre> <pre><code>from wraps import Null, Some\n\nfrom option import divide\n\nDIVISION_BY_ZERO = \"division by zero\"\n\nmatch divide(1.0, 2.0):\n    case Some(result):\n        print(result)\n\n    case Null():\n        print(DIVISION_BY_ZERO)\n</code></pre> <p>Here, we know that <code>Null</code> represents only one case, that is, attempts to divide by zero. However, when we need to represent multiple errors from one function, we might want to use <code>Result[T, E]</code> instead, as described in the <code>result</code> section.</p>"},{"location":"reference/option/#wraps.option.Option","title":"<code>Option = Union[Some[T], Null]</code>  <code>module-attribute</code>","text":"<p>Optional value, expressed as the union of <code>Some[T]</code> and <code>Null</code>.</p>"},{"location":"reference/option/#wraps.option.NULL","title":"<code>NULL = Null()</code>  <code>module-attribute</code>","text":"<p>The instance of <code>Null</code>.</p>"},{"location":"reference/option/#wraps.option.wrap_option","title":"<code>wrap_option = wrap_option_on(NormalError)</code>  <code>module-attribute</code>","text":"<p>An instance of <code>WrapOption[NormalError]</code> (see <code>NormalError</code>).</p>"},{"location":"reference/option/#wraps.option.wrap_option_await","title":"<code>wrap_option_await = wrap_option_await_on(NormalError)</code>  <code>module-attribute</code>","text":"<p>An instance of <code>WrapOptionAwait[NormalError]</code> (see <code>NormalError</code>).</p>"},{"location":"reference/option/#wraps.option.OptionProtocol","title":"<code>OptionProtocol</code>","text":"<p>               Bases: <code>AsyncIterable[T]</code>, <code>Iterable[T]</code>, <code>Protocol[T]</code></p> Source code in <code>src/wraps/option.py</code> <pre><code>class OptionProtocol(AsyncIterable[T], Iterable[T], Protocol[T]):  # type: ignore[misc]\n    def __iter__(self) -&gt; Iterator[T]:\n        return self.iter()\n\n    def __aiter__(self) -&gt; AsyncIterator[T]:\n        return self.async_iter()\n\n    @required\n    def is_some(self) -&gt; bool:\n        \"\"\"Checks if the option is [`Some[T]`][wraps.option.Some].\n\n        Example:\n            ```python\n            some = Some(42)\n            assert some.is_some()\n\n            null = NULL\n            assert not null.is_some()\n            ```\n\n        Returns:\n            Whether the option is [`Some[T]`][wraps.option.Some].\n        \"\"\"\n        ...\n\n    @required\n    def is_some_and(self, predicate: Predicate[T]) -&gt; bool:\n        \"\"\"Checks if the option is [`Some[T]`][wraps.option.Some] and the value\n        inside of it matches the `predicate`.\n\n        Example:\n            ```python\n            def is_positive(value: int) -&gt; bool:\n                return value &gt; 0\n\n            some = Some(13)\n            assert some.is_some_and(is_positive)\n\n            zero = Some(0)\n            assert not zero.is_some_and(is_positive)\n\n            null = NULL\n            assert not null.is_some_and(is_positive)\n            ```\n\n        Arguments:\n            predicate: The predicate to check the possibly contained value against.\n\n        Returns:\n            Whether the option is [`Some[T]`][wraps.option.Some] and the predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    async def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        \"\"\"Checks if the option is [`Some[T]`][wraps.option.Some] and the value\n        inside of it matches the asynchronous `predicate`.\n\n        Example:\n            ```python\n            async def is_negative(value: int) -&gt; bool:\n                return value &lt; 0\n\n            some = Some(-42)\n            assert await some.is_some_and_await(is_negative)\n\n            zero = Some(0)\n            assert not await zero.is_some_and_await(is_negative)\n\n            null = NULL\n            assert not await null.is_some_and_await(is_negative)\n            ```\n\n        Arguments:\n            predicate: The asynchronous predicate to check the possibly contained value against.\n\n        Returns:\n            Whether the option is [`Some[T]`][wraps.option.Some] and\n            the asynchronous predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    def is_null(self) -&gt; bool:\n        \"\"\"Checks if the option is [`Null`][wraps.option.Null].\n\n        Example:\n            ```python\n            null = NULL\n            assert null.is_null()\n\n            some = Some(34)\n            assert not some.is_null()\n            ```\n\n        Returns:\n            Whether the option is [`Null`][wraps.option.Null].\n        \"\"\"\n        ...\n\n    @required\n    def expect(self, message: str) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; some.expect(\"panic!\")\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; null.expect(\"panic!\")\n            Traceback (most recent call last):\n              ...\n            wraps.panics.Panic: panic!\n            ```\n\n        Arguments:\n            message: The message to use in panicking.\n\n        Raises:\n            Panic: Panics with the `message` if the option is [`Null`][wraps.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def extract(self) -&gt; Optional[T]:\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value or [`None`][None].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; some.extract()\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; null.extract()\n            &gt;&gt;&gt; # None\n            ```\n\n        Returns:\n            The contained value or [`None`][None].\n        \"\"\"\n        ...\n\n    @required\n    def unwrap(self) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value.\n\n        Because this function may panic, its use is generally discouraged.\n\n        Instead, prefer to use pattern matching and handle the [`Null`][wraps.option.Null]\n        case explicitly, or call [`unwrap_or`][wraps.option.OptionProtocol.unwrap_or]\n        or [`unwrap_or_else`][wraps.option.OptionProtocol.unwrap_or_else].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; some.unwrap()\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; null.unwrap()\n            Traceback (most recent call last):\n              ...\n            wraps.panics.Panic: called `unwrap` on null\n            ```\n\n        Raises:\n            Panic: Panics if the option is [`Null`][wraps.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value or the provided `default`.\n\n        Example:\n            ```python\n            some = Some(13)\n            assert some.unwrap_or(0)\n\n            null = NULL\n            assert not null.unwrap_or(0)\n            ```\n\n        Arguments:\n            default: The default value to use.\n\n        Returns:\n            The contained value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value or\n        computes it from the `default` function.\n\n        Example:\n            ```python\n            some = Some(13)\n            assert some.unwrap_or_else(int)\n\n            null = NULL\n            assert not null.unwrap_or_else(int)\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n\n        Returns:\n            The contained value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value\n        or computes it from the asynchronous `default` function.\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            some = Some(42)\n            assert await some.unwrap_or_else_await(default)\n\n            null = NULL\n            assert not await null.unwrap_or_else_await(default)\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n\n        Returns:\n            The contained value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise(self, error: AnyError) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value\n        or raises the `error` provided.\n\n        Arguments:\n            error: The error to raise if the option is [`Null`][wraps.option.Null].\n\n        Raises:\n            AnyError: The error provided, if the option is [`Null`][wraps.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value\n        or raises the error computed from `error`.\n\n        Arguments:\n            error: The function computing the error to raise\n                if the option is [`Null`][wraps.option.Null].\n\n        Raises:\n            AnyError: The error computed, if the option is [`Null`][wraps.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value\n        or raises the error computed asynchronously from `error`.\n\n        Arguments:\n            error: The asynchronous function computing the error to raise\n                if the option is [`Null`][wraps.option.Null].\n\n        Raises:\n            AnyError: The error computed, if the option is [`Null`][wraps.option.Null].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def inspect(self, function: Inspect[T]) -&gt; Option[T]:\n        \"\"\"Inspects a possibly contained [`Option[T]`][wraps.option.Option] value.\n\n        Example:\n            ```python\n            some = Some(\"Hello, world!\")\n\n            same = some.inspect(print)  # Hello, world!\n\n            assert some == same\n            ```\n\n        Arguments:\n            function: The inspecting function.\n\n        Returns:\n            The inspected option.\n        \"\"\"\n        ...\n\n    @required\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Option[T]:\n        \"\"\"Inspects a possibly contained [`Option[T]`][wraps.option.Option] value.\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; None:\n                print(value)\n\n            some = Some(\"Hello, world!\")\n\n            same = await some.inspect(function)  # Hello, world!\n\n            assert some == same\n            ```\n\n        Arguments:\n            function: The asynchronous inspecting function.\n\n        Returns:\n            The inspected option.\n        \"\"\"\n        ...\n\n    @required\n    def map(self, function: Unary[T, U]) -&gt; Option[U]:\n        \"\"\"Maps an [`Option[T]`][wraps.option.Option] to an [`Option[U]`][wraps.option.Option]\n        by applying the `function` to the contained value.\n\n        Example:\n            ```python\n            some = Some(\"Hello, world!\")\n\n            print(some.map(len).unwrap())  # 13\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The mapped option.\n        \"\"\"\n        ...\n\n    @required\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        \"\"\"Returns the `default` value (if none), or applies the `function`\n        to the contained value (if any).\n\n        Example:\n            ```python\n            some = Some(\"nekit\")\n\n            print(some.map_or(42, len))  # 5\n\n            null = NULL\n\n            print(null.map_or(42, len))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        \"\"\"Computes the default value from the `default` function (if none),\n        or applies the `function` to the contained value (if any).\n\n        Example:\n            ```python\n            def default() -&gt; int:\n                return 42\n\n            some = Some(\"Hello, world!\")\n\n            print(some.map_or_else(default, len))  # 13\n\n            null = NULL\n\n            print(null.map_or_else(default, len))  # 42\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        \"\"\"Computes the default value from the asynchronous `default` function (if none),\n        or applies the `function` to the contained value (if any).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 42\n\n            some = Some(\"Hello, world!\")\n\n            print(await some.map_or_else_await(default, len))  # 13\n\n            null = NULL\n\n            print(await null.map_or_else_await(default, len))  # 42\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Option[U]:\n        \"\"\"Maps an [`Option[T]`][wraps.option.Option] to an [`Option[U]`][wraps.option.Option]\n        by applying the asynchronous `function` to the contained value.\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            some = Some(\"Hello, world!\")\n\n            mapped = await some.map_await(function)\n\n            print(some.unwrap())  # 13\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The mapped option.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        \"\"\"Returns the `default` value (if none), or applies the asynchronous `function`\n        to the contained value (if any).\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            some = Some(\"nekit\")\n\n            print(await some.map_await_or(42, function))  # 5\n\n            null = NULL\n\n            print(await null.map_await_or(42, function))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        \"\"\"Computes the default value from the `default` function (if none),\n        or applies the asynchronous `function` to the contained value (if any).\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            def default() -&gt; int:\n                return 0\n\n            some = Some(\"Hello, world!\")\n\n            print(await some.map_await_or_else(default, function))  # 13\n\n            null = NULL\n\n            print(await null.map_await_or_else(default, function))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        \"\"\"Computes the default value (if none), or applies the asynchronous `function`\n        to the contained value (if any).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 42\n\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            some = Some(\"Hello, world!\")\n\n            print(await some.map_await_or_else_await(default, function))  # 13\n\n            null = NULL\n\n            print(await null.map_await_or_else_await(default, function))  # 42\n            ```\n\n        Arguments:\n            default: The asynchronous default function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    def ok_or(self, error: E) -&gt; Result[T, E]:\n        \"\"\"Transforms an [`Option[T]`][wraps.option.Option]\n        into a [`Result[T, E]`][wraps.result.Result], mapping [`Some(value)`][wraps.option.Some]\n        to [`Ok(value)`][wraps.result.Ok] and [`Null`][wraps.option.Null]\n        to [`Err(error)`][wraps.result.Err].\n\n        Example:\n            ```python\n            error = 13\n\n            some = Some(42)\n            assert some.ok_or(error).is_ok()\n\n            null = NULL\n            assert null.ok_or(error).is_err()\n            ```\n\n        Arguments:\n            error: The error to use.\n\n        Returns:\n            The transformed result.\n        \"\"\"\n        ...\n\n    @required\n    def ok_or_else(self, error: Nullary[E]) -&gt; Result[T, E]:\n        \"\"\"Transforms an [`Option[T]`][wraps.option.Option]\n        into a [`Result[T, E]`][wraps.result.Result], mapping [`Some(value)`][wraps.option.Some]\n        to [`Ok(value)`][wraps.result.Ok] and [`Null`][wraps.option.Null]\n        to [`Err(error())`][wraps.result.Err].\n\n        Example:\n            ```python\n            def error() -&gt; Err[int]:\n                return Err(0)\n\n            some = Some(7)\n            assert some.ok_or_else(error).is_ok()\n\n            null = NULL\n            assert null.ok_or_else(error).is_err()\n            ```\n\n        Arguments:\n            error: The error-computing function to use.\n\n        Returns:\n            The transformed result.\n        \"\"\"\n        ...\n\n    @required\n    async def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Result[T, E]:\n        \"\"\"Transforms an [`Option[T]`][wraps.option.Option]\n        into a [`Result[T, E]`][wraps.result.Result], mapping [`Some(value)`][wraps.option.Some]\n        to [`Ok(value)`][wraps.result.Ok] and [`Null`][wraps.option.Null]\n        to [`Err(await error())`][wraps.result.Err].\n\n        Example:\n            ```python\n            async def error() -&gt; Err[int]:\n                return Err(0)\n\n            some = Some(7)\n            result = await some.ok_or_else_await(error)\n\n            assert result.is_ok()\n\n            null = NULL\n            result = await null.ok_or_else_await(error)\n\n            assert result.is_err()\n            ```\n\n        Arguments:\n            error: The error-computing function to use.\n\n        Returns:\n            The transformed result.\n        \"\"\"\n        ...\n\n    @required\n    def iter(self) -&gt; Iterator[T]:\n        \"\"\"Returns an iterator over the possibly contained value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; next(some.iter(), 0)\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; next(null.iter(), 0)\n            0\n            ```\n\n        Returns:\n            An iterator over the possible value.\n        \"\"\"\n        ...\n\n    @required\n    def async_iter(self) -&gt; AsyncIterator[T]:\n        \"\"\"Returns an asynchronous iterator over the possibly contained value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; some = Some(42)\n            &gt;&gt;&gt; await async_next(some.async_iter(), 0)\n            42\n            &gt;&gt;&gt; null = NULL\n            &gt;&gt;&gt; await async_next(null.async_iter(), 0)\n            0\n            ```\n\n        Returns:\n            An asynchronous iterator over the possible value.\n        \"\"\"\n        ...\n\n    @required\n    def and_then(self, function: Unary[T, Option[U]]) -&gt; Option[U]:\n        \"\"\"Returns the option if it is [`Null`][wraps.option.Null],\n        otherwise calls the `function` with the wrapped value and returns the result.\n\n        This function is also known as *bind* in functional programming.\n\n        Example:\n            ```python\n            def inverse(value: float) -&gt; Option[float]:\n                return Some(1.0 / value) if value else NULL\n\n            some = Some(2.0)\n            print(some.and_then(inverse).unwrap())  # 0.5\n\n            zero = Some(0.0)\n            assert zero.and_then(inverse).is_null()\n\n            null = NULL\n            assert null.and_then(inverse).is_null()\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    async def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Option[U]:\n        \"\"\"Returns the option if it is [`Null`][wraps.option.Null],\n        otherwise calls the asynchronous `function` with the wrapped value and returns the result.\n\n        Example:\n            ```python\n            async def inverse(value: float) -&gt; Option[float]:\n                return Some(1.0 / value) if value else NULL\n\n            some = Some(2.0)\n            option = await some.and_then_await(inverse)\n\n            print(option.unwrap())  # 0.5\n\n            zero = Some(0.0)\n            option = await zero.and_then_await(inverse)\n\n            assert option.is_null()\n\n            null = NULL\n            option = await null.and_then_await(inverse)\n\n            assert option.is_null()\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def filter(self, predicate: Predicate[T]) -&gt; Option[T]:\n        \"\"\"Returns the option if it is [`Null`][wraps.option.Null],\n        otherwise calls the `predicate` with the wrapped value and returns:\n\n        - [`Some(value)`][wraps.option.Some] if the contained `value` matches the predicate, and\n        - [`Null`][wraps.option.Null] otherwise.\n\n        Example:\n            ```python\n            def is_even(value: int) -&gt; bool:\n                return not value % 2\n\n            null = NULL\n            assert null.filter(is_even).is_null()\n\n            even = Some(2)\n            assert even.filter(is_even).is_some()\n\n            odd = Some(1)\n            assert odd.filter(is_even).is_null()\n            ```\n\n        Arguments:\n            predicate: The predicate to check the contained value against.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    async def filter_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n        \"\"\"Returns the option if it is [`Null`][wraps.option.Null],\n        otherwise calls the asynchronous `predicate` with the wrapped value and returns:\n\n        - [`Some(value)`][wraps.option.Some] if the contained `value` matches the predicate, and\n        - [`Null`][wraps.option.Null] otherwise.\n\n        Example:\n            ```python\n            async def is_even(value: int) -&gt; bool:\n                return not value % 2\n\n            null = NULL\n            assert (await null.filter_await(is_even)).is_null()\n\n            even = Some(2)\n            assert (await even.filter_await(is_even)).is_some()\n\n            odd = Some(1)\n            assert (await odd.filter_await(is_even)).is_null()\n            ```\n\n        Arguments:\n            predicate: The asynchronous predicate to check the contained value against.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def or_else(self, default: Nullary[Option[T]]) -&gt; Option[T]:\n        \"\"\"Returns the option if it contains a value, otherwise calls\n        the `default` function and returns the result.\n\n        Example:\n            ```python\n            def default() -&gt; Some[int]:\n                return Some(13)\n\n            some = Some(42)\n            null = NULL\n\n            assert some.or_else(default).is_some()\n            assert null.or_else(default).is_some()\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    async def or_else_await(self, default: AsyncNullary[Option[T]]) -&gt; Option[T]:\n        \"\"\"Returns the option if it contains a value, otherwise calls\n        the asynchronous `default` function and returns the result.\n\n        Example:\n            ```python\n            async def default() -&gt; Some[int]:\n                return Some(13)\n\n            some = Some(42)\n            null = NULL\n\n            assert (await some.or_else_await(default)).is_some()\n            assert (await null.or_else_await(default)).is_some()\n            ```\n\n        Arguments:\n            default: The asynchronous default function to use.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def xor(self, option: Option[T]) -&gt; Option[T]:\n        \"\"\"Returns [`Some[T]`][wraps.option.Some] if exactly one of `self` and `option`\n        is [`Some[T]`][wraps.option.Option], otherwise returns [`Null`][wraps.option.Null].\n\n        Example:\n            ```python\n            some = Some(69)\n            other = Some(7)\n\n            null = NULL\n\n            assert some.xor(other) == null\n            assert null.xor(other) == other\n            assert some.xor(null) == some\n            assert null.xor(null) == null\n            ```\n\n        Arguments:\n            option: The option to *xor* `self` with.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def zip(self, option: Option[U]) -&gt; Option[Tuple[T, U]]:\n        \"\"\"Zips `self` with an `option`.\n\n        If `self` is [`Some(s)`][wraps.option.Some] and `option` is [`Some(o)`][wraps.option.Some],\n        this method returns [`Some((s, o))`][wraps.option.Some]. Otherwise,\n        [`Null`][wraps.option.Null] is returned.\n\n        Example:\n            ```python\n            x = 0.7\n            y = 1.3\n\n            some_x = Some(x)\n            some_y = Some(y)\n\n            some_tuple = Some((x, y))\n\n            assert some_x.zip(some_y) == some_point\n\n            null = NULL\n\n            assert some_y.zip(null) == null\n            ```\n\n        Arguments:\n            option: The option to *zip* `self` with.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]:\n        \"\"\"Zips `self` with an `option` using `function`.\n\n        If `self` is [`Some(s)`][wraps.option.Some] and `option` is [`Some(o)`][wraps.option.Some],\n        this method returns [`Some(function(s, o))`][wraps.option.Some]. Otherwise,\n        [`Null`][wraps.option.Null] is returned.\n\n        Example:\n            ```python\n            @frozen()\n            class Point:\n                x: float\n                y: float\n\n            x = 1.3\n            y = 4.2\n\n            some_x = Some(x)\n            some_y = Some(y)\n\n            some_point = Some(Point(x, y))\n\n            assert some_x.zip_with(some_y, Point) == some_point\n\n            null = NULL\n\n            assert some_x.zip_with(null, Point) == null\n            ```\n\n        Arguments:\n            option: The option to *zip* `self` with.\n            function: The function to use for zipping.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    async def zip_with_await(self, option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Option[V]:\n        \"\"\"Zips `self` with an `option` using asynchronous `function`.\n\n        If `self` is [`Some(s)`][wraps.option.Some] and `option` is [`Some(o)`][wraps.option.Some],\n        this method returns [`Some(await function(s, o))`][wraps.option.Some]. Otherwise,\n        [`Null`][wraps.option.Null] is returned.\n\n        Example:\n            ```python\n            @frozen()\n            class Point:\n                x: float\n                y: float\n\n            async def point(x: float, y: float) -&gt; Point:\n                return Point(x, y)\n\n            x = 1.3\n            y = 4.2\n\n            some_x = Some(x)\n            some_y = Some(y)\n\n            some_point = Some(Point(x, y))\n\n            assert await some_x.zip_with(some_y, point) == some_point\n\n            null = NULL\n\n            assert await some_x.zip_with(null, point) == null\n            ```\n\n        Arguments:\n            option: The option to *zip* `self` with.\n            function: The asynchronous function to use for zipping.\n\n        Returns:\n            The resulting option.\n        \"\"\"\n        ...\n\n    @required\n    def unzip(self: OptionProtocol[Tuple[U, V]]) -&gt; Tuple[Option[U], Option[V]]:\n        \"\"\"Unzips an option into two options.\n\n        If `self` is [`Some((u, v))`][wraps.option.Some], this method returns\n        ([`Some(u)`][wraps.option.Some], [`Some(v)`][wraps.option.Some]) tuple.\n        Otherwise, ([`Null`][wraps.option.Null], [`Null`][wraps.option.Null]) is returned.\n\n        Example:\n            ```python\n            value = 13\n            other = 42\n\n            zipped = Some((value, other))\n\n            assert zipped.unzip() == (Some(value), Some(other))\n\n            null = NULL\n\n            assert null.unzip() == (NULL, NULL)\n\n        Returns:\n            The resulting tuple of two options.\n        \"\"\"\n        ...\n\n    def flatten(self: OptionProtocol[OptionProtocol[U]]) -&gt; Option[U]:\n        \"\"\"Flattens an [`Option[Option[T]]`][wraps.option.Option]\n        to [`Option[T]`][wraps.option.Option].\n\n        Example:\n            ```python\n            some = Some(42)\n            some_nested = Some(some)\n            assert some_nested.flatten() == some\n\n            null = NULL\n            null_nested = Some(null)\n            assert null_nested.flatten() == null\n\n            assert null.flatten() == null\n            ```\n\n        Returns:\n            The flattened option.\n        \"\"\"\n        return self.and_then(identity)  # type: ignore[arg-type]\n\n    @required\n    def contains(self, value: U) -&gt; bool:\n        \"\"\"Checks if the contained value (if any) is equal to `value`.\n\n        Example:\n            ```python\n            value = 42\n            other = 69\n\n            some = Some(value)\n            assert some.contains(value)\n            assert not some.contains(other)\n\n            null = NULL\n            assert not null.contains(value)\n            ```\n\n        Arguments:\n            value: The value to check against.\n\n        Returns:\n            Whether the contained value is equal to `value`.\n        \"\"\"\n        ...\n\n    @required\n    def early(self) -&gt; T:\n        \"\"\"Functionally similar to the *question-mark* (`?`) operator in Rust.\n\n        Calls to this method are to be combined with\n        [`@early_option`][wraps.early.decorators.early_option] decorators to work properly.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.is_some","title":"<code>is_some() -&gt; bool</code>","text":"<p>Checks if the option is <code>Some[T]</code>.</p> Example <pre><code>some = Some(42)\nassert some.is_some()\n\nnull = NULL\nassert not null.is_some()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the option is <code>Some[T]</code>.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef is_some(self) -&gt; bool:\n    \"\"\"Checks if the option is [`Some[T]`][wraps.option.Some].\n\n    Example:\n        ```python\n        some = Some(42)\n        assert some.is_some()\n\n        null = NULL\n        assert not null.is_some()\n        ```\n\n    Returns:\n        Whether the option is [`Some[T]`][wraps.option.Some].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.is_some_and","title":"<code>is_some_and(predicate: Predicate[T]) -&gt; bool</code>","text":"<p>Checks if the option is <code>Some[T]</code> and the value inside of it matches the <code>predicate</code>.</p> Example <pre><code>def is_positive(value: int) -&gt; bool:\n    return value &gt; 0\n\nsome = Some(13)\nassert some.is_some_and(is_positive)\n\nzero = Some(0)\nassert not zero.is_some_and(is_positive)\n\nnull = NULL\nassert not null.is_some_and(is_positive)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[T]</code> <p>The predicate to check the possibly contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the option is <code>Some[T]</code> and the predicate is matched.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef is_some_and(self, predicate: Predicate[T]) -&gt; bool:\n    \"\"\"Checks if the option is [`Some[T]`][wraps.option.Some] and the value\n    inside of it matches the `predicate`.\n\n    Example:\n        ```python\n        def is_positive(value: int) -&gt; bool:\n            return value &gt; 0\n\n        some = Some(13)\n        assert some.is_some_and(is_positive)\n\n        zero = Some(0)\n        assert not zero.is_some_and(is_positive)\n\n        null = NULL\n        assert not null.is_some_and(is_positive)\n        ```\n\n    Arguments:\n        predicate: The predicate to check the possibly contained value against.\n\n    Returns:\n        Whether the option is [`Some[T]`][wraps.option.Some] and the predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.is_some_and_await","title":"<code>is_some_and_await(predicate: AsyncPredicate[T]) -&gt; bool</code>  <code>async</code>","text":"<p>Checks if the option is <code>Some[T]</code> and the value inside of it matches the asynchronous <code>predicate</code>.</p> Example <pre><code>async def is_negative(value: int) -&gt; bool:\n    return value &lt; 0\n\nsome = Some(-42)\nassert await some.is_some_and_await(is_negative)\n\nzero = Some(0)\nassert not await zero.is_some_and_await(is_negative)\n\nnull = NULL\nassert not await null.is_some_and_await(is_negative)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>AsyncPredicate[T]</code> <p>The asynchronous predicate to check the possibly contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the option is <code>Some[T]</code> and</p> <code>bool</code> <p>the asynchronous predicate is matched.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n    \"\"\"Checks if the option is [`Some[T]`][wraps.option.Some] and the value\n    inside of it matches the asynchronous `predicate`.\n\n    Example:\n        ```python\n        async def is_negative(value: int) -&gt; bool:\n            return value &lt; 0\n\n        some = Some(-42)\n        assert await some.is_some_and_await(is_negative)\n\n        zero = Some(0)\n        assert not await zero.is_some_and_await(is_negative)\n\n        null = NULL\n        assert not await null.is_some_and_await(is_negative)\n        ```\n\n    Arguments:\n        predicate: The asynchronous predicate to check the possibly contained value against.\n\n    Returns:\n        Whether the option is [`Some[T]`][wraps.option.Some] and\n        the asynchronous predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.is_null","title":"<code>is_null() -&gt; bool</code>","text":"<p>Checks if the option is <code>Null</code>.</p> Example <pre><code>null = NULL\nassert null.is_null()\n\nsome = Some(34)\nassert not some.is_null()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the option is <code>Null</code>.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef is_null(self) -&gt; bool:\n    \"\"\"Checks if the option is [`Null`][wraps.option.Null].\n\n    Example:\n        ```python\n        null = NULL\n        assert null.is_null()\n\n        some = Some(34)\n        assert not some.is_null()\n        ```\n\n    Returns:\n        Whether the option is [`Null`][wraps.option.Null].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.expect","title":"<code>expect(message: str) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; some.expect(\"panic!\")\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; null.expect(\"panic!\")\nTraceback (most recent call last):\n  ...\nwraps.panics.Panic: panic!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to use in panicking.</p> required <p>Raises:</p> Type Description <code>Panic</code> <p>Panics with the <code>message</code> if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef expect(self, message: str) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; some.expect(\"panic!\")\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; null.expect(\"panic!\")\n        Traceback (most recent call last):\n          ...\n        wraps.panics.Panic: panic!\n        ```\n\n    Arguments:\n        message: The message to use in panicking.\n\n    Raises:\n        Panic: Panics with the `message` if the option is [`Null`][wraps.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.extract","title":"<code>extract() -&gt; Optional[T]</code>","text":"<p>Returns the contained <code>Some[T]</code> value or <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; some.extract()\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; null.extract()\n&gt;&gt;&gt; # None\n</code></pre> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The contained value or <code>None</code>.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef extract(self) -&gt; Optional[T]:\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value or [`None`][None].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; some.extract()\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; null.extract()\n        &gt;&gt;&gt; # None\n        ```\n\n    Returns:\n        The contained value or [`None`][None].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.unwrap","title":"<code>unwrap() -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value.</p> <p>Because this function may panic, its use is generally discouraged.</p> <p>Instead, prefer to use pattern matching and handle the <code>Null</code> case explicitly, or call <code>unwrap_or</code> or <code>unwrap_or_else</code>.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; some.unwrap()\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; null.unwrap()\nTraceback (most recent call last):\n  ...\nwraps.panics.Panic: called `unwrap` on null\n</code></pre> <p>Raises:</p> Type Description <code>Panic</code> <p>Panics if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef unwrap(self) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value.\n\n    Because this function may panic, its use is generally discouraged.\n\n    Instead, prefer to use pattern matching and handle the [`Null`][wraps.option.Null]\n    case explicitly, or call [`unwrap_or`][wraps.option.OptionProtocol.unwrap_or]\n    or [`unwrap_or_else`][wraps.option.OptionProtocol.unwrap_or_else].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; some.unwrap()\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; null.unwrap()\n        Traceback (most recent call last):\n          ...\n        wraps.panics.Panic: called `unwrap` on null\n        ```\n\n    Raises:\n        Panic: Panics if the option is [`Null`][wraps.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.unwrap_or","title":"<code>unwrap_or(default: T) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value or the provided <code>default</code>.</p> Example <pre><code>some = Some(13)\nassert some.unwrap_or(0)\n\nnull = NULL\nassert not null.unwrap_or(0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>T</code> <p>The default value to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>default</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value or the provided `default`.\n\n    Example:\n        ```python\n        some = Some(13)\n        assert some.unwrap_or(0)\n\n        null = NULL\n        assert not null.unwrap_or(0)\n        ```\n\n    Arguments:\n        default: The default value to use.\n\n    Returns:\n        The contained value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.unwrap_or_else","title":"<code>unwrap_or_else(default: Nullary[T]) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value or computes it from the <code>default</code> function.</p> Example <pre><code>some = Some(13)\nassert some.unwrap_or_else(int)\n\nnull = NULL\nassert not null.unwrap_or_else(int)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[T]</code> <p>The default-computing function to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>default()</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value or\n    computes it from the `default` function.\n\n    Example:\n        ```python\n        some = Some(13)\n        assert some.unwrap_or_else(int)\n\n        null = NULL\n        assert not null.unwrap_or_else(int)\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n\n    Returns:\n        The contained value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.unwrap_or_else_await","title":"<code>unwrap_or_else_await(default: AsyncNullary[T]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Some[T]</code> value or computes it from the asynchronous <code>default</code> function.</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nsome = Some(42)\nassert await some.unwrap_or_else_await(default)\n\nnull = NULL\nassert not await null.unwrap_or_else_await(default)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[T]</code> <p>The asynchronous default-computing function to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>await default()</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value\n    or computes it from the asynchronous `default` function.\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        some = Some(42)\n        assert await some.unwrap_or_else_await(default)\n\n        null = NULL\n        assert not await null.unwrap_or_else_await(default)\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n\n    Returns:\n        The contained value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.or_raise","title":"<code>or_raise(error: AnyError) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value or raises the <code>error</code> provided.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AnyError</code> <p>The error to raise if the option is <code>Null</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error provided, if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef or_raise(self, error: AnyError) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value\n    or raises the `error` provided.\n\n    Arguments:\n        error: The error to raise if the option is [`Null`][wraps.option.Null].\n\n    Raises:\n        AnyError: The error provided, if the option is [`Null`][wraps.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.or_raise_with","title":"<code>or_raise_with(error: Nullary[AnyError]) -&gt; T</code>","text":"<p>Returns the contained <code>Some[T]</code> value or raises the error computed from <code>error</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Nullary[AnyError]</code> <p>The function computing the error to raise if the option is <code>Null</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value\n    or raises the error computed from `error`.\n\n    Arguments:\n        error: The function computing the error to raise\n            if the option is [`Null`][wraps.option.Null].\n\n    Raises:\n        AnyError: The error computed, if the option is [`Null`][wraps.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.or_raise_with_await","title":"<code>or_raise_with_await(error: AsyncNullary[AnyError]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Some[T]</code> value or raises the error computed asynchronously from <code>error</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AsyncNullary[AnyError]</code> <p>The asynchronous function computing the error to raise if the option is <code>Null</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the option is <code>Null</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Some[T]`][wraps.option.Some] value\n    or raises the error computed asynchronously from `error`.\n\n    Arguments:\n        error: The asynchronous function computing the error to raise\n            if the option is [`Null`][wraps.option.Null].\n\n    Raises:\n        AnyError: The error computed, if the option is [`Null`][wraps.option.Null].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.inspect","title":"<code>inspect(function: Inspect[T]) -&gt; Option[T]</code>","text":"<p>Inspects a possibly contained <code>Option[T]</code> value.</p> Example <pre><code>some = Some(\"Hello, world!\")\n\nsame = some.inspect(print)  # Hello, world!\n\nassert some == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Inspect[T]</code> <p>The inspecting function.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The inspected option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef inspect(self, function: Inspect[T]) -&gt; Option[T]:\n    \"\"\"Inspects a possibly contained [`Option[T]`][wraps.option.Option] value.\n\n    Example:\n        ```python\n        some = Some(\"Hello, world!\")\n\n        same = some.inspect(print)  # Hello, world!\n\n        assert some == same\n        ```\n\n    Arguments:\n        function: The inspecting function.\n\n    Returns:\n        The inspected option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.inspect_await","title":"<code>inspect_await(function: AsyncInspect[T]) -&gt; Option[T]</code>  <code>async</code>","text":"<p>Inspects a possibly contained <code>Option[T]</code> value.</p> Example <pre><code>async def function(value: str) -&gt; None:\n    print(value)\n\nsome = Some(\"Hello, world!\")\n\nsame = await some.inspect(function)  # Hello, world!\n\nassert some == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncInspect[T]</code> <p>The asynchronous inspecting function.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The inspected option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def inspect_await(self, function: AsyncInspect[T]) -&gt; Option[T]:\n    \"\"\"Inspects a possibly contained [`Option[T]`][wraps.option.Option] value.\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; None:\n            print(value)\n\n        some = Some(\"Hello, world!\")\n\n        same = await some.inspect(function)  # Hello, world!\n\n        assert some == same\n        ```\n\n    Arguments:\n        function: The asynchronous inspecting function.\n\n    Returns:\n        The inspected option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.map","title":"<code>map(function: Unary[T, U]) -&gt; Option[U]</code>","text":"<p>Maps an <code>Option[T]</code> to an <code>Option[U]</code> by applying the <code>function</code> to the contained value.</p> Example <pre><code>some = Some(\"Hello, world!\")\n\nprint(some.map(len).unwrap())  # 13\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Option[U]</code> <p>The mapped option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef map(self, function: Unary[T, U]) -&gt; Option[U]:\n    \"\"\"Maps an [`Option[T]`][wraps.option.Option] to an [`Option[U]`][wraps.option.Option]\n    by applying the `function` to the contained value.\n\n    Example:\n        ```python\n        some = Some(\"Hello, world!\")\n\n        print(some.map(len).unwrap())  # 13\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The mapped option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.map_or","title":"<code>map_or(default: U, function: Unary[T, U]) -&gt; U</code>","text":"<p>Returns the <code>default</code> value (if none), or applies the <code>function</code> to the contained value (if any).</p> Example <pre><code>some = Some(\"nekit\")\n\nprint(some.map_or(42, len))  # 5\n\nnull = NULL\n\nprint(null.map_or(42, len))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>U</code> <p>The default value to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>default</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n    \"\"\"Returns the `default` value (if none), or applies the `function`\n    to the contained value (if any).\n\n    Example:\n        ```python\n        some = Some(\"nekit\")\n\n        print(some.map_or(42, len))  # 5\n\n        null = NULL\n\n        print(null.map_or(42, len))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.map_or_else","title":"<code>map_or_else(default: Nullary[U], function: Unary[T, U]) -&gt; U</code>","text":"<p>Computes the default value from the <code>default</code> function (if none), or applies the <code>function</code> to the contained value (if any).</p> Example <pre><code>def default() -&gt; int:\n    return 42\n\nsome = Some(\"Hello, world!\")\n\nprint(some.map_or_else(default, len))  # 13\n\nnull = NULL\n\nprint(null.map_or_else(default, len))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[U]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>default()</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n    \"\"\"Computes the default value from the `default` function (if none),\n    or applies the `function` to the contained value (if any).\n\n    Example:\n        ```python\n        def default() -&gt; int:\n            return 42\n\n        some = Some(\"Hello, world!\")\n\n        print(some.map_or_else(default, len))  # 13\n\n        null = NULL\n\n        print(null.map_or_else(default, len))  # 42\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.map_or_else_await","title":"<code>map_or_else_await(default: AsyncNullary[U], function: Unary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value from the asynchronous <code>default</code> function (if none), or applies the <code>function</code> to the contained value (if any).</p> Example <pre><code>async def default() -&gt; int:\n    return 42\n\nsome = Some(\"Hello, world!\")\n\nprint(await some.map_or_else_await(default, len))  # 13\n\nnull = NULL\n\nprint(await null.map_or_else_await(default, len))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[U]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>await default()</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n    \"\"\"Computes the default value from the asynchronous `default` function (if none),\n    or applies the `function` to the contained value (if any).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 42\n\n        some = Some(\"Hello, world!\")\n\n        print(await some.map_or_else_await(default, len))  # 13\n\n        null = NULL\n\n        print(await null.map_or_else_await(default, len))  # 42\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.map_await","title":"<code>map_await(function: AsyncUnary[T, U]) -&gt; Option[U]</code>  <code>async</code>","text":"<p>Maps an <code>Option[T]</code> to an <code>Option[U]</code> by applying the asynchronous <code>function</code> to the contained value.</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\nsome = Some(\"Hello, world!\")\n\nmapped = await some.map_await(function)\n\nprint(some.unwrap())  # 13\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Option[U]</code> <p>The mapped option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def map_await(self, function: AsyncUnary[T, U]) -&gt; Option[U]:\n    \"\"\"Maps an [`Option[T]`][wraps.option.Option] to an [`Option[U]`][wraps.option.Option]\n    by applying the asynchronous `function` to the contained value.\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        some = Some(\"Hello, world!\")\n\n        mapped = await some.map_await(function)\n\n        print(some.unwrap())  # 13\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The mapped option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.map_await_or","title":"<code>map_await_or(default: U, function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Returns the <code>default</code> value (if none), or applies the asynchronous <code>function</code> to the contained value (if any).</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\nsome = Some(\"nekit\")\n\nprint(await some.map_await_or(42, function))  # 5\n\nnull = NULL\n\nprint(await null.map_await_or(42, function))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>U</code> <p>The default value to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>default</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n    \"\"\"Returns the `default` value (if none), or applies the asynchronous `function`\n    to the contained value (if any).\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        some = Some(\"nekit\")\n\n        print(await some.map_await_or(42, function))  # 5\n\n        null = NULL\n\n        print(await null.map_await_or(42, function))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.map_await_or_else","title":"<code>map_await_or_else(default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value from the <code>default</code> function (if none), or applies the asynchronous <code>function</code> to the contained value (if any).</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\ndef default() -&gt; int:\n    return 0\n\nsome = Some(\"Hello, world!\")\n\nprint(await some.map_await_or_else(default, function))  # 13\n\nnull = NULL\n\nprint(await null.map_await_or_else(default, function))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[U]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>default()</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n    \"\"\"Computes the default value from the `default` function (if none),\n    or applies the asynchronous `function` to the contained value (if any).\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        def default() -&gt; int:\n            return 0\n\n        some = Some(\"Hello, world!\")\n\n        print(await some.map_await_or_else(default, function))  # 13\n\n        null = NULL\n\n        print(await null.map_await_or_else(default, function))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.map_await_or_else_await","title":"<code>map_await_or_else_await(default: AsyncNullary[U], function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value (if none), or applies the asynchronous <code>function</code> to the contained value (if any).</p> Example <pre><code>async def default() -&gt; int:\n    return 42\n\nasync def function(value: str) -&gt; int:\n    return len(value)\n\nsome = Some(\"Hello, world!\")\n\nprint(await some.map_await_or_else_await(default, function))  # 13\n\nnull = NULL\n\nprint(await null.map_await_or_else_await(default, function))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[U]</code> <p>The asynchronous default function to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting value or the <code>await default()</code> one.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def map_await_or_else_await(\n    self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n) -&gt; U:\n    \"\"\"Computes the default value (if none), or applies the asynchronous `function`\n    to the contained value (if any).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 42\n\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        some = Some(\"Hello, world!\")\n\n        print(await some.map_await_or_else_await(default, function))  # 13\n\n        null = NULL\n\n        print(await null.map_await_or_else_await(default, function))  # 42\n        ```\n\n    Arguments:\n        default: The asynchronous default function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.ok_or","title":"<code>ok_or(error: E) -&gt; Result[T, E]</code>","text":"<p>Transforms an <code>Option[T]</code> into a <code>Result[T, E]</code>, mapping <code>Some(value)</code> to <code>Ok(value)</code> and <code>Null</code> to <code>Err(error)</code>.</p> Example <pre><code>error = 13\n\nsome = Some(42)\nassert some.ok_or(error).is_ok()\n\nnull = NULL\nassert null.ok_or(error).is_err()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>E</code> <p>The error to use.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The transformed result.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef ok_or(self, error: E) -&gt; Result[T, E]:\n    \"\"\"Transforms an [`Option[T]`][wraps.option.Option]\n    into a [`Result[T, E]`][wraps.result.Result], mapping [`Some(value)`][wraps.option.Some]\n    to [`Ok(value)`][wraps.result.Ok] and [`Null`][wraps.option.Null]\n    to [`Err(error)`][wraps.result.Err].\n\n    Example:\n        ```python\n        error = 13\n\n        some = Some(42)\n        assert some.ok_or(error).is_ok()\n\n        null = NULL\n        assert null.ok_or(error).is_err()\n        ```\n\n    Arguments:\n        error: The error to use.\n\n    Returns:\n        The transformed result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.ok_or_else","title":"<code>ok_or_else(error: Nullary[E]) -&gt; Result[T, E]</code>","text":"<p>Transforms an <code>Option[T]</code> into a <code>Result[T, E]</code>, mapping <code>Some(value)</code> to <code>Ok(value)</code> and <code>Null</code> to <code>Err(error())</code>.</p> Example <pre><code>def error() -&gt; Err[int]:\n    return Err(0)\n\nsome = Some(7)\nassert some.ok_or_else(error).is_ok()\n\nnull = NULL\nassert null.ok_or_else(error).is_err()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Nullary[E]</code> <p>The error-computing function to use.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The transformed result.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef ok_or_else(self, error: Nullary[E]) -&gt; Result[T, E]:\n    \"\"\"Transforms an [`Option[T]`][wraps.option.Option]\n    into a [`Result[T, E]`][wraps.result.Result], mapping [`Some(value)`][wraps.option.Some]\n    to [`Ok(value)`][wraps.result.Ok] and [`Null`][wraps.option.Null]\n    to [`Err(error())`][wraps.result.Err].\n\n    Example:\n        ```python\n        def error() -&gt; Err[int]:\n            return Err(0)\n\n        some = Some(7)\n        assert some.ok_or_else(error).is_ok()\n\n        null = NULL\n        assert null.ok_or_else(error).is_err()\n        ```\n\n    Arguments:\n        error: The error-computing function to use.\n\n    Returns:\n        The transformed result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.ok_or_else_await","title":"<code>ok_or_else_await(error: AsyncNullary[E]) -&gt; Result[T, E]</code>  <code>async</code>","text":"<p>Transforms an <code>Option[T]</code> into a <code>Result[T, E]</code>, mapping <code>Some(value)</code> to <code>Ok(value)</code> and <code>Null</code> to <code>Err(await error())</code>.</p> Example <pre><code>async def error() -&gt; Err[int]:\n    return Err(0)\n\nsome = Some(7)\nresult = await some.ok_or_else_await(error)\n\nassert result.is_ok()\n\nnull = NULL\nresult = await null.ok_or_else_await(error)\n\nassert result.is_err()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AsyncNullary[E]</code> <p>The error-computing function to use.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The transformed result.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Result[T, E]:\n    \"\"\"Transforms an [`Option[T]`][wraps.option.Option]\n    into a [`Result[T, E]`][wraps.result.Result], mapping [`Some(value)`][wraps.option.Some]\n    to [`Ok(value)`][wraps.result.Ok] and [`Null`][wraps.option.Null]\n    to [`Err(await error())`][wraps.result.Err].\n\n    Example:\n        ```python\n        async def error() -&gt; Err[int]:\n            return Err(0)\n\n        some = Some(7)\n        result = await some.ok_or_else_await(error)\n\n        assert result.is_ok()\n\n        null = NULL\n        result = await null.ok_or_else_await(error)\n\n        assert result.is_err()\n        ```\n\n    Arguments:\n        error: The error-computing function to use.\n\n    Returns:\n        The transformed result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.iter","title":"<code>iter() -&gt; Iterator[T]</code>","text":"<p>Returns an iterator over the possibly contained value.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; next(some.iter(), 0)\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; next(null.iter(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>An iterator over the possible value.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef iter(self) -&gt; Iterator[T]:\n    \"\"\"Returns an iterator over the possibly contained value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; next(some.iter(), 0)\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; next(null.iter(), 0)\n        0\n        ```\n\n    Returns:\n        An iterator over the possible value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.async_iter","title":"<code>async_iter() -&gt; AsyncIterator[T]</code>","text":"<p>Returns an asynchronous iterator over the possibly contained value.</p> Example <pre><code>&gt;&gt;&gt; some = Some(42)\n&gt;&gt;&gt; await async_next(some.async_iter(), 0)\n42\n&gt;&gt;&gt; null = NULL\n&gt;&gt;&gt; await async_next(null.async_iter(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>AsyncIterator[T]</code> <p>An asynchronous iterator over the possible value.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef async_iter(self) -&gt; AsyncIterator[T]:\n    \"\"\"Returns an asynchronous iterator over the possibly contained value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; some = Some(42)\n        &gt;&gt;&gt; await async_next(some.async_iter(), 0)\n        42\n        &gt;&gt;&gt; null = NULL\n        &gt;&gt;&gt; await async_next(null.async_iter(), 0)\n        0\n        ```\n\n    Returns:\n        An asynchronous iterator over the possible value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.and_then","title":"<code>and_then(function: Unary[T, Option[U]]) -&gt; Option[U]</code>","text":"<p>Returns the option if it is <code>Null</code>, otherwise calls the <code>function</code> with the wrapped value and returns the result.</p> <p>This function is also known as bind in functional programming.</p> Example <pre><code>def inverse(value: float) -&gt; Option[float]:\n    return Some(1.0 / value) if value else NULL\n\nsome = Some(2.0)\nprint(some.and_then(inverse).unwrap())  # 0.5\n\nzero = Some(0.0)\nassert zero.and_then(inverse).is_null()\n\nnull = NULL\nassert null.and_then(inverse).is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, Option[U]]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Option[U]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef and_then(self, function: Unary[T, Option[U]]) -&gt; Option[U]:\n    \"\"\"Returns the option if it is [`Null`][wraps.option.Null],\n    otherwise calls the `function` with the wrapped value and returns the result.\n\n    This function is also known as *bind* in functional programming.\n\n    Example:\n        ```python\n        def inverse(value: float) -&gt; Option[float]:\n            return Some(1.0 / value) if value else NULL\n\n        some = Some(2.0)\n        print(some.and_then(inverse).unwrap())  # 0.5\n\n        zero = Some(0.0)\n        assert zero.and_then(inverse).is_null()\n\n        null = NULL\n        assert null.and_then(inverse).is_null()\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.and_then_await","title":"<code>and_then_await(function: AsyncUnary[T, Option[U]]) -&gt; Option[U]</code>  <code>async</code>","text":"<p>Returns the option if it is <code>Null</code>, otherwise calls the asynchronous <code>function</code> with the wrapped value and returns the result.</p> Example <pre><code>async def inverse(value: float) -&gt; Option[float]:\n    return Some(1.0 / value) if value else NULL\n\nsome = Some(2.0)\noption = await some.and_then_await(inverse)\n\nprint(option.unwrap())  # 0.5\n\nzero = Some(0.0)\noption = await zero.and_then_await(inverse)\n\nassert option.is_null()\n\nnull = NULL\noption = await null.and_then_await(inverse)\n\nassert option.is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, Option[U]]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Option[U]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Option[U]:\n    \"\"\"Returns the option if it is [`Null`][wraps.option.Null],\n    otherwise calls the asynchronous `function` with the wrapped value and returns the result.\n\n    Example:\n        ```python\n        async def inverse(value: float) -&gt; Option[float]:\n            return Some(1.0 / value) if value else NULL\n\n        some = Some(2.0)\n        option = await some.and_then_await(inverse)\n\n        print(option.unwrap())  # 0.5\n\n        zero = Some(0.0)\n        option = await zero.and_then_await(inverse)\n\n        assert option.is_null()\n\n        null = NULL\n        option = await null.and_then_await(inverse)\n\n        assert option.is_null()\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.filter","title":"<code>filter(predicate: Predicate[T]) -&gt; Option[T]</code>","text":"<p>Returns the option if it is <code>Null</code>, otherwise calls the <code>predicate</code> with the wrapped value and returns:</p> <ul> <li><code>Some(value)</code> if the contained <code>value</code> matches the predicate, and</li> <li><code>Null</code> otherwise.</li> </ul> Example <pre><code>def is_even(value: int) -&gt; bool:\n    return not value % 2\n\nnull = NULL\nassert null.filter(is_even).is_null()\n\neven = Some(2)\nassert even.filter(is_even).is_some()\n\nodd = Some(1)\nassert odd.filter(is_even).is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[T]</code> <p>The predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef filter(self, predicate: Predicate[T]) -&gt; Option[T]:\n    \"\"\"Returns the option if it is [`Null`][wraps.option.Null],\n    otherwise calls the `predicate` with the wrapped value and returns:\n\n    - [`Some(value)`][wraps.option.Some] if the contained `value` matches the predicate, and\n    - [`Null`][wraps.option.Null] otherwise.\n\n    Example:\n        ```python\n        def is_even(value: int) -&gt; bool:\n            return not value % 2\n\n        null = NULL\n        assert null.filter(is_even).is_null()\n\n        even = Some(2)\n        assert even.filter(is_even).is_some()\n\n        odd = Some(1)\n        assert odd.filter(is_even).is_null()\n        ```\n\n    Arguments:\n        predicate: The predicate to check the contained value against.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.filter_await","title":"<code>filter_await(predicate: AsyncPredicate[T]) -&gt; Option[T]</code>  <code>async</code>","text":"<p>Returns the option if it is <code>Null</code>, otherwise calls the asynchronous <code>predicate</code> with the wrapped value and returns:</p> <ul> <li><code>Some(value)</code> if the contained <code>value</code> matches the predicate, and</li> <li><code>Null</code> otherwise.</li> </ul> Example <pre><code>async def is_even(value: int) -&gt; bool:\n    return not value % 2\n\nnull = NULL\nassert (await null.filter_await(is_even)).is_null()\n\neven = Some(2)\nassert (await even.filter_await(is_even)).is_some()\n\nodd = Some(1)\nassert (await odd.filter_await(is_even)).is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>AsyncPredicate[T]</code> <p>The asynchronous predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def filter_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n    \"\"\"Returns the option if it is [`Null`][wraps.option.Null],\n    otherwise calls the asynchronous `predicate` with the wrapped value and returns:\n\n    - [`Some(value)`][wraps.option.Some] if the contained `value` matches the predicate, and\n    - [`Null`][wraps.option.Null] otherwise.\n\n    Example:\n        ```python\n        async def is_even(value: int) -&gt; bool:\n            return not value % 2\n\n        null = NULL\n        assert (await null.filter_await(is_even)).is_null()\n\n        even = Some(2)\n        assert (await even.filter_await(is_even)).is_some()\n\n        odd = Some(1)\n        assert (await odd.filter_await(is_even)).is_null()\n        ```\n\n    Arguments:\n        predicate: The asynchronous predicate to check the contained value against.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.or_else","title":"<code>or_else(default: Nullary[Option[T]]) -&gt; Option[T]</code>","text":"<p>Returns the option if it contains a value, otherwise calls the <code>default</code> function and returns the result.</p> Example <pre><code>def default() -&gt; Some[int]:\n    return Some(13)\n\nsome = Some(42)\nnull = NULL\n\nassert some.or_else(default).is_some()\nassert null.or_else(default).is_some()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[Option[T]]</code> <p>The default-computing function to use.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef or_else(self, default: Nullary[Option[T]]) -&gt; Option[T]:\n    \"\"\"Returns the option if it contains a value, otherwise calls\n    the `default` function and returns the result.\n\n    Example:\n        ```python\n        def default() -&gt; Some[int]:\n            return Some(13)\n\n        some = Some(42)\n        null = NULL\n\n        assert some.or_else(default).is_some()\n        assert null.or_else(default).is_some()\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.or_else_await","title":"<code>or_else_await(default: AsyncNullary[Option[T]]) -&gt; Option[T]</code>  <code>async</code>","text":"<p>Returns the option if it contains a value, otherwise calls the asynchronous <code>default</code> function and returns the result.</p> Example <pre><code>async def default() -&gt; Some[int]:\n    return Some(13)\n\nsome = Some(42)\nnull = NULL\n\nassert (await some.or_else_await(default)).is_some()\nassert (await null.or_else_await(default)).is_some()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[Option[T]]</code> <p>The asynchronous default function to use.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def or_else_await(self, default: AsyncNullary[Option[T]]) -&gt; Option[T]:\n    \"\"\"Returns the option if it contains a value, otherwise calls\n    the asynchronous `default` function and returns the result.\n\n    Example:\n        ```python\n        async def default() -&gt; Some[int]:\n            return Some(13)\n\n        some = Some(42)\n        null = NULL\n\n        assert (await some.or_else_await(default)).is_some()\n        assert (await null.or_else_await(default)).is_some()\n        ```\n\n    Arguments:\n        default: The asynchronous default function to use.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.xor","title":"<code>xor(option: Option[T]) -&gt; Option[T]</code>","text":"<p>Returns <code>Some[T]</code> if exactly one of <code>self</code> and <code>option</code> is <code>Some[T]</code>, otherwise returns <code>Null</code>.</p> Example <pre><code>some = Some(69)\nother = Some(7)\n\nnull = NULL\n\nassert some.xor(other) == null\nassert null.xor(other) == other\nassert some.xor(null) == some\nassert null.xor(null) == null\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option[T]</code> <p>The option to xor <code>self</code> with.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef xor(self, option: Option[T]) -&gt; Option[T]:\n    \"\"\"Returns [`Some[T]`][wraps.option.Some] if exactly one of `self` and `option`\n    is [`Some[T]`][wraps.option.Option], otherwise returns [`Null`][wraps.option.Null].\n\n    Example:\n        ```python\n        some = Some(69)\n        other = Some(7)\n\n        null = NULL\n\n        assert some.xor(other) == null\n        assert null.xor(other) == other\n        assert some.xor(null) == some\n        assert null.xor(null) == null\n        ```\n\n    Arguments:\n        option: The option to *xor* `self` with.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.zip","title":"<code>zip(option: Option[U]) -&gt; Option[Tuple[T, U]]</code>","text":"<p>Zips <code>self</code> with an <code>option</code>.</p> <p>If <code>self</code> is <code>Some(s)</code> and <code>option</code> is <code>Some(o)</code>, this method returns <code>Some((s, o))</code>. Otherwise, <code>Null</code> is returned.</p> Example <pre><code>x = 0.7\ny = 1.3\n\nsome_x = Some(x)\nsome_y = Some(y)\n\nsome_tuple = Some((x, y))\n\nassert some_x.zip(some_y) == some_point\n\nnull = NULL\n\nassert some_y.zip(null) == null\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option[U]</code> <p>The option to zip <code>self</code> with.</p> required <p>Returns:</p> Type Description <code>Option[Tuple[T, U]]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef zip(self, option: Option[U]) -&gt; Option[Tuple[T, U]]:\n    \"\"\"Zips `self` with an `option`.\n\n    If `self` is [`Some(s)`][wraps.option.Some] and `option` is [`Some(o)`][wraps.option.Some],\n    this method returns [`Some((s, o))`][wraps.option.Some]. Otherwise,\n    [`Null`][wraps.option.Null] is returned.\n\n    Example:\n        ```python\n        x = 0.7\n        y = 1.3\n\n        some_x = Some(x)\n        some_y = Some(y)\n\n        some_tuple = Some((x, y))\n\n        assert some_x.zip(some_y) == some_point\n\n        null = NULL\n\n        assert some_y.zip(null) == null\n        ```\n\n    Arguments:\n        option: The option to *zip* `self` with.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.zip_with","title":"<code>zip_with(option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]</code>","text":"<p>Zips <code>self</code> with an <code>option</code> using <code>function</code>.</p> <p>If <code>self</code> is <code>Some(s)</code> and <code>option</code> is <code>Some(o)</code>, this method returns <code>Some(function(s, o))</code>. Otherwise, <code>Null</code> is returned.</p> Example <pre><code>@frozen()\nclass Point:\n    x: float\n    y: float\n\nx = 1.3\ny = 4.2\n\nsome_x = Some(x)\nsome_y = Some(y)\n\nsome_point = Some(Point(x, y))\n\nassert some_x.zip_with(some_y, Point) == some_point\n\nnull = NULL\n\nassert some_x.zip_with(null, Point) == null\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option[U]</code> <p>The option to zip <code>self</code> with.</p> required <code>function</code> <code>Binary[T, U, V]</code> <p>The function to use for zipping.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]:\n    \"\"\"Zips `self` with an `option` using `function`.\n\n    If `self` is [`Some(s)`][wraps.option.Some] and `option` is [`Some(o)`][wraps.option.Some],\n    this method returns [`Some(function(s, o))`][wraps.option.Some]. Otherwise,\n    [`Null`][wraps.option.Null] is returned.\n\n    Example:\n        ```python\n        @frozen()\n        class Point:\n            x: float\n            y: float\n\n        x = 1.3\n        y = 4.2\n\n        some_x = Some(x)\n        some_y = Some(y)\n\n        some_point = Some(Point(x, y))\n\n        assert some_x.zip_with(some_y, Point) == some_point\n\n        null = NULL\n\n        assert some_x.zip_with(null, Point) == null\n        ```\n\n    Arguments:\n        option: The option to *zip* `self` with.\n        function: The function to use for zipping.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.zip_with_await","title":"<code>zip_with_await(option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Option[V]</code>  <code>async</code>","text":"<p>Zips <code>self</code> with an <code>option</code> using asynchronous <code>function</code>.</p> <p>If <code>self</code> is <code>Some(s)</code> and <code>option</code> is <code>Some(o)</code>, this method returns <code>Some(await function(s, o))</code>. Otherwise, <code>Null</code> is returned.</p> Example <pre><code>@frozen()\nclass Point:\n    x: float\n    y: float\n\nasync def point(x: float, y: float) -&gt; Point:\n    return Point(x, y)\n\nx = 1.3\ny = 4.2\n\nsome_x = Some(x)\nsome_y = Some(y)\n\nsome_point = Some(Point(x, y))\n\nassert await some_x.zip_with(some_y, point) == some_point\n\nnull = NULL\n\nassert await some_x.zip_with(null, point) == null\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option[U]</code> <p>The option to zip <code>self</code> with.</p> required <code>function</code> <code>AsyncBinary[T, U, V]</code> <p>The asynchronous function to use for zipping.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>The resulting option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\nasync def zip_with_await(self, option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Option[V]:\n    \"\"\"Zips `self` with an `option` using asynchronous `function`.\n\n    If `self` is [`Some(s)`][wraps.option.Some] and `option` is [`Some(o)`][wraps.option.Some],\n    this method returns [`Some(await function(s, o))`][wraps.option.Some]. Otherwise,\n    [`Null`][wraps.option.Null] is returned.\n\n    Example:\n        ```python\n        @frozen()\n        class Point:\n            x: float\n            y: float\n\n        async def point(x: float, y: float) -&gt; Point:\n            return Point(x, y)\n\n        x = 1.3\n        y = 4.2\n\n        some_x = Some(x)\n        some_y = Some(y)\n\n        some_point = Some(Point(x, y))\n\n        assert await some_x.zip_with(some_y, point) == some_point\n\n        null = NULL\n\n        assert await some_x.zip_with(null, point) == null\n        ```\n\n    Arguments:\n        option: The option to *zip* `self` with.\n        function: The asynchronous function to use for zipping.\n\n    Returns:\n        The resulting option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.unzip","title":"<code>unzip() -&gt; Tuple[Option[U], Option[V]]</code>","text":"<p>Unzips an option into two options.</p> <p>If <code>self</code> is <code>Some((u, v))</code>, this method returns (<code>Some(u)</code>, <code>Some(v)</code>) tuple. Otherwise, (<code>Null</code>, <code>Null</code>) is returned.</p> Example <p>```python value = 13 other = 42</p> <p>zipped = Some((value, other))</p> <p>assert zipped.unzip() == (Some(value), Some(other))</p> <p>null = NULL</p> <p>assert null.unzip() == (NULL, NULL)</p> <p>Returns:</p> Type Description <code>Tuple[Option[U], Option[V]]</code> <p>The resulting tuple of two options.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef unzip(self: OptionProtocol[Tuple[U, V]]) -&gt; Tuple[Option[U], Option[V]]:\n    \"\"\"Unzips an option into two options.\n\n    If `self` is [`Some((u, v))`][wraps.option.Some], this method returns\n    ([`Some(u)`][wraps.option.Some], [`Some(v)`][wraps.option.Some]) tuple.\n    Otherwise, ([`Null`][wraps.option.Null], [`Null`][wraps.option.Null]) is returned.\n\n    Example:\n        ```python\n        value = 13\n        other = 42\n\n        zipped = Some((value, other))\n\n        assert zipped.unzip() == (Some(value), Some(other))\n\n        null = NULL\n\n        assert null.unzip() == (NULL, NULL)\n\n    Returns:\n        The resulting tuple of two options.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.flatten","title":"<code>flatten() -&gt; Option[U]</code>","text":"<p>Flattens an <code>Option[Option[T]]</code> to <code>Option[T]</code>.</p> Example <pre><code>some = Some(42)\nsome_nested = Some(some)\nassert some_nested.flatten() == some\n\nnull = NULL\nnull_nested = Some(null)\nassert null_nested.flatten() == null\n\nassert null.flatten() == null\n</code></pre> <p>Returns:</p> Type Description <code>Option[U]</code> <p>The flattened option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>def flatten(self: OptionProtocol[OptionProtocol[U]]) -&gt; Option[U]:\n    \"\"\"Flattens an [`Option[Option[T]]`][wraps.option.Option]\n    to [`Option[T]`][wraps.option.Option].\n\n    Example:\n        ```python\n        some = Some(42)\n        some_nested = Some(some)\n        assert some_nested.flatten() == some\n\n        null = NULL\n        null_nested = Some(null)\n        assert null_nested.flatten() == null\n\n        assert null.flatten() == null\n        ```\n\n    Returns:\n        The flattened option.\n    \"\"\"\n    return self.and_then(identity)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.contains","title":"<code>contains(value: U) -&gt; bool</code>","text":"<p>Checks if the contained value (if any) is equal to <code>value</code>.</p> Example <pre><code>value = 42\nother = 69\n\nsome = Some(value)\nassert some.contains(value)\nassert not some.contains(other)\n\nnull = NULL\nassert not null.contains(value)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>U</code> <p>The value to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the contained value is equal to <code>value</code>.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef contains(self, value: U) -&gt; bool:\n    \"\"\"Checks if the contained value (if any) is equal to `value`.\n\n    Example:\n        ```python\n        value = 42\n        other = 69\n\n        some = Some(value)\n        assert some.contains(value)\n        assert not some.contains(other)\n\n        null = NULL\n        assert not null.contains(value)\n        ```\n\n    Arguments:\n        value: The value to check against.\n\n    Returns:\n        Whether the contained value is equal to `value`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.OptionProtocol.early","title":"<code>early() -&gt; T</code>","text":"<p>Functionally similar to the question-mark (<code>?</code>) operator in Rust.</p> <p>Calls to this method are to be combined with <code>@early_option</code> decorators to work properly.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@required\ndef early(self) -&gt; T:\n    \"\"\"Functionally similar to the *question-mark* (`?`) operator in Rust.\n\n    Calls to this method are to be combined with\n    [`@early_option`][wraps.early.decorators.early_option] decorators to work properly.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/option/#wraps.option.Null","title":"<code>Null</code>","text":"<p>               Bases: <code>OptionProtocol[Never]</code></p> <p>The <code>Null</code> variant of <code>Option[T]</code>.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@final\n@frozen()\nclass Null(OptionProtocol[Never]):\n    \"\"\"The [`Null`][wraps.option.Null] variant of [`Option[T]`][wraps.option.Option].\"\"\"\n\n    def __bool__(self) -&gt; Literal[False]:\n        return False\n\n    def __repr__(self) -&gt; str:\n        return empty_repr(self)\n\n    @classmethod\n    def create(cls) -&gt; Null:\n        return cls()\n\n    def is_some(self) -&gt; Literal[False]:\n        return False\n\n    def is_some_and(self, predicate: Predicate[T]) -&gt; Literal[False]:\n        return False\n\n    async def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; Literal[False]:\n        return False\n\n    def is_null(self) -&gt; Literal[True]:\n        return True\n\n    def expect(self, message: str) -&gt; Never:\n        panic(message)\n\n    def extract(self) -&gt; None:\n        return None\n\n    def unwrap(self) -&gt; Never:\n        panic(UNWRAP_ON_NULL)\n\n    def unwrap_or(self, default: U) -&gt; U:\n        return default\n\n    def unwrap_or_else(self, default: Nullary[U]) -&gt; U:\n        return default()\n\n    async def unwrap_or_else_await(self, default: AsyncNullary[U]) -&gt; U:\n        return await default()\n\n    def or_raise(self, error: AnyError) -&gt; Never:\n        raise error\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; Never:\n        raise error()\n\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; Never:\n        raise await error()\n\n    def inspect(self, function: Inspect[T]) -&gt; Null:\n        return self\n\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Null:\n        return self\n\n    def map(self, function: Unary[T, U]) -&gt; Null:\n        return self\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return default\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return default()\n\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return await default()\n\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Null:\n        return self\n\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return default\n\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return default()\n\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await default()\n\n    def ok_or(self, error: E) -&gt; Err[E]:\n        return Err(error)\n\n    def ok_or_else(self, error: Nullary[E]) -&gt; Err[E]:\n        return Err(error())\n\n    async def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Err[E]:\n        return Err(await error())\n\n    def iter(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def async_iter(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def and_then(self, function: Unary[T, Option[U]]) -&gt; Null:\n        return self\n\n    async def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Null:\n        return self\n\n    def filter(self, predicate: Predicate[T]) -&gt; Null:\n        return self\n\n    async def filter_await(self, predicate: AsyncPredicate[T]) -&gt; Null:\n        return self\n\n    def or_else(self, default: Nullary[Option[T]]) -&gt; Option[T]:\n        return default()\n\n    async def or_else_await(self, default: AsyncNullary[Option[T]]) -&gt; Option[T]:\n        return await default()\n\n    def xor(self, option: Option[T]) -&gt; Option[T]:\n        return option\n\n    def zip(self, option: Option[U]) -&gt; Null:\n        return self\n\n    def zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Null:\n        return self\n\n    async def zip_with_await(self, option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Null:\n        return self\n\n    def unzip(self) -&gt; Tuple[Null, Null]:\n        return self, self\n\n    def contains(self, value: U) -&gt; Literal[False]:\n        return False\n\n    def early(self) -&gt; Never:\n        raise EarlyOption()\n</code></pre>"},{"location":"reference/option/#wraps.option.Some","title":"<code>Some</code>","text":"<p>               Bases: <code>OptionProtocol[T]</code></p> <p><code>Some[T]</code> variant of <code>Option[T]</code>.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@final\n@frozen()\nclass Some(OptionProtocol[T]):\n    \"\"\"[`Some[T]`][wraps.option.Some] variant of [`Option[T]`][wraps.option.Option].\"\"\"\n\n    value: T\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, value: U) -&gt; Some[U]:\n        return cls(value)  # type: ignore[arg-type, return-value]\n\n    def is_some(self) -&gt; Literal[True]:\n        return True\n\n    def is_some_and(self, predicate: Predicate[T]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        return await predicate(self.value)\n\n    def is_null(self) -&gt; Literal[False]:\n        return False\n\n    def expect(self, message: str) -&gt; T:\n        return self.value\n\n    def extract(self) -&gt; T:\n        return self.value\n\n    def unwrap(self) -&gt; T:\n        return self.value\n\n    def unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n        return self.value\n\n    def unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n        return self.value\n\n    def or_raise(self, error: AnyError) -&gt; T:\n        return self.value\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        return self.value\n\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        return self.value\n\n    async def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n        return self.value\n\n    def inspect(self, function: Inspect[T]) -&gt; Some[T]:\n        function(self.value)\n\n        return self\n\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Some[T]:\n        await function(self.value)\n\n        return self\n\n    def map(self, function: Unary[T, U]) -&gt; Some[U]:\n        return self.create(function(self.value))\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Some[U]:\n        return self.create(await function(self.value))\n\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return await function(self.value)\n\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return await function(self.value)\n\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await function(self.value)\n\n    def ok_or(self, error: E) -&gt; Ok[T]:\n        return Ok(self.value)\n\n    def ok_or_else(self, error: Nullary[E]) -&gt; Ok[T]:\n        return Ok(self.value)\n\n    async def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Ok[T]:\n        return Ok(self.value)\n\n    def iter(self) -&gt; Iterator[T]:\n        return once(self.value)\n\n    def async_iter(self) -&gt; AsyncIterator[T]:\n        return async_once(self.value)\n\n    def and_then(self, function: Unary[T, Option[U]]) -&gt; Option[U]:\n        return function(self.value)\n\n    async def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Option[U]:\n        return await function(self.value)\n\n    def filter(self, predicate: Predicate[T]) -&gt; Option[T]:\n        return self if predicate(self.value) else NULL\n\n    async def filter_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n        return self if await predicate(self.value) else NULL\n\n    def or_else(self, default: Nullary[Option[T]]) -&gt; Some[T]:\n        return self\n\n    async def or_else_await(self, default: AsyncNullary[Option[T]]) -&gt; Some[T]:\n        return self\n\n    def xor(self, option: Option[T]) -&gt; Option[T]:\n        return self if is_null(option) else NULL\n\n    @overload\n    def zip(self, option: Null) -&gt; Null: ...\n\n    @overload\n    def zip(self, option: Some[U]) -&gt; Some[Tuple[T, U]]: ...\n\n    @overload\n    def zip(self, option: Option[U]) -&gt; Option[Tuple[T, U]]: ...\n\n    def zip(self, option: Option[U]) -&gt; Option[Tuple[T, U]]:\n        return self.create((self.value, option.value)) if is_some(option) else NULL\n\n    @overload\n    def zip_with(self, option: Null, function: Binary[T, U, V]) -&gt; Null: ...\n\n    @overload\n    def zip_with(self, option: Some[U], function: Binary[T, U, V]) -&gt; Some[V]: ...\n\n    @overload\n    def zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]: ...\n\n    def zip_with(self, option: Option[U], function: Binary[T, U, V]) -&gt; Option[V]:\n        return self.create(function(self.value, option.value)) if is_some(option) else NULL\n\n    @overload\n    async def zip_with_await(self, option: Null, function: AsyncBinary[T, U, V]) -&gt; Null: ...\n\n    @overload\n    async def zip_with_await(self, option: Some[U], function: AsyncBinary[T, U, V]) -&gt; Some[V]: ...\n\n    @overload\n    async def zip_with_await(\n        self, option: Option[U], function: AsyncBinary[T, U, V]\n    ) -&gt; Option[V]: ...\n\n    async def zip_with_await(self, option: Option[U], function: AsyncBinary[T, U, V]) -&gt; Option[V]:\n        return self.create(await function(self.value, option.value)) if is_some(option) else NULL\n\n    def unzip(self: Some[Tuple[U, V]]) -&gt; Tuple[Some[U], Some[V]]:\n        u, v = self.value\n\n        return self.create(u), self.create(v)\n\n    def contains(self, value: U) -&gt; bool:\n        return self.value == value\n\n    def early(self) -&gt; T:\n        return self.value\n</code></pre>"},{"location":"reference/option/#wraps.option.WrapOption","title":"<code>WrapOption</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Wraps functions returning <code>T</code> into functions returning <code>Option[T]</code>.</p> <p>Errors are handled via returning <code>NULL</code> on <code>error</code> of <code>error_types</code>, wrapping the resulting <code>value</code> into <code>Some(value)</code>.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@final\n@frozen()\nclass WrapOption(Generic[A]):\n    \"\"\"Wraps functions returning `T` into functions returning\n    [`Option[T]`][wraps.option.Option].\n\n    Errors are handled via returning [`NULL`][wraps.option.NULL] on `error` of\n    [`error_types`][wraps.option.WrapOption.error_types], wrapping the resulting\n    `value` into [`Some(value)`][wraps.option.Some].\n    \"\"\"\n\n    error_types: ErrorTypes[A]\n    \"\"\"The error types to handle. See [`ErrorTypes[A]`][wraps.errors.ErrorTypes].\"\"\"\n\n    def __call__(self, function: Callable[P, T]) -&gt; OptionCallable[P, T]:\n        @wraps(function)\n        def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Option[T]:\n            try:\n                return Some(function(*args, **kwargs))\n\n            except self.error_types.extract():\n                return NULL\n\n        return wrap\n</code></pre>"},{"location":"reference/option/#wraps.option.WrapOption.error_types","title":"<code>error_types: ErrorTypes[A]</code>  <code>instance-attribute</code>","text":"<p>The error types to handle. See <code>ErrorTypes[A]</code>.</p>"},{"location":"reference/option/#wraps.option.WrapOptionAwait","title":"<code>WrapOptionAwait</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Wraps asynchronous functions returning <code>T</code> into functions returning <code>Option[T]</code>.</p> <p>Errors are handled via returning <code>NULL</code> on <code>error</code> of <code>error_types</code>, wrapping the resulting <code>value</code> into <code>Some(value)</code>.</p> Source code in <code>src/wraps/option.py</code> <pre><code>@final\n@frozen()\nclass WrapOptionAwait(Generic[A]):\n    \"\"\"Wraps asynchronous functions returning `T` into functions returning\n    [`Option[T]`][wraps.option.Option].\n\n    Errors are handled via returning [`NULL`][wraps.option.NULL] on `error` of\n    [`error_types`][wraps.option.WrapOptionAwait.error_types], wrapping the resulting\n    `value` into [`Some(value)`][wraps.option.Some].\n    \"\"\"\n\n    error_types: ErrorTypes[A]\n    \"\"\"The error types to handle. See [`ErrorTypes[A]`][wraps.errors.ErrorTypes].\"\"\"\n\n    def __call__(self, function: AsyncCallable[P, T]) -&gt; OptionAsyncCallable[P, T]:\n        @wraps(function)\n        async def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Option[T]:\n            try:\n                return Some(await function(*args, **kwargs))\n\n            except self.error_types.extract():\n                return NULL\n\n        return wrap\n</code></pre>"},{"location":"reference/option/#wraps.option.WrapOptionAwait.error_types","title":"<code>error_types: ErrorTypes[A]</code>  <code>instance-attribute</code>","text":"<p>The error types to handle. See <code>ErrorTypes[A]</code>.</p>"},{"location":"reference/option/#wraps.option.is_some","title":"<code>is_some(option: Option[T]) -&gt; TypeIs[Some[T]]</code>","text":"<p>This is the same as <code>Option.is_some</code>, except it works as a type guard.</p> Source code in <code>src/wraps/option.py</code> <pre><code>def is_some(option: Option[T]) -&gt; TypeIs[Some[T]]:\n    \"\"\"This is the same as [`Option.is_some`][wraps.option.OptionProtocol.is_some],\n    except it works as a *type guard*.\n    \"\"\"\n    return option.is_some()\n</code></pre>"},{"location":"reference/option/#wraps.option.is_null","title":"<code>is_null(option: Option[T]) -&gt; TypeIs[Null]</code>","text":"<p>This is the same as <code>Option.is_null</code>, except it works as a type guard.</p> Source code in <code>src/wraps/option.py</code> <pre><code>def is_null(option: Option[T]) -&gt; TypeIs[Null]:\n    \"\"\"This is the same as [`Option.is_null`][wraps.option.OptionProtocol.is_null],\n    except it works as a *type guard*.\n    \"\"\"\n    return option.is_null()\n</code></pre>"},{"location":"reference/option/#wraps.option.wrap_optional","title":"<code>wrap_optional(optional: Optional[T]) -&gt; Option[T]</code>","text":"<p>Wraps <code>Optional[T]</code> into <code>Option[T]</code>.</p> <p>If the argument is <code>None</code>, <code>NULL</code> is returned. Otherwise the <code>value</code> (of type <code>T</code>) is wrapped into <code>Some(value)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>optional</code> <code>Optional[T]</code> <p>The optional value to wrap.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>The wrapped option.</p> Source code in <code>src/wraps/option.py</code> <pre><code>def wrap_optional(optional: Optional[T]) -&gt; Option[T]:\n    \"\"\"Wraps [`Optional[T]`][typing.Optional] into [`Option[T]`][wraps.option.Option].\n\n    If the argument is [`None`][None], [`NULL`][wraps.option.NULL] is returned.\n    Otherwise the `value` (of type `T`) is wrapped into [`Some(value)`][wraps.option.Some].\n\n    Arguments:\n        optional: The optional value to wrap.\n\n    Returns:\n        The wrapped option.\n    \"\"\"\n    return NULL if optional is None else Some(optional)\n</code></pre>"},{"location":"reference/option/#wraps.option.wrap_option_on","title":"<code>wrap_option_on(head: Type[A], *tail: Type[A]) -&gt; WrapOption[A]</code>","text":"<p>Creates <code>WrapOption[A]</code> decorators.</p> <p>This function enforces at least one error type to be provided.</p> Example <pre><code>@wrap_option_on(ValueError)\ndef parse(string: str) -&gt; int:\n    return int(string)\n\nassert parse(\"256\").is_some()\nassert parse(\"uwu\").is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>Type[A]</code> <p>The head of the error types to handle.</p> required <code>*tail</code> <code>Type[A]</code> <p>The tail of the error types to handle.</p> <code>()</code> <p>Returns:</p> Type Description <code>WrapOption[A]</code> <p>The <code>WrapOption[A]</code> decorator created.</p> Source code in <code>src/wraps/option.py</code> <pre><code>def wrap_option_on(head: Type[A], *tail: Type[A]) -&gt; WrapOption[A]:\n    \"\"\"Creates [`WrapOption[A]`][wraps.option.WrapOption] decorators.\n\n    This function enforces at least one error type to be provided.\n\n    Example:\n        ```python\n        @wrap_option_on(ValueError)\n        def parse(string: str) -&gt; int:\n            return int(string)\n\n        assert parse(\"256\").is_some()\n        assert parse(\"uwu\").is_null()\n        ```\n\n    Arguments:\n        head: The head of the error types to handle.\n        *tail: The tail of the error types to handle.\n\n    Returns:\n        The [`WrapOption[A]`][wraps.option.WrapOption] decorator created.\n    \"\"\"\n    return WrapOption(ErrorTypes[A].from_head_and_tail(head, *tail))\n</code></pre>"},{"location":"reference/option/#wraps.option.wrap_option_await_on","title":"<code>wrap_option_await_on(head: Type[A], *tail: Type[A]) -&gt; WrapOptionAwait[A]</code>","text":"<p>Creates <code>WrapOptionAwait[A]</code> decorators.</p> <p>This function enforces at least one error type to be provided.</p> Example <pre><code>@wrap_option_await_on(ValueError)\nasync def parse(string: str) -&gt; int:\n    return int(string)\n\nassert (await parse(\"256\")).is_some()\nassert (await parse(\"uwu\")).is_null()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>Type[A]</code> <p>The head of the error types to handle.</p> required <code>*tail</code> <code>Type[A]</code> <p>The tail of the error types to handle.</p> <code>()</code> <p>Returns:</p> Type Description <code>WrapOptionAwait[A]</code> <p>The <code>WrapOptionAwait[A]</code> decorator created.</p> Source code in <code>src/wraps/option.py</code> <pre><code>def wrap_option_await_on(head: Type[A], *tail: Type[A]) -&gt; WrapOptionAwait[A]:\n    \"\"\"Creates [`WrapOptionAwait[A]`][wraps.option.WrapOptionAwait] decorators.\n\n    This function enforces at least one error type to be provided.\n\n    Example:\n        ```python\n        @wrap_option_await_on(ValueError)\n        async def parse(string: str) -&gt; int:\n            return int(string)\n\n        assert (await parse(\"256\")).is_some()\n        assert (await parse(\"uwu\")).is_null()\n        ```\n\n    Arguments:\n        head: The head of the error types to handle.\n        *tail: The tail of the error types to handle.\n\n    Returns:\n        The [`WrapOptionAwait[A]`][wraps.option.WrapOptionAwait] decorator created.\n    \"\"\"\n    return WrapOptionAwait(ErrorTypes[A].from_head_and_tail(head, *tail))\n</code></pre>"},{"location":"reference/panics/","title":"Panics","text":"<p>Panics represented as errors.</p>"},{"location":"reference/panics/#wraps.panics.Panic","title":"<code>Panic</code>","text":"<p>               Bases: <code>AnyError</code></p> <p>Represents panics as errors.</p> <p>Panics should not be explicitly handled in general, therefore <code>Panic</code> is derived from <code>AnyError</code>.</p> Source code in <code>src/wraps/panics.py</code> <pre><code>class Panic(AnyError):\n    \"\"\"Represents panics as errors.\n\n    Panics should not be explicitly handled in general, therefore [`Panic`][wraps.panics.Panic]\n    is derived from [`AnyError`][typing_aliases.AnyError].\n    \"\"\"\n\n    def __init__(self, message: Optional[str] = None) -&gt; None:\n        self._message = message\n\n        if message is None:\n            message = PANIC\n\n        super().__init__(message)\n\n    @property\n    def message(self) -&gt; Optional[str]:\n        return self._message\n</code></pre>"},{"location":"reference/panics/#wraps.panics.panic","title":"<code>panic(message: Optional[str] = None) -&gt; Never</code>","text":"<p>Panics with the optional message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>The message to panic with.</p> <code>None</code> <p>Raises:</p> Type Description <code>Panic</code> <p>Always raised.</p> Source code in <code>src/wraps/panics.py</code> <pre><code>def panic(message: Optional[str] = None) -&gt; Never:\n    \"\"\"Panics with the optional message.\n\n    Arguments:\n        message: The message to panic with.\n\n    Raises:\n        Panic: Always raised.\n    \"\"\"\n    raise Panic(message)\n</code></pre>"},{"location":"reference/result/","title":"Result","text":"<p>Error handling with the <code>Result[T, E]</code> type.</p> <p><code>Result[T, E]</code> is the type used for returning and propagating errors.</p> <p>It is an enum with the variants, <code>Ok[T]</code>, representing success and containing a value, and <code>Err[E]</code>, representing error and containing an error value.</p> <p>Functions return <code>Result[T, E]</code> whenever errors are expected and recoverable.</p> <p>For instance, our <code>divide</code> function from the <code>option</code> section:</p> <pre><code># result.py\n\nfrom enum import Enum\n\nfrom wraps import Err, Ok, Result\n\n\nclass Error(Enum):\n    DIVISION_BY_ZERO = \"division by zero\"\n\n\ndef divide(numerator: float, denominator: float) -&gt; Result[float, Error]:\n    return Ok(numerator / denominator) if denominator else Err(Error.DIVISION_BY_ZERO)\n</code></pre> <pre><code>from wraps import Err, Ok\n\nfrom result import divide\n\nresult = divide(1.0, 2.0)\n\nmatch result:\n    case Ok(value):\n        print(value)\n\n    case Err(error):\n        print(error.value)  # get the string `value` of the enumeration member\n</code></pre>"},{"location":"reference/result/#wraps.result.Result","title":"<code>Result = Union[Ok[T], Err[E]]</code>  <code>module-attribute</code>","text":"<p>Result value, expressed as the union of <code>Ok[T]</code> and <code>Err[E]</code>.</p>"},{"location":"reference/result/#wraps.result.wrap_result","title":"<code>wrap_result = wrap_result_on(NormalError)</code>  <code>module-attribute</code>","text":"<p>An instance of <code>WrapResult[NormalError]</code> (see <code>NormalError</code>).</p>"},{"location":"reference/result/#wraps.result.wrap_result_await","title":"<code>wrap_result_await = wrap_result_await_on(NormalError)</code>  <code>module-attribute</code>","text":"<p>An instance of <code>WrapResultAwait[NormalError]</code> (see <code>NormalError</code>).</p>"},{"location":"reference/result/#wraps.result.ResultProtocol","title":"<code>ResultProtocol</code>","text":"<p>               Bases: <code>AsyncIterable[T]</code>, <code>Iterable[T]</code>, <code>Protocol[T, E]</code></p> Source code in <code>src/wraps/result.py</code> <pre><code>class ResultProtocol(AsyncIterable[T], Iterable[T], Protocol[T, E]):  # type: ignore[misc]\n    def __iter__(self) -&gt; Iterator[T]:\n        return self.iter()\n\n    def __aiter__(self) -&gt; AsyncIterator[T]:\n        return self.async_iter()\n\n    @required\n    def is_ok(self) -&gt; bool:\n        \"\"\"Checks if the result is [`Ok[T]`][wraps.result.Ok].\n\n        Example:\n            ```python\n            ok = Ok(42)\n            assert ok.is_ok()\n\n            err = Err(13)\n            assert not err.is_ok()\n            ```\n\n        Returns:\n            Whether the result is [`Ok[T]`][wraps.result.Ok].\n        \"\"\"\n        ...\n\n    @required\n    def is_ok_and(self, predicate: Predicate[T]) -&gt; bool:\n        \"\"\"Checks if the result is [`Ok[T]`][wraps.result.Ok] and the value\n        inside of it matches the `predicate`.\n\n        Example:\n            ```python\n            def is_positive(value: int) -&gt; bool:\n                return value &gt; 0\n\n            ok = Ok(13)\n            assert ok.is_ok_and(is_positive)\n\n            zero = Ok(0)\n            assert not zero.is_ok_and(is_positive)\n\n            err = Err(7)\n            assert not err.is_ok_and(is_positive)\n            ```\n\n        Arguments:\n            predicate: The predicate to check the contained value against.\n\n        Returns:\n            Whether the result is [`Ok[T]`][wraps.result.Ok] and the predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    async def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        \"\"\"Checks if the result is [`Ok[T]`][wraps.result.Ok] and the value\n        inside of it matches the asynchronous `predicate`.\n\n        Example:\n            ```python\n            async def is_positive(value: int) -&gt; bool:\n                return value &gt; 0\n\n            ok = Ok(13)\n            assert await ok.is_ok_and_await(is_positive)\n\n            zero = Ok(0)\n            assert not await zero.is_ok_and_await(is_positive)\n\n            err = Err(7)\n            assert not await err.is_ok_and_await(is_positive)\n            ```\n\n        Arguments:\n            predicate: The asynchronous predicate to check the contained value against.\n\n        Returns:\n            Whether the result is [`Ok[T]`][wraps.result.Ok] and\n            the asynchronous predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    def is_err(self) -&gt; bool:\n        \"\"\"Checks if the result is [`Err[E]`][wraps.result.Err].\n\n        Example:\n            ```python\n            err = Err(34)\n            assert err.is_err()\n\n            ok = Ok(69)\n            assert not ok.is_err()\n            ```\n\n        Returns:\n            Whether the result is [`Err[E]`][wraps.result.Err].\n        \"\"\"\n        ...\n\n    @required\n    def is_err_and(self, predicate: Predicate[E]) -&gt; bool:\n        \"\"\"Checks if the result is [`Err[E]`][wraps.result.Err] and the value\n        inside of it matches the `predicate`.\n\n        Example:\n            ```python\n            def is_negative(value: int) -&gt; bool:\n                return value &lt; 0\n\n            err = Err(-13)\n            assert err.is_err_and(is_positive)\n\n            zero = Err(0)\n            assert not zero.is_err_and(is_positive)\n\n            ok = Ok(7)\n            assert not ok.is_err_and(is_positive)\n            ```\n\n        Arguments:\n            predicate: The predicate to check the contained value against.\n\n        Returns:\n            Whether the result is [`Err[E]`][wraps.result.Err] and the predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    async def is_err_and_await(self, predicate: AsyncPredicate[E]) -&gt; bool:\n        \"\"\"Checks if the result is [`Err[E]`][wraps.result.Err] and the value\n        inside of it matches the asynchronous `predicate`.\n\n        Example:\n            ```python\n            async def is_negative(value: int) -&gt; bool:\n                return value &lt; 0\n\n            err = Err(-13)\n            assert await err.is_err_and_await(is_negative)\n\n            zero = Err(0)\n            assert not await zero.is_err_and_await(is_negative)\n\n            ok = Ok(7)\n            assert not await ok.is_err_and_await(is_negative)\n            ```\n\n        Arguments:\n            predicate: The asynchronous predicate to check the contained value against.\n\n        Returns:\n            Whether the result is [`Err[E]`][wraps.result.Err] and\n            the asynchronous predicate is matched.\n        \"\"\"\n        ...\n\n    @required\n    def expect(self, message: str) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; ok.expect(\"error!\")\n            42\n            &gt;&gt;&gt; err = Err(0)\n            &gt;&gt;&gt; err.expect(\"error!\")\n            Traceback (most recent call last):\n              ...\n            wraps.panics.Panic: error!\n            ```\n\n        Arguments:\n            message: The message used in panicking.\n\n        Raises:\n            Panic: Panics with the `message` if the result is [`Err[E]`][wraps.result.Err].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def expect_err(self, message: str) -&gt; E:\n        \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; ok.expect_err(\"ok!\")\n            Traceback (most recent call last):\n              ...\n            wraps.panics.Panic: ok!\n\n            &gt;&gt;&gt; err = Err(0)\n            &gt;&gt;&gt; err.expect_err(\"ok!\")\n            0\n            ```\n\n        Arguments:\n            message: The message used in panicking.\n\n        Raises:\n            Panic: Panics with the `message` if the result is [`Ok[T]`][wraps.result.Ok].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap(self) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value (of type `T`).\n\n        Because this function may panic, its use is generally discouraged.\n\n        Instead, prefer to use pattern matching and handle the [`Err[E]`][wraps.result.Err]\n        case explicitly, or call [`unwrap_or`][wraps.result.ResultProtocol.unwrap_or]\n        or [`unwrap_or_else`][wraps.result.ResultProtocol.unwrap_or_else].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(13)\n            &gt;&gt;&gt; ok.unwrap()\n            13\n\n            &gt;&gt;&gt; err = Err(0)\n            &gt;&gt;&gt; err.unwrap()\n            Traceback (most recent call last):\n              ...\n            wraps.panics.Panic: called `unwrap` on err\n            ```\n\n        Raises:\n            Panic: Panics if the result is [`Err[E]`][wraps.result.Err].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value or the provided `default`.\n\n        Example:\n            ```python\n            ok = Ok(69)\n            assert ok.unwrap_or(0)\n\n            err = Err(13)\n            assert not err.unwrap_or(0)\n            ```\n\n        Arguments:\n            default: The default value to use.\n\n        Returns:\n            The contained value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n        or computes it from the `default` function.\n\n        Example:\n            ```python\n            ok = Ok(5)\n            assert ok.unwrap_or_else(int)\n\n            err = Err(8)\n            assert not err.unwrap_or_else(int)\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n\n        Returns:\n            The contained value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n        or computes it from the asynchronous `default` function.\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            ok = Ok(5)\n            assert await ok.unwrap_or_else_await(default)\n\n            err = Err(8)\n            assert not await err.unwrap_or_else_await(default)\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n\n        Returns:\n            The contained value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise(self, error: AnyError) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n        or raises the `error` provided.\n\n        Arguments:\n            error: The error to raise if the result is [`Err[E]`][wraps.result.Err].\n\n        Raises:\n            AnyError: The error provided, if the result is [`Err[E]`][wraps.result.Err].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n        or raises the error computed from `error`.\n\n        Arguments:\n            error: The function computing the error to raise\n                if the result is [`Err[E]`][wraps.result.Err].\n\n        Raises:\n            AnyError: The error computed, if the result is [`Err[E]`][wraps.result.Err].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n        or raises the error computed asynchronously from `error`.\n\n        Arguments:\n            error: The asynchronous function computing the error to raise\n                if the result is [`Err[E]`][wraps.result.Err].\n\n        Raises:\n            AnyError: The error computed, if the result is [`Err[E]`][wraps.result.Err].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def or_raise_from(self, error: Unary[E, AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n        or raises the error computed from `error` that receives the contained\n        [`Err[E]`][wraps.result.Err] value.\n\n        Arguments:\n            error: The function computing the error to raise\n                if the result is [`Err[E]`][wraps.result.Err].\n\n        Raises:\n            AnyError: The error computed, if the result is [`Err[E]`][wraps.result.Err].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    async def or_raise_from_await(self, error: AsyncUnary[E, AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n        or raise the error computed asynchronously from `error` that receives the contained\n        [`Err[E]`][wraps.result.Err] value.\n\n        Arguments:\n            error: The asynchronous function computing the error to raise\n                if the result is [`Err[E]`][wraps.result.Err].\n\n        Raises:\n            AnyError: The error computed, if the result is [`Err[E]`][wraps.result.Err].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_err(self) -&gt; E:\n        \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value.\n\n        Because this function may panic, its use is generally discouraged.\n\n        Instead, prefer to use pattern matching and handle the [`Ok[T]`][wraps.result.Ok]\n        case explicitly, or call [`unwrap_err_or`][wraps.result.ResultProtocol.unwrap_err_or]\n        or [`unwrap_err_or_else`][wraps.result.ResultProtocol.unwrap_err_or_else].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; err = Err(13)\n            &gt;&gt;&gt; err.unwrap_err()\n            13\n\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; ok.unwrap_err()\n            Traceback (most recent call last):\n              ...\n            wraps.panics.Panic: called `unwrap_err` on ok\n            ```\n\n        Raises:\n            Panic: Panics if the result is [`Ok[T]`][wraps.result.Ok].\n\n        Returns:\n            The contained error value.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_err_or(self, default: E) -&gt; E:  # type: ignore[misc]\n        \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value (of type `E`)\n        or a provided default.\n\n        Example:\n            ```python\n            err = Err(1)\n            assert err.unwrap_err_or(0)\n\n            ok = Ok(2)\n            assert not ok.unwrap_err_or(0)\n            ```\n\n        Arguments:\n            default: The default value to use.\n\n        Returns:\n            The contained error value or the `default` one.\n        \"\"\"\n        ...\n\n    @required\n    def unwrap_err_or_else(self, default: Nullary[E]) -&gt; E:\n        \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value\n        or computes it from the `default` function.\n\n        Example:\n            ```python\n            err = Err(5)\n            assert err.unwrap_err_or_else(int)\n\n            ok = Ok(8)\n            assert not ok.unwrap_err_or_else(int)\n\n        Arguments:\n            default: The default-computing function to use.\n\n        Returns:\n            The contained error value or the `default()` one.\n        \"\"\"\n        ...\n\n    @required\n    async def unwrap_err_or_else_await(self, default: AsyncNullary[E]) -&gt; E:\n        \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value\n        or computes it from the asynchronous `default` function.\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            err = Err(13)\n            assert await err.unwrap_err_or_else_await(default)\n\n            ok = Ok(5)\n            assert not await ok.unwrap_err_or_else_await(default)\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n\n        Returns:\n            The contained error value or the `await default()` one.\n        \"\"\"\n        ...\n\n    @required\n    def raising(self: ResultProtocol[T, AnyError]) -&gt; T:\n        \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value or raises the\n        contained [`Err[AnyError]`][wraps.result.Err] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(13)\n            &gt;&gt;&gt; ok.raising()\n            13\n\n            &gt;&gt;&gt; err = Err(ValueError(\"error...\"))\n            &gt;&gt;&gt; err.raising()\n            Traceback (most recent call last):\n              ...\n            ValueError: error...\n            ```\n\n        Raises:\n            AnyError: The contained error, if the result is [`Err[AnyError]`][wraps.result.Err].\n\n        Returns:\n            The contained value.\n        \"\"\"\n        ...\n\n    @required\n    def ok(self) -&gt; Option[T]:\n        \"\"\"Converts a [`Result[T, E]`][wraps.result.Result]\n        into an [`Option[T]`][wraps.option.Option].\n\n        Converts `self` into an [`Option[T]`][wraps.option.Option], discarding errors, if any.\n\n        Example:\n            ```python\n            ok = Ok(42)\n\n            assert ok.ok().is_some()\n\n            err = Err(0)\n\n            assert err.ok().is_null()\n            ```\n\n        Returns:\n            The converted option.\n        \"\"\"\n        ...\n\n    @required\n    def err(self) -&gt; Option[E]:\n        \"\"\"Converts a [`Result[T, E]`][wraps.result.Result]\n        into an [`Option[E]`][wraps.option.Option].\n\n        Converts `self` into an [`Option[E]`][wraps.option.Option],\n        discarding success values, if any.\n\n        Example:\n            ```python\n            err = Err(13)\n\n            assert err.err().is_some()\n\n            ok = Ok(2)\n\n            assert ok.err().is_null()\n            ```\n\n        Returns:\n            The converted option.\n        \"\"\"\n        ...\n\n    @required\n    def inspect(self, function: Inspect[T]) -&gt; Result[T, E]:\n        \"\"\"Inspects a possibly contained [`Ok[T]`][wraps.result.Ok] value.\n\n        Example:\n            ```python\n            ok = Ok(\"Hello, world!\")\n\n            same = ok.inspect(print)  # Hello, world!\n\n            assert ok == same\n            ```\n\n        Arguments:\n            function: The inspecting function.\n\n        Returns:\n            The inspected result.\n        \"\"\"\n        ...\n\n    @required\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Result[T, E]:\n        \"\"\"Inspects a possibly contained [`Ok[T]`][wraps.result.Ok] value.\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; None:\n                print(value)\n\n            ok = Ok(\"Hello, world!\")\n\n            same = await ok.inspect_await(function)  # Hello, world!\n\n            assert ok == same\n            ```\n\n        Arguments:\n            function: The asynchronous inspecting function.\n\n        Returns:\n            The inspected result.\n        \"\"\"\n        ...\n\n    @required\n    def inspect_err(self, function: Inspect[E]) -&gt; Result[T, E]:\n        \"\"\"Inspects a possibly contained [`Err[E]`][wraps.result.Err] value.\n\n        Example:\n            ```python\n            err = Err(\"Bye, world!\")\n\n            same = err.inspect_err(print)  # Bye, world!\n\n            assert err == same\n            ```\n\n        Arguments:\n            function: The error-inspecting function.\n\n        Returns:\n            The inspected result.\n        \"\"\"\n        ...\n\n    @required\n    async def inspect_err_await(self, function: AsyncInspect[E]) -&gt; Result[T, E]:\n        \"\"\"Inspects a possibly contained [`Err[E]`][wraps.result.Err] value.\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; None:\n                print(value)\n\n            err = Err(\"Bye, world!\")\n\n            same = await err.inspect_err_await(function)  # Bye, world!\n\n            assert err == same\n            ```\n\n        Arguments:\n            function: The asynchronous error-inspecting function.\n\n        Returns:\n            The inspected result.\n        \"\"\"\n        ...\n\n    @required\n    def map(self, function: Unary[T, U]) -&gt; Result[U, E]:\n        \"\"\"Maps a [`Result[T, E]`][wraps.result.Result] to a [`Result[U, E]`][wraps.result.Result]\n        by applying `function` to the contained [`Ok[T]`][wraps.result.Ok] value,\n        leaving any [`Err[E]`][wraps.result.Err] values untouched.\n\n        This function can be used to compose the results of two functions.\n\n        Example:\n            ```python\n            value = 69\n            mapped = \"69\"\n\n            ok = Ok(value)\n\n            assert ok.map(str) == Ok(mapped)\n\n            err = Err(0)\n\n            assert err.map(str) == err\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The mapped result.\n        \"\"\"\n        ...\n\n    @required\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        \"\"\"Returns the default value (if errored), or applies the `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            ok = Ok(\"Hello, world!\")\n            print(ok.map_or(42, len))  # 13\n\n            err = Err(\"error...\")\n            print(err.map_or(42, len))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the default value.\n        \"\"\"\n        ...\n\n    @required\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        \"\"\"Computes the default value (if errored), or applies the `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            ok = Ok(\"Hello, world!\")\n            print(ok.map_or_else(int, len))  # 13\n\n            err = Err(\"error!\")\n            print(err.map_or_else(int, len))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the default computed value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        \"\"\"Computes the default value (if errored), or applies the `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_or_else_await(default, len))  # 13\n\n            err = Err(\"error!\")\n            print(await err.map_or_else_await(default, len))  # 0\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the default computed value.\n        \"\"\"\n        ...\n\n    @required\n    def map_err(self, function: Unary[E, F]) -&gt; Result[T, F]:\n        \"\"\"Maps a [`Result[T, E]`][wraps.result.Result] to a [`Result[T, F]`][wraps.result.Result]\n        by applying the `function` to the contained [`Err[E]`][wraps.result.Err] value,\n        leaving any [`Ok[T]`][wraps.result.Ok] values untouched.\n\n        Example:\n            ```python\n            value = 42\n            mapped = \"42\"\n\n            err = Err(value)\n\n            assert err.map_err(str) == Err(mapped)\n\n            ok = Ok(2)\n\n            assert ok.map_err(str) == ok\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The mapped result.\n        \"\"\"\n        ...\n\n    @required\n    def map_err_or(self, default: F, function: Unary[E, F]) -&gt; F:\n        \"\"\"Returns the default value (if succeeded), or applies the `function`\n        to the contained error value (if errored).\n\n        Example:\n            ```python\n            err = Err(\"nekit\")\n            print(err.map_err_or(13, len))  # 5\n\n            ok = Ok(\"ok\")\n            print(ok.map_err_or(13, len))  # 13\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the default value.\n        \"\"\"\n        ...\n\n    @required\n    def map_err_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n        \"\"\"Computes the default value (if succeeded), or applies the `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            err = Err(\"error...\")\n            print(err.map_err_or_else(int, len))  # 8\n\n            ok = Ok(\"ok!\")\n            print(ok.map_err_or_else(int, len))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_err_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n        \"\"\"Computes the default value (if succeeded), or applies the `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            err = Err(\"error...\")\n            print(await err.map_err_or_else(int, len))  # 8\n\n            ok = Ok(\"ok!\")\n            print(await ok.map_err_or_else(int, len))  # 0\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Result[U, E]:\n        \"\"\"Maps a [`Result[T, E]`][wraps.result.Result] to a [`Result[U, E]`][wraps.result.Result]\n        by applying the asynchronous `function` to the contained [`Ok[T]`][wraps.result.Ok] value,\n        leaving any [`Err[E]`][wraps.result.Err] values untouched.\n\n        This function can be used to compose the results of two functions.\n\n        Example:\n            ```python\n            async def function(value: int) -&gt; str:\n                return str(value)\n\n            value = 69\n            mapped = \"69\"\n\n            ok = Ok(value)\n\n            assert await ok.map_await(function) == Ok(mapped)\n\n            err = Err(0)\n\n            assert await err.map_await(function) == err\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The mapped result.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        \"\"\"Returns the default value (if errored), or applies the asynchronous `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_await_or(42, function))  # 13\n\n            err = Err(\"error...\")\n            print(err.map_await_or(42, function))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        \"\"\"Computes the default value (if errored), or applies the asynchronous `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            async def async_len(value: str) -&gt; int:\n                return len(value)\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_await_or_else(int, async_len))  # 13\n\n            err = Err(\"error!\")\n            print(await err.map_await_or_else(int, async_len))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        \"\"\"Computes the default value (if errored), or applies the asynchronous `function`\n        to the contained value (if succeeded).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_await_or_else_await(default, function))  # 13\n\n            err = Err(\"error!\")\n            print(await err.map_await_or_else_await(default, function))  # 0\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_err_await(self, function: AsyncUnary[E, F]) -&gt; Result[T, F]:\n        \"\"\"Maps a [`Result[T, E]`][wraps.result.Result] to a [`Result[T, F]`][wraps.result.Result]\n        by applying the asynchronous `function` to the contained [`Err[E]`][wraps.result.Err]\n        value, leaving any [`Ok[T]`][wraps.result.Ok] values untouched.\n\n        Example:\n            ```python\n            async def function(value: int) -&gt; str:\n                return str(value)\n\n            value = 42\n            mapped = \"42\"\n\n            err = Err(value)\n\n            assert await err.map_err_await(function) == Err(mapped)\n\n            ok = Ok(13)\n\n            assert await ok.map_err_await(function) == ok\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The mapped result.\n        \"\"\"\n        ...\n\n    @required\n    async def map_err_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n        \"\"\"Returns the default value (if succeeded), or applies the asynchronous `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            err = Err(\"Bye, world!\")\n            print(await err.map_err_await_or(42, function))  # 11\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_err_await_or(42, function))  # 42\n            ```\n\n        Arguments:\n            default: The default value to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_err_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n        \"\"\"Computes the default value (if succeeded), or applies the asynchronous `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            async def async_len(value: str) -&gt; int:\n                return len(value)\n\n            err = Err(\"Bye, world!\")\n            print(await err.map_err_await_or_else(int, async_len))  # 11\n\n            ok = Ok(\"Hello, world!\")\n            print(await ok.map_err_await_or_else(int, async_len))  # 0\n            ```\n\n        Arguments:\n            default: The default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the computed default value.\n        \"\"\"\n        ...\n\n    @required\n    async def map_err_await_or_else_await(\n        self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n    ) -&gt; F:\n        \"\"\"Computes the default value (if succeeded), or applies the asynchronous `function`\n        to the contained value (if errored).\n\n        Example:\n            ```python\n            async def default() -&gt; int:\n                return 0\n\n            async def function(value: str) -&gt; int:\n                return len(value)\n\n            err = Err(\"error\")\n            print(await err.map_err_await_or_else_await(default, function))  # 5\n\n            ok = Ok(\"ok\")\n            print(await ok.map_err_await_or_else_await(default, function))  # 0\n            ```\n\n        Arguments:\n            default: The asynchronous default-computing function to use.\n            function: The asynchronous function to apply.\n\n        Returns:\n            The resulting or the default computed value.\n        \"\"\"\n        ...\n\n    @required\n    def iter(self) -&gt; Iterator[T]:\n        \"\"\"Returns an iterator over the possibly contained value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; next(ok.iter(), 0)\n            42\n            &gt;&gt;&gt; err = Err(13)\n            &gt;&gt;&gt; next(err.iter(), 0)\n            0\n            ```\n\n        Returns:\n            An iterator over the possibly contained value.\n        \"\"\"\n        ...\n\n    @required\n    def iter_err(self) -&gt; Iterator[E]:\n        \"\"\"Returns an iterator over the possibly contained error value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; err = Err(13)\n            &gt;&gt;&gt; next(err.iter_err(), 0)\n            13\n            &gt;&gt;&gt; ok = Ok(1)\n            &gt;&gt;&gt; next(ok.iter_err(), 0)\n            0\n            ```\n\n        Returns:\n            An iterator over the possibly contained error value.\n        \"\"\"\n        ...\n\n    @required\n    def async_iter(self) -&gt; AsyncIterator[T]:\n        \"\"\"Returns an asynchronous iterator over the possibly contained\n        [`Ok[T]`][wraps.result.Ok] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; ok = Ok(42)\n            &gt;&gt;&gt; await async_next(ok.async_iter(), 0)\n            42\n            &gt;&gt;&gt; err = Err(13)\n            &gt;&gt;&gt; await async_next(err.async_iter(), 0)\n            0\n            ```\n\n        Returns:\n            An asynchronous iterator over the possibly contained value.\n        \"\"\"\n        ...\n\n    @required\n    def async_iter_err(self) -&gt; AsyncIterator[E]:\n        \"\"\"Returns an asynchronous iterator over the possibly contained\n        [`Err[E]`][wraps.result.Err] value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; err = Err(42)\n            &gt;&gt;&gt; await async_next(err.async_iter_err(), 0)\n            42\n            &gt;&gt;&gt; ok = Ok(13)\n            &gt;&gt;&gt; await async_next(ok.async_iter_err(), 0)\n            0\n            ```\n\n        Returns:\n            An asynchronous iterator over the possibly contained error value.\n        \"\"\"\n        ...\n\n    @required\n    def and_then(self, function: Unary[T, Result[U, E]]) -&gt; Result[U, E]:\n        \"\"\"Returns the result if it is an [`Err[E]`][wraps.result.Err],\n        otherwise calls the `function` with the wrapped value and returns the result.\n\n        This function is also known as *bind* in functional programming.\n\n        Example:\n            ```python\n            def inverse(value: float) -&gt; Result[float, str]:\n                return Ok(1.0 / value) if value else Err(\"division by zero\")\n\n            two = Ok(2.0)\n            print(two.and_then(inverse).unwrap())  # 0.5\n\n            zero = Ok(0.0)\n            print(zero.and_then(inverse).unwrap_err())  # division by zero\n\n            err = Err(1.0)\n            print(err.and_then(inverse).unwrap_err())  # 1.0\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The bound result.\n        \"\"\"\n        ...\n\n    @required\n    async def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]:\n        \"\"\"Returns the result if it is an [`Err[E]`][wraps.result.Err],\n        otherwise calls the asynchronous `function` with the wrapped value and returns the result.\n\n        Example:\n            ```python\n            async def inverse(value: float) -&gt; Result[float, str]:\n                return Ok(1.0 / value) if value else Err(\"division by zero\")\n\n            two = Ok(2.0)\n            print((await two.and_then_await(inverse)).unwrap())  # 0.5\n\n            zero = Ok(0.0)\n            print((await zero.and_then_await(inverse)).unwrap_err())  # division by zero\n\n            err = Err(1.0)\n            print((await err.and_then_await(inverse)).unwrap_err())  # 1.0\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The bound result.\n        \"\"\"\n        ...\n\n    @required\n    def or_else(self, function: Unary[E, Result[T, F]]) -&gt; Result[T, F]:\n        \"\"\"Returns the result if it is [`Ok[T]`][wraps.result.Ok], otherwise calls the `function`\n        with the wrapped error value and returns the result.\n\n        Example:\n            ```python\n            def check_non_zero(value: int) -&gt; Result[int, str]:\n                return Ok(value) if value else Err(\"the value is zero\")\n\n            err = Err(5)\n            print(err.or_else(check_non_zero).unwrap())  # 5\n\n            zero = Err(0)\n            print(zero.or_else(check_non_zero).unwrap_err())  # the value is zero\n\n            ok = Ok(1)\n            print(ok.or_else(check_non_zero).unwrap())  # 1\n            ```\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The bound result.\n        \"\"\"\n        ...\n\n    @required\n    async def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]:\n        \"\"\"Returns the result if it is [`Ok[T]`][wraps.result.Ok], otherwise calls the asynchronous\n        `function` with the wrapped error value and returns the result.\n\n        Example:\n            ```python\n            async def check_non_zero(value: int) -&gt; Result[int, str]:\n                return Ok(value) if value else Err(\"the value is zero\")\n\n            err = Err(5)\n\n            print((await err.or_else_await(check_non_zero)).unwrap())  # 5\n\n            zero = Err(0)\n            print((await zero.or_else_await(check_non_zero)).unwrap_err())  # the value is zero\n\n            ok = Ok(1)\n            print((await ok.or_else_await(check_non_zero)).unwrap())  # 1\n            ```\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The bound result.\n        \"\"\"\n        ...\n\n    def try_flatten(self: ResultProtocol[ResultProtocol[T, E], E]) -&gt; Result[T, E]:\n        \"\"\"Flattens a [`Result[Result[T, E], E]`][wraps.result.Result]\n        into a [`Result[T, E]`][wraps.result.Result].\n\n        This is equivalent to [`result.and_then(identity)`][wraps.result.ResultProtocol.and_then].\n\n        Example:\n            ```python\n            ok = Ok(42)\n            ok_nested = Ok(ok)\n            assert ok_nested.try_flatten() == ok\n\n            err = Err(13)\n            err_nested = Ok(err)\n            assert err_nested.try_flatten() == err\n\n            assert err.try_flatten() == err\n            ```\n\n        Returns:\n            The flattened result.\n        \"\"\"\n        return self.and_then(identity)  # type: ignore[arg-type]\n\n    def try_flatten_err(self: ResultProtocol[T, ResultProtocol[T, E]]) -&gt; Result[T, E]:\n        \"\"\"Flattens a [`Result[T, Result[T, E]]`][wraps.result.Result]\n        into a [`Result[T, E]`][wraps.result.Result].\n\n        This is equivalent to [`result.or_else(identity)`][wraps.result.ResultProtocol.or_else].\n\n        Example:\n            ```python\n            ok = Ok(42)\n            ok_nested = Err(ok)\n            assert ok_nested.try_flatten_err() == err\n\n            err = Err(13)\n            err_nested = Err(err)\n            assert err_nested.try_flatten_err() == err\n\n            assert ok.try_flatten_err() == ok\n            ```\n\n        Returns:\n            The flattened result.\n        \"\"\"\n        return self.or_else(identity)  # type: ignore[arg-type]\n\n    @required\n    def contains(self, value: U) -&gt; bool:\n        \"\"\"Checks if the contained value is equal to the `value`.\n\n        Example:\n            ```python\n            value = 42\n            other = 69\n\n            ok = Ok(value)\n            assert ok.contains(value)\n            assert not ok.contains(other)\n\n            err = Err(value)\n            assert not err.contains(value)\n            ```\n\n        Arguments:\n            value: The value to check against.\n\n        Returns:\n            Whether the contained value is equal to the `value`.\n        \"\"\"\n        ...\n\n    @required\n    def contains_err(self, error: F) -&gt; bool:\n        \"\"\"Checks if the contained error value is equal to the `error`.\n\n        Example:\n            ```python\n            value = 42\n            other = 69\n\n            err = Err(value)\n            assert err.contains_err(value)\n            assert not err.contains_err(other)\n\n            ok = Ok(value)\n            assert not ok.contains_err(value)\n            ```\n\n        Arguments:\n            error: The error value to check against.\n\n        Returns:\n            Whether the contained error value is equal to the `error`.\n        \"\"\"\n        ...\n\n    @required\n    def flip(self) -&gt; Result[E, T]:\n        \"\"\"Converts a [`Result[T, E]`][wraps.result.Result]\n        into a [`Result[E, T]`][wraps.result.Result].\n\n        [`Ok(value)`][wraps.result.Ok] and [`Err(error)`][wraps.result.Err] get swapped to\n        [`Err(value)`][wraps.result.Err] and [`Ok(error)`][wraps.result.Ok] respectively.\n\n        Example:\n            ```python\n            value = 42\n\n            result = Ok(value)\n            flipped = Err(value)\n\n            assert result.flip() == flipped\n            ```\n\n        Returns:\n            The flipped result.\n        \"\"\"\n        ...\n\n    @required\n    def into_ok_or_err(self: ResultProtocol[V, V]) -&gt; V:\n        \"\"\"Returns the value contained within [`Result[V, V]`][wraps.result.Result], regardless\n        of whether or not that result is [`Ok[V]`][wraps.result.Ok]\n        or [`Err[V]`][wraps.result.Err].\n\n        Example:\n            ```python\n            result: Result[int, int] = Ok(69)\n\n            print(result.into_ok_or_err())  # 69; inferred `int`\n\n            result = Err(42)\n\n            print(result.into_ok_or_err())  # 42; inferred `int`\n            ```\n\n        Returns:\n            The contained value, regardless of whether or not it is an error one.\n        \"\"\"\n        ...\n\n    @required\n    def into_either(self) -&gt; Either[T, E]:\n        \"\"\"Converts a [`Result[T, E]`][wraps.result.Result]\n        into an [`Either[T, E]`][wraps.either.Either].\n\n        [`Ok(value)`][wraps.result.Ok] is mapped to [`Left(value)`][wraps.either.Left]\n        and [`Err(error)`][wraps.result.Err] is mapped to [`Right(error)`][wraps.either.Right].\n\n        Example:\n            ```python\n            value = 42\n\n            ok = Ok(value)\n            left = Left(value)\n\n            assert ok.into_either() == left\n\n            err = Err(value)\n            right = Right(value)\n\n            assert err.into_either() == right\n            ```\n\n        Returns:\n            The mapped either.\n        \"\"\"\n        ...\n\n    @required\n    def early(self) -&gt; T:\n        \"\"\"Functionally similar to the *question-mark* (`?`) operator in Rust.\n\n        Calls to this method are to be combined with\n        [`@early_result`][wraps.early.decorators.early_result] decorators to work properly.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.is_ok","title":"<code>is_ok() -&gt; bool</code>","text":"<p>Checks if the result is <code>Ok[T]</code>.</p> Example <pre><code>ok = Ok(42)\nassert ok.is_ok()\n\nerr = Err(13)\nassert not err.is_ok()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Ok[T]</code>.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef is_ok(self) -&gt; bool:\n    \"\"\"Checks if the result is [`Ok[T]`][wraps.result.Ok].\n\n    Example:\n        ```python\n        ok = Ok(42)\n        assert ok.is_ok()\n\n        err = Err(13)\n        assert not err.is_ok()\n        ```\n\n    Returns:\n        Whether the result is [`Ok[T]`][wraps.result.Ok].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.is_ok_and","title":"<code>is_ok_and(predicate: Predicate[T]) -&gt; bool</code>","text":"<p>Checks if the result is <code>Ok[T]</code> and the value inside of it matches the <code>predicate</code>.</p> Example <pre><code>def is_positive(value: int) -&gt; bool:\n    return value &gt; 0\n\nok = Ok(13)\nassert ok.is_ok_and(is_positive)\n\nzero = Ok(0)\nassert not zero.is_ok_and(is_positive)\n\nerr = Err(7)\nassert not err.is_ok_and(is_positive)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[T]</code> <p>The predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Ok[T]</code> and the predicate is matched.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef is_ok_and(self, predicate: Predicate[T]) -&gt; bool:\n    \"\"\"Checks if the result is [`Ok[T]`][wraps.result.Ok] and the value\n    inside of it matches the `predicate`.\n\n    Example:\n        ```python\n        def is_positive(value: int) -&gt; bool:\n            return value &gt; 0\n\n        ok = Ok(13)\n        assert ok.is_ok_and(is_positive)\n\n        zero = Ok(0)\n        assert not zero.is_ok_and(is_positive)\n\n        err = Err(7)\n        assert not err.is_ok_and(is_positive)\n        ```\n\n    Arguments:\n        predicate: The predicate to check the contained value against.\n\n    Returns:\n        Whether the result is [`Ok[T]`][wraps.result.Ok] and the predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.is_ok_and_await","title":"<code>is_ok_and_await(predicate: AsyncPredicate[T]) -&gt; bool</code>  <code>async</code>","text":"<p>Checks if the result is <code>Ok[T]</code> and the value inside of it matches the asynchronous <code>predicate</code>.</p> Example <pre><code>async def is_positive(value: int) -&gt; bool:\n    return value &gt; 0\n\nok = Ok(13)\nassert await ok.is_ok_and_await(is_positive)\n\nzero = Ok(0)\nassert not await zero.is_ok_and_await(is_positive)\n\nerr = Err(7)\nassert not await err.is_ok_and_await(is_positive)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>AsyncPredicate[T]</code> <p>The asynchronous predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Ok[T]</code> and</p> <code>bool</code> <p>the asynchronous predicate is matched.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n    \"\"\"Checks if the result is [`Ok[T]`][wraps.result.Ok] and the value\n    inside of it matches the asynchronous `predicate`.\n\n    Example:\n        ```python\n        async def is_positive(value: int) -&gt; bool:\n            return value &gt; 0\n\n        ok = Ok(13)\n        assert await ok.is_ok_and_await(is_positive)\n\n        zero = Ok(0)\n        assert not await zero.is_ok_and_await(is_positive)\n\n        err = Err(7)\n        assert not await err.is_ok_and_await(is_positive)\n        ```\n\n    Arguments:\n        predicate: The asynchronous predicate to check the contained value against.\n\n    Returns:\n        Whether the result is [`Ok[T]`][wraps.result.Ok] and\n        the asynchronous predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.is_err","title":"<code>is_err() -&gt; bool</code>","text":"<p>Checks if the result is <code>Err[E]</code>.</p> Example <pre><code>err = Err(34)\nassert err.is_err()\n\nok = Ok(69)\nassert not ok.is_err()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Err[E]</code>.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef is_err(self) -&gt; bool:\n    \"\"\"Checks if the result is [`Err[E]`][wraps.result.Err].\n\n    Example:\n        ```python\n        err = Err(34)\n        assert err.is_err()\n\n        ok = Ok(69)\n        assert not ok.is_err()\n        ```\n\n    Returns:\n        Whether the result is [`Err[E]`][wraps.result.Err].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.is_err_and","title":"<code>is_err_and(predicate: Predicate[E]) -&gt; bool</code>","text":"<p>Checks if the result is <code>Err[E]</code> and the value inside of it matches the <code>predicate</code>.</p> Example <pre><code>def is_negative(value: int) -&gt; bool:\n    return value &lt; 0\n\nerr = Err(-13)\nassert err.is_err_and(is_positive)\n\nzero = Err(0)\nassert not zero.is_err_and(is_positive)\n\nok = Ok(7)\nassert not ok.is_err_and(is_positive)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[E]</code> <p>The predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Err[E]</code> and the predicate is matched.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef is_err_and(self, predicate: Predicate[E]) -&gt; bool:\n    \"\"\"Checks if the result is [`Err[E]`][wraps.result.Err] and the value\n    inside of it matches the `predicate`.\n\n    Example:\n        ```python\n        def is_negative(value: int) -&gt; bool:\n            return value &lt; 0\n\n        err = Err(-13)\n        assert err.is_err_and(is_positive)\n\n        zero = Err(0)\n        assert not zero.is_err_and(is_positive)\n\n        ok = Ok(7)\n        assert not ok.is_err_and(is_positive)\n        ```\n\n    Arguments:\n        predicate: The predicate to check the contained value against.\n\n    Returns:\n        Whether the result is [`Err[E]`][wraps.result.Err] and the predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.is_err_and_await","title":"<code>is_err_and_await(predicate: AsyncPredicate[E]) -&gt; bool</code>  <code>async</code>","text":"<p>Checks if the result is <code>Err[E]</code> and the value inside of it matches the asynchronous <code>predicate</code>.</p> Example <pre><code>async def is_negative(value: int) -&gt; bool:\n    return value &lt; 0\n\nerr = Err(-13)\nassert await err.is_err_and_await(is_negative)\n\nzero = Err(0)\nassert not await zero.is_err_and_await(is_negative)\n\nok = Ok(7)\nassert not await ok.is_err_and_await(is_negative)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>AsyncPredicate[E]</code> <p>The asynchronous predicate to check the contained value against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the result is <code>Err[E]</code> and</p> <code>bool</code> <p>the asynchronous predicate is matched.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def is_err_and_await(self, predicate: AsyncPredicate[E]) -&gt; bool:\n    \"\"\"Checks if the result is [`Err[E]`][wraps.result.Err] and the value\n    inside of it matches the asynchronous `predicate`.\n\n    Example:\n        ```python\n        async def is_negative(value: int) -&gt; bool:\n            return value &lt; 0\n\n        err = Err(-13)\n        assert await err.is_err_and_await(is_negative)\n\n        zero = Err(0)\n        assert not await zero.is_err_and_await(is_negative)\n\n        ok = Ok(7)\n        assert not await ok.is_err_and_await(is_negative)\n        ```\n\n    Arguments:\n        predicate: The asynchronous predicate to check the contained value against.\n\n    Returns:\n        Whether the result is [`Err[E]`][wraps.result.Err] and\n        the asynchronous predicate is matched.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.expect","title":"<code>expect(message: str) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; ok.expect(\"error!\")\n42\n&gt;&gt;&gt; err = Err(0)\n&gt;&gt;&gt; err.expect(\"error!\")\nTraceback (most recent call last):\n  ...\nwraps.panics.Panic: error!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message used in panicking.</p> required <p>Raises:</p> Type Description <code>Panic</code> <p>Panics with the <code>message</code> if the result is <code>Err[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef expect(self, message: str) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; ok.expect(\"error!\")\n        42\n        &gt;&gt;&gt; err = Err(0)\n        &gt;&gt;&gt; err.expect(\"error!\")\n        Traceback (most recent call last):\n          ...\n        wraps.panics.Panic: error!\n        ```\n\n    Arguments:\n        message: The message used in panicking.\n\n    Raises:\n        Panic: Panics with the `message` if the result is [`Err[E]`][wraps.result.Err].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.expect_err","title":"<code>expect_err(message: str) -&gt; E</code>","text":"<p>Returns the contained <code>Err[E]</code> value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; ok.expect_err(\"ok!\")\nTraceback (most recent call last):\n  ...\nwraps.panics.Panic: ok!\n\n&gt;&gt;&gt; err = Err(0)\n&gt;&gt;&gt; err.expect_err(\"ok!\")\n0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message used in panicking.</p> required <p>Raises:</p> Type Description <code>Panic</code> <p>Panics with the <code>message</code> if the result is <code>Ok[T]</code>.</p> <p>Returns:</p> Type Description <code>E</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef expect_err(self, message: str) -&gt; E:\n    \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; ok.expect_err(\"ok!\")\n        Traceback (most recent call last):\n          ...\n        wraps.panics.Panic: ok!\n\n        &gt;&gt;&gt; err = Err(0)\n        &gt;&gt;&gt; err.expect_err(\"ok!\")\n        0\n        ```\n\n    Arguments:\n        message: The message used in panicking.\n\n    Raises:\n        Panic: Panics with the `message` if the result is [`Ok[T]`][wraps.result.Ok].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.unwrap","title":"<code>unwrap() -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value (of type <code>T</code>).</p> <p>Because this function may panic, its use is generally discouraged.</p> <p>Instead, prefer to use pattern matching and handle the <code>Err[E]</code> case explicitly, or call <code>unwrap_or</code> or <code>unwrap_or_else</code>.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(13)\n&gt;&gt;&gt; ok.unwrap()\n13\n\n&gt;&gt;&gt; err = Err(0)\n&gt;&gt;&gt; err.unwrap()\nTraceback (most recent call last):\n  ...\nwraps.panics.Panic: called `unwrap` on err\n</code></pre> <p>Raises:</p> Type Description <code>Panic</code> <p>Panics if the result is <code>Err[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef unwrap(self) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value (of type `T`).\n\n    Because this function may panic, its use is generally discouraged.\n\n    Instead, prefer to use pattern matching and handle the [`Err[E]`][wraps.result.Err]\n    case explicitly, or call [`unwrap_or`][wraps.result.ResultProtocol.unwrap_or]\n    or [`unwrap_or_else`][wraps.result.ResultProtocol.unwrap_or_else].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(13)\n        &gt;&gt;&gt; ok.unwrap()\n        13\n\n        &gt;&gt;&gt; err = Err(0)\n        &gt;&gt;&gt; err.unwrap()\n        Traceback (most recent call last):\n          ...\n        wraps.panics.Panic: called `unwrap` on err\n        ```\n\n    Raises:\n        Panic: Panics if the result is [`Err[E]`][wraps.result.Err].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.unwrap_or","title":"<code>unwrap_or(default: T) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or the provided <code>default</code>.</p> Example <pre><code>ok = Ok(69)\nassert ok.unwrap_or(0)\n\nerr = Err(13)\nassert not err.unwrap_or(0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>T</code> <p>The default value to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>default</code> one.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value or the provided `default`.\n\n    Example:\n        ```python\n        ok = Ok(69)\n        assert ok.unwrap_or(0)\n\n        err = Err(13)\n        assert not err.unwrap_or(0)\n        ```\n\n    Arguments:\n        default: The default value to use.\n\n    Returns:\n        The contained value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.unwrap_or_else","title":"<code>unwrap_or_else(default: Nullary[T]) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or computes it from the <code>default</code> function.</p> Example <pre><code>ok = Ok(5)\nassert ok.unwrap_or_else(int)\n\nerr = Err(8)\nassert not err.unwrap_or_else(int)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[T]</code> <p>The default-computing function to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>default()</code> one.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n    or computes it from the `default` function.\n\n    Example:\n        ```python\n        ok = Ok(5)\n        assert ok.unwrap_or_else(int)\n\n        err = Err(8)\n        assert not err.unwrap_or_else(int)\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n\n    Returns:\n        The contained value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.unwrap_or_else_await","title":"<code>unwrap_or_else_await(default: AsyncNullary[T]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or computes it from the asynchronous <code>default</code> function.</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nok = Ok(5)\nassert await ok.unwrap_or_else_await(default)\n\nerr = Err(8)\nassert not await err.unwrap_or_else_await(default)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[T]</code> <p>The asynchronous default-computing function to use.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The contained value or the <code>await default()</code> one.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n    or computes it from the asynchronous `default` function.\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        ok = Ok(5)\n        assert await ok.unwrap_or_else_await(default)\n\n        err = Err(8)\n        assert not await err.unwrap_or_else_await(default)\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n\n    Returns:\n        The contained value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.or_raise","title":"<code>or_raise(error: AnyError) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the <code>error</code> provided.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AnyError</code> <p>The error to raise if the result is <code>Err[E]</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error provided, if the result is <code>Err[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef or_raise(self, error: AnyError) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n    or raises the `error` provided.\n\n    Arguments:\n        error: The error to raise if the result is [`Err[E]`][wraps.result.Err].\n\n    Raises:\n        AnyError: The error provided, if the result is [`Err[E]`][wraps.result.Err].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.or_raise_with","title":"<code>or_raise_with(error: Nullary[AnyError]) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the error computed from <code>error</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Nullary[AnyError]</code> <p>The function computing the error to raise if the result is <code>Err[E]</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the result is <code>Err[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n    or raises the error computed from `error`.\n\n    Arguments:\n        error: The function computing the error to raise\n            if the result is [`Err[E]`][wraps.result.Err].\n\n    Raises:\n        AnyError: The error computed, if the result is [`Err[E]`][wraps.result.Err].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.or_raise_with_await","title":"<code>or_raise_with_await(error: AsyncNullary[AnyError]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the error computed asynchronously from <code>error</code>.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AsyncNullary[AnyError]</code> <p>The asynchronous function computing the error to raise if the result is <code>Err[E]</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the result is <code>Err[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n    or raises the error computed asynchronously from `error`.\n\n    Arguments:\n        error: The asynchronous function computing the error to raise\n            if the result is [`Err[E]`][wraps.result.Err].\n\n    Raises:\n        AnyError: The error computed, if the result is [`Err[E]`][wraps.result.Err].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.or_raise_from","title":"<code>or_raise_from(error: Unary[E, AnyError]) -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the error computed from <code>error</code> that receives the contained <code>Err[E]</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Unary[E, AnyError]</code> <p>The function computing the error to raise if the result is <code>Err[E]</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the result is <code>Err[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef or_raise_from(self, error: Unary[E, AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n    or raises the error computed from `error` that receives the contained\n    [`Err[E]`][wraps.result.Err] value.\n\n    Arguments:\n        error: The function computing the error to raise\n            if the result is [`Err[E]`][wraps.result.Err].\n\n    Raises:\n        AnyError: The error computed, if the result is [`Err[E]`][wraps.result.Err].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.or_raise_from_await","title":"<code>or_raise_from_await(error: AsyncUnary[E, AnyError]) -&gt; T</code>  <code>async</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raise the error computed asynchronously from <code>error</code> that receives the contained <code>Err[E]</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>AsyncUnary[E, AnyError]</code> <p>The asynchronous function computing the error to raise if the result is <code>Err[E]</code>.</p> required <p>Raises:</p> Type Description <code>AnyError</code> <p>The error computed, if the result is <code>Err[E]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def or_raise_from_await(self, error: AsyncUnary[E, AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value\n    or raise the error computed asynchronously from `error` that receives the contained\n    [`Err[E]`][wraps.result.Err] value.\n\n    Arguments:\n        error: The asynchronous function computing the error to raise\n            if the result is [`Err[E]`][wraps.result.Err].\n\n    Raises:\n        AnyError: The error computed, if the result is [`Err[E]`][wraps.result.Err].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.unwrap_err","title":"<code>unwrap_err() -&gt; E</code>","text":"<p>Returns the contained <code>Err[E]</code> value.</p> <p>Because this function may panic, its use is generally discouraged.</p> <p>Instead, prefer to use pattern matching and handle the <code>Ok[T]</code> case explicitly, or call <code>unwrap_err_or</code> or <code>unwrap_err_or_else</code>.</p> Example <pre><code>&gt;&gt;&gt; err = Err(13)\n&gt;&gt;&gt; err.unwrap_err()\n13\n\n&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; ok.unwrap_err()\nTraceback (most recent call last):\n  ...\nwraps.panics.Panic: called `unwrap_err` on ok\n</code></pre> <p>Raises:</p> Type Description <code>Panic</code> <p>Panics if the result is <code>Ok[T]</code>.</p> <p>Returns:</p> Type Description <code>E</code> <p>The contained error value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef unwrap_err(self) -&gt; E:\n    \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value.\n\n    Because this function may panic, its use is generally discouraged.\n\n    Instead, prefer to use pattern matching and handle the [`Ok[T]`][wraps.result.Ok]\n    case explicitly, or call [`unwrap_err_or`][wraps.result.ResultProtocol.unwrap_err_or]\n    or [`unwrap_err_or_else`][wraps.result.ResultProtocol.unwrap_err_or_else].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; err = Err(13)\n        &gt;&gt;&gt; err.unwrap_err()\n        13\n\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; ok.unwrap_err()\n        Traceback (most recent call last):\n          ...\n        wraps.panics.Panic: called `unwrap_err` on ok\n        ```\n\n    Raises:\n        Panic: Panics if the result is [`Ok[T]`][wraps.result.Ok].\n\n    Returns:\n        The contained error value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.unwrap_err_or","title":"<code>unwrap_err_or(default: E) -&gt; E</code>","text":"<p>Returns the contained <code>Err[E]</code> value (of type <code>E</code>) or a provided default.</p> Example <pre><code>err = Err(1)\nassert err.unwrap_err_or(0)\n\nok = Ok(2)\nassert not ok.unwrap_err_or(0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>E</code> <p>The default value to use.</p> required <p>Returns:</p> Type Description <code>E</code> <p>The contained error value or the <code>default</code> one.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef unwrap_err_or(self, default: E) -&gt; E:  # type: ignore[misc]\n    \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value (of type `E`)\n    or a provided default.\n\n    Example:\n        ```python\n        err = Err(1)\n        assert err.unwrap_err_or(0)\n\n        ok = Ok(2)\n        assert not ok.unwrap_err_or(0)\n        ```\n\n    Arguments:\n        default: The default value to use.\n\n    Returns:\n        The contained error value or the `default` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.unwrap_err_or_else","title":"<code>unwrap_err_or_else(default: Nullary[E]) -&gt; E</code>","text":"<p>Returns the contained <code>Err[E]</code> value or computes it from the <code>default</code> function.</p> Example <p>```python err = Err(5) assert err.unwrap_err_or_else(int)</p> <p>ok = Ok(8) assert not ok.unwrap_err_or_else(int)</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[E]</code> <p>The default-computing function to use.</p> required <p>Returns:</p> Type Description <code>E</code> <p>The contained error value or the <code>default()</code> one.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef unwrap_err_or_else(self, default: Nullary[E]) -&gt; E:\n    \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value\n    or computes it from the `default` function.\n\n    Example:\n        ```python\n        err = Err(5)\n        assert err.unwrap_err_or_else(int)\n\n        ok = Ok(8)\n        assert not ok.unwrap_err_or_else(int)\n\n    Arguments:\n        default: The default-computing function to use.\n\n    Returns:\n        The contained error value or the `default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.unwrap_err_or_else_await","title":"<code>unwrap_err_or_else_await(default: AsyncNullary[E]) -&gt; E</code>  <code>async</code>","text":"<p>Returns the contained <code>Err[E]</code> value or computes it from the asynchronous <code>default</code> function.</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nerr = Err(13)\nassert await err.unwrap_err_or_else_await(default)\n\nok = Ok(5)\nassert not await ok.unwrap_err_or_else_await(default)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[E]</code> <p>The asynchronous default-computing function to use.</p> required <p>Returns:</p> Type Description <code>E</code> <p>The contained error value or the <code>await default()</code> one.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def unwrap_err_or_else_await(self, default: AsyncNullary[E]) -&gt; E:\n    \"\"\"Returns the contained [`Err[E]`][wraps.result.Err] value\n    or computes it from the asynchronous `default` function.\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        err = Err(13)\n        assert await err.unwrap_err_or_else_await(default)\n\n        ok = Ok(5)\n        assert not await ok.unwrap_err_or_else_await(default)\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n\n    Returns:\n        The contained error value or the `await default()` one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.raising","title":"<code>raising() -&gt; T</code>","text":"<p>Returns the contained <code>Ok[T]</code> value or raises the contained <code>Err[AnyError]</code> value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(13)\n&gt;&gt;&gt; ok.raising()\n13\n\n&gt;&gt;&gt; err = Err(ValueError(\"error...\"))\n&gt;&gt;&gt; err.raising()\nTraceback (most recent call last):\n  ...\nValueError: error...\n</code></pre> <p>Raises:</p> Type Description <code>AnyError</code> <p>The contained error, if the result is <code>Err[AnyError]</code>.</p> <p>Returns:</p> Type Description <code>T</code> <p>The contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef raising(self: ResultProtocol[T, AnyError]) -&gt; T:\n    \"\"\"Returns the contained [`Ok[T]`][wraps.result.Ok] value or raises the\n    contained [`Err[AnyError]`][wraps.result.Err] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(13)\n        &gt;&gt;&gt; ok.raising()\n        13\n\n        &gt;&gt;&gt; err = Err(ValueError(\"error...\"))\n        &gt;&gt;&gt; err.raising()\n        Traceback (most recent call last):\n          ...\n        ValueError: error...\n        ```\n\n    Raises:\n        AnyError: The contained error, if the result is [`Err[AnyError]`][wraps.result.Err].\n\n    Returns:\n        The contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.ok","title":"<code>ok() -&gt; Option[T]</code>","text":"<p>Converts a <code>Result[T, E]</code> into an <code>Option[T]</code>.</p> <p>Converts <code>self</code> into an <code>Option[T]</code>, discarding errors, if any.</p> Example <pre><code>ok = Ok(42)\n\nassert ok.ok().is_some()\n\nerr = Err(0)\n\nassert err.ok().is_null()\n</code></pre> <p>Returns:</p> Type Description <code>Option[T]</code> <p>The converted option.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef ok(self) -&gt; Option[T]:\n    \"\"\"Converts a [`Result[T, E]`][wraps.result.Result]\n    into an [`Option[T]`][wraps.option.Option].\n\n    Converts `self` into an [`Option[T]`][wraps.option.Option], discarding errors, if any.\n\n    Example:\n        ```python\n        ok = Ok(42)\n\n        assert ok.ok().is_some()\n\n        err = Err(0)\n\n        assert err.ok().is_null()\n        ```\n\n    Returns:\n        The converted option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.err","title":"<code>err() -&gt; Option[E]</code>","text":"<p>Converts a <code>Result[T, E]</code> into an <code>Option[E]</code>.</p> <p>Converts <code>self</code> into an <code>Option[E]</code>, discarding success values, if any.</p> Example <pre><code>err = Err(13)\n\nassert err.err().is_some()\n\nok = Ok(2)\n\nassert ok.err().is_null()\n</code></pre> <p>Returns:</p> Type Description <code>Option[E]</code> <p>The converted option.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef err(self) -&gt; Option[E]:\n    \"\"\"Converts a [`Result[T, E]`][wraps.result.Result]\n    into an [`Option[E]`][wraps.option.Option].\n\n    Converts `self` into an [`Option[E]`][wraps.option.Option],\n    discarding success values, if any.\n\n    Example:\n        ```python\n        err = Err(13)\n\n        assert err.err().is_some()\n\n        ok = Ok(2)\n\n        assert ok.err().is_null()\n        ```\n\n    Returns:\n        The converted option.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.inspect","title":"<code>inspect(function: Inspect[T]) -&gt; Result[T, E]</code>","text":"<p>Inspects a possibly contained <code>Ok[T]</code> value.</p> Example <pre><code>ok = Ok(\"Hello, world!\")\n\nsame = ok.inspect(print)  # Hello, world!\n\nassert ok == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Inspect[T]</code> <p>The inspecting function.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The inspected result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef inspect(self, function: Inspect[T]) -&gt; Result[T, E]:\n    \"\"\"Inspects a possibly contained [`Ok[T]`][wraps.result.Ok] value.\n\n    Example:\n        ```python\n        ok = Ok(\"Hello, world!\")\n\n        same = ok.inspect(print)  # Hello, world!\n\n        assert ok == same\n        ```\n\n    Arguments:\n        function: The inspecting function.\n\n    Returns:\n        The inspected result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.inspect_await","title":"<code>inspect_await(function: AsyncInspect[T]) -&gt; Result[T, E]</code>  <code>async</code>","text":"<p>Inspects a possibly contained <code>Ok[T]</code> value.</p> Example <pre><code>async def function(value: str) -&gt; None:\n    print(value)\n\nok = Ok(\"Hello, world!\")\n\nsame = await ok.inspect_await(function)  # Hello, world!\n\nassert ok == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncInspect[T]</code> <p>The asynchronous inspecting function.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The inspected result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def inspect_await(self, function: AsyncInspect[T]) -&gt; Result[T, E]:\n    \"\"\"Inspects a possibly contained [`Ok[T]`][wraps.result.Ok] value.\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; None:\n            print(value)\n\n        ok = Ok(\"Hello, world!\")\n\n        same = await ok.inspect_await(function)  # Hello, world!\n\n        assert ok == same\n        ```\n\n    Arguments:\n        function: The asynchronous inspecting function.\n\n    Returns:\n        The inspected result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.inspect_err","title":"<code>inspect_err(function: Inspect[E]) -&gt; Result[T, E]</code>","text":"<p>Inspects a possibly contained <code>Err[E]</code> value.</p> Example <pre><code>err = Err(\"Bye, world!\")\n\nsame = err.inspect_err(print)  # Bye, world!\n\nassert err == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Inspect[E]</code> <p>The error-inspecting function.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The inspected result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef inspect_err(self, function: Inspect[E]) -&gt; Result[T, E]:\n    \"\"\"Inspects a possibly contained [`Err[E]`][wraps.result.Err] value.\n\n    Example:\n        ```python\n        err = Err(\"Bye, world!\")\n\n        same = err.inspect_err(print)  # Bye, world!\n\n        assert err == same\n        ```\n\n    Arguments:\n        function: The error-inspecting function.\n\n    Returns:\n        The inspected result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.inspect_err_await","title":"<code>inspect_err_await(function: AsyncInspect[E]) -&gt; Result[T, E]</code>  <code>async</code>","text":"<p>Inspects a possibly contained <code>Err[E]</code> value.</p> Example <pre><code>async def function(value: str) -&gt; None:\n    print(value)\n\nerr = Err(\"Bye, world!\")\n\nsame = await err.inspect_err_await(function)  # Bye, world!\n\nassert err == same\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncInspect[E]</code> <p>The asynchronous error-inspecting function.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The inspected result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def inspect_err_await(self, function: AsyncInspect[E]) -&gt; Result[T, E]:\n    \"\"\"Inspects a possibly contained [`Err[E]`][wraps.result.Err] value.\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; None:\n            print(value)\n\n        err = Err(\"Bye, world!\")\n\n        same = await err.inspect_err_await(function)  # Bye, world!\n\n        assert err == same\n        ```\n\n    Arguments:\n        function: The asynchronous error-inspecting function.\n\n    Returns:\n        The inspected result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map","title":"<code>map(function: Unary[T, U]) -&gt; Result[U, E]</code>","text":"<p>Maps a <code>Result[T, E]</code> to a <code>Result[U, E]</code> by applying <code>function</code> to the contained <code>Ok[T]</code> value, leaving any <code>Err[E]</code> values untouched.</p> <p>This function can be used to compose the results of two functions.</p> Example <pre><code>value = 69\nmapped = \"69\"\n\nok = Ok(value)\n\nassert ok.map(str) == Ok(mapped)\n\nerr = Err(0)\n\nassert err.map(str) == err\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>The mapped result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef map(self, function: Unary[T, U]) -&gt; Result[U, E]:\n    \"\"\"Maps a [`Result[T, E]`][wraps.result.Result] to a [`Result[U, E]`][wraps.result.Result]\n    by applying `function` to the contained [`Ok[T]`][wraps.result.Ok] value,\n    leaving any [`Err[E]`][wraps.result.Err] values untouched.\n\n    This function can be used to compose the results of two functions.\n\n    Example:\n        ```python\n        value = 69\n        mapped = \"69\"\n\n        ok = Ok(value)\n\n        assert ok.map(str) == Ok(mapped)\n\n        err = Err(0)\n\n        assert err.map(str) == err\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The mapped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_or","title":"<code>map_or(default: U, function: Unary[T, U]) -&gt; U</code>","text":"<p>Returns the default value (if errored), or applies the <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>ok = Ok(\"Hello, world!\")\nprint(ok.map_or(42, len))  # 13\n\nerr = Err(\"error...\")\nprint(err.map_or(42, len))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>U</code> <p>The default value to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n    \"\"\"Returns the default value (if errored), or applies the `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        ok = Ok(\"Hello, world!\")\n        print(ok.map_or(42, len))  # 13\n\n        err = Err(\"error...\")\n        print(err.map_or(42, len))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_or_else","title":"<code>map_or_else(default: Nullary[U], function: Unary[T, U]) -&gt; U</code>","text":"<p>Computes the default value (if errored), or applies the <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>ok = Ok(\"Hello, world!\")\nprint(ok.map_or_else(int, len))  # 13\n\nerr = Err(\"error!\")\nprint(err.map_or_else(int, len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[U]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the default computed value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n    \"\"\"Computes the default value (if errored), or applies the `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        ok = Ok(\"Hello, world!\")\n        print(ok.map_or_else(int, len))  # 13\n\n        err = Err(\"error!\")\n        print(err.map_or_else(int, len))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the default computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_or_else_await","title":"<code>map_or_else_await(default: AsyncNullary[U], function: Unary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value (if errored), or applies the <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_or_else_await(default, len))  # 13\n\nerr = Err(\"error!\")\nprint(await err.map_or_else_await(default, len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[U]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the default computed value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n    \"\"\"Computes the default value (if errored), or applies the `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_or_else_await(default, len))  # 13\n\n        err = Err(\"error!\")\n        print(await err.map_or_else_await(default, len))  # 0\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the default computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_err","title":"<code>map_err(function: Unary[E, F]) -&gt; Result[T, F]</code>","text":"<p>Maps a <code>Result[T, E]</code> to a <code>Result[T, F]</code> by applying the <code>function</code> to the contained <code>Err[E]</code> value, leaving any <code>Ok[T]</code> values untouched.</p> Example <pre><code>value = 42\nmapped = \"42\"\n\nerr = Err(value)\n\nassert err.map_err(str) == Err(mapped)\n\nok = Ok(2)\n\nassert ok.map_err(str) == ok\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[E, F]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>The mapped result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef map_err(self, function: Unary[E, F]) -&gt; Result[T, F]:\n    \"\"\"Maps a [`Result[T, E]`][wraps.result.Result] to a [`Result[T, F]`][wraps.result.Result]\n    by applying the `function` to the contained [`Err[E]`][wraps.result.Err] value,\n    leaving any [`Ok[T]`][wraps.result.Ok] values untouched.\n\n    Example:\n        ```python\n        value = 42\n        mapped = \"42\"\n\n        err = Err(value)\n\n        assert err.map_err(str) == Err(mapped)\n\n        ok = Ok(2)\n\n        assert ok.map_err(str) == ok\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The mapped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_err_or","title":"<code>map_err_or(default: F, function: Unary[E, F]) -&gt; F</code>","text":"<p>Returns the default value (if succeeded), or applies the <code>function</code> to the contained error value (if errored).</p> Example <pre><code>err = Err(\"nekit\")\nprint(err.map_err_or(13, len))  # 5\n\nok = Ok(\"ok\")\nprint(ok.map_err_or(13, len))  # 13\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>F</code> <p>The default value to use.</p> required <code>function</code> <code>Unary[E, F]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef map_err_or(self, default: F, function: Unary[E, F]) -&gt; F:\n    \"\"\"Returns the default value (if succeeded), or applies the `function`\n    to the contained error value (if errored).\n\n    Example:\n        ```python\n        err = Err(\"nekit\")\n        print(err.map_err_or(13, len))  # 5\n\n        ok = Ok(\"ok\")\n        print(ok.map_err_or(13, len))  # 13\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_err_or_else","title":"<code>map_err_or_else(default: Nullary[F], function: Unary[E, F]) -&gt; F</code>","text":"<p>Computes the default value (if succeeded), or applies the <code>function</code> to the contained value (if errored).</p> Example <pre><code>err = Err(\"error...\")\nprint(err.map_err_or_else(int, len))  # 8\n\nok = Ok(\"ok!\")\nprint(ok.map_err_or_else(int, len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[F]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>Unary[E, F]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef map_err_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n    \"\"\"Computes the default value (if succeeded), or applies the `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        err = Err(\"error...\")\n        print(err.map_err_or_else(int, len))  # 8\n\n        ok = Ok(\"ok!\")\n        print(ok.map_err_or_else(int, len))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_err_or_else_await","title":"<code>map_err_or_else_await(default: AsyncNullary[F], function: Unary[E, F]) -&gt; F</code>  <code>async</code>","text":"<p>Computes the default value (if succeeded), or applies the <code>function</code> to the contained value (if errored).</p> Example <pre><code>err = Err(\"error...\")\nprint(await err.map_err_or_else(int, len))  # 8\n\nok = Ok(\"ok!\")\nprint(await ok.map_err_or_else(int, len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[F]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>Unary[E, F]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_err_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n    \"\"\"Computes the default value (if succeeded), or applies the `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        err = Err(\"error...\")\n        print(await err.map_err_or_else(int, len))  # 8\n\n        ok = Ok(\"ok!\")\n        print(await ok.map_err_or_else(int, len))  # 0\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_await","title":"<code>map_await(function: AsyncUnary[T, U]) -&gt; Result[U, E]</code>  <code>async</code>","text":"<p>Maps a <code>Result[T, E]</code> to a <code>Result[U, E]</code> by applying the asynchronous <code>function</code> to the contained <code>Ok[T]</code> value, leaving any <code>Err[E]</code> values untouched.</p> <p>This function can be used to compose the results of two functions.</p> Example <pre><code>async def function(value: int) -&gt; str:\n    return str(value)\n\nvalue = 69\nmapped = \"69\"\n\nok = Ok(value)\n\nassert await ok.map_await(function) == Ok(mapped)\n\nerr = Err(0)\n\nassert await err.map_await(function) == err\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>The mapped result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_await(self, function: AsyncUnary[T, U]) -&gt; Result[U, E]:\n    \"\"\"Maps a [`Result[T, E]`][wraps.result.Result] to a [`Result[U, E]`][wraps.result.Result]\n    by applying the asynchronous `function` to the contained [`Ok[T]`][wraps.result.Ok] value,\n    leaving any [`Err[E]`][wraps.result.Err] values untouched.\n\n    This function can be used to compose the results of two functions.\n\n    Example:\n        ```python\n        async def function(value: int) -&gt; str:\n            return str(value)\n\n        value = 69\n        mapped = \"69\"\n\n        ok = Ok(value)\n\n        assert await ok.map_await(function) == Ok(mapped)\n\n        err = Err(0)\n\n        assert await err.map_await(function) == err\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The mapped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_await_or","title":"<code>map_await_or(default: U, function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Returns the default value (if errored), or applies the asynchronous <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_await_or(42, function))  # 13\n\nerr = Err(\"error...\")\nprint(err.map_await_or(42, function))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>U</code> <p>The default value to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n    \"\"\"Returns the default value (if errored), or applies the asynchronous `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_await_or(42, function))  # 13\n\n        err = Err(\"error...\")\n        print(err.map_await_or(42, function))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_await_or_else","title":"<code>map_await_or_else(default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value (if errored), or applies the asynchronous <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>async def async_len(value: str) -&gt; int:\n    return len(value)\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_await_or_else(int, async_len))  # 13\n\nerr = Err(\"error!\")\nprint(await err.map_await_or_else(int, async_len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[U]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n    \"\"\"Computes the default value (if errored), or applies the asynchronous `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        async def async_len(value: str) -&gt; int:\n            return len(value)\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_await_or_else(int, async_len))  # 13\n\n        err = Err(\"error!\")\n        print(await err.map_await_or_else(int, async_len))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_await_or_else_await","title":"<code>map_await_or_else_await(default: AsyncNullary[U], function: AsyncUnary[T, U]) -&gt; U</code>  <code>async</code>","text":"<p>Computes the default value (if errored), or applies the asynchronous <code>function</code> to the contained value (if succeeded).</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nasync def function(value: str) -&gt; int:\n    return len(value)\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_await_or_else_await(default, function))  # 13\n\nerr = Err(\"error!\")\nprint(await err.map_await_or_else_await(default, function))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[U]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_await_or_else_await(\n    self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n) -&gt; U:\n    \"\"\"Computes the default value (if errored), or applies the asynchronous `function`\n    to the contained value (if succeeded).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_await_or_else_await(default, function))  # 13\n\n        err = Err(\"error!\")\n        print(await err.map_await_or_else_await(default, function))  # 0\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_err_await","title":"<code>map_err_await(function: AsyncUnary[E, F]) -&gt; Result[T, F]</code>  <code>async</code>","text":"<p>Maps a <code>Result[T, E]</code> to a <code>Result[T, F]</code> by applying the asynchronous <code>function</code> to the contained <code>Err[E]</code> value, leaving any <code>Ok[T]</code> values untouched.</p> Example <pre><code>async def function(value: int) -&gt; str:\n    return str(value)\n\nvalue = 42\nmapped = \"42\"\n\nerr = Err(value)\n\nassert await err.map_err_await(function) == Err(mapped)\n\nok = Ok(13)\n\nassert await ok.map_err_await(function) == ok\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[E, F]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>The mapped result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_err_await(self, function: AsyncUnary[E, F]) -&gt; Result[T, F]:\n    \"\"\"Maps a [`Result[T, E]`][wraps.result.Result] to a [`Result[T, F]`][wraps.result.Result]\n    by applying the asynchronous `function` to the contained [`Err[E]`][wraps.result.Err]\n    value, leaving any [`Ok[T]`][wraps.result.Ok] values untouched.\n\n    Example:\n        ```python\n        async def function(value: int) -&gt; str:\n            return str(value)\n\n        value = 42\n        mapped = \"42\"\n\n        err = Err(value)\n\n        assert await err.map_err_await(function) == Err(mapped)\n\n        ok = Ok(13)\n\n        assert await ok.map_err_await(function) == ok\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The mapped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_err_await_or","title":"<code>map_err_await_or(default: F, function: AsyncUnary[E, F]) -&gt; F</code>  <code>async</code>","text":"<p>Returns the default value (if succeeded), or applies the asynchronous <code>function</code> to the contained value (if errored).</p> Example <pre><code>async def function(value: str) -&gt; int:\n    return len(value)\n\nerr = Err(\"Bye, world!\")\nprint(await err.map_err_await_or(42, function))  # 11\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_err_await_or(42, function))  # 42\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>F</code> <p>The default value to use.</p> required <code>function</code> <code>AsyncUnary[E, F]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_err_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n    \"\"\"Returns the default value (if succeeded), or applies the asynchronous `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        err = Err(\"Bye, world!\")\n        print(await err.map_err_await_or(42, function))  # 11\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_err_await_or(42, function))  # 42\n        ```\n\n    Arguments:\n        default: The default value to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_err_await_or_else","title":"<code>map_err_await_or_else(default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F</code>  <code>async</code>","text":"<p>Computes the default value (if succeeded), or applies the asynchronous <code>function</code> to the contained value (if errored).</p> Example <pre><code>async def async_len(value: str) -&gt; int:\n    return len(value)\n\nerr = Err(\"Bye, world!\")\nprint(await err.map_err_await_or_else(int, async_len))  # 11\n\nok = Ok(\"Hello, world!\")\nprint(await ok.map_err_await_or_else(int, async_len))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Nullary[F]</code> <p>The default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[E, F]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the computed default value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_err_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n    \"\"\"Computes the default value (if succeeded), or applies the asynchronous `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        async def async_len(value: str) -&gt; int:\n            return len(value)\n\n        err = Err(\"Bye, world!\")\n        print(await err.map_err_await_or_else(int, async_len))  # 11\n\n        ok = Ok(\"Hello, world!\")\n        print(await ok.map_err_await_or_else(int, async_len))  # 0\n        ```\n\n    Arguments:\n        default: The default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the computed default value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.map_err_await_or_else_await","title":"<code>map_err_await_or_else_await(default: AsyncNullary[F], function: AsyncUnary[E, F]) -&gt; F</code>  <code>async</code>","text":"<p>Computes the default value (if succeeded), or applies the asynchronous <code>function</code> to the contained value (if errored).</p> Example <pre><code>async def default() -&gt; int:\n    return 0\n\nasync def function(value: str) -&gt; int:\n    return len(value)\n\nerr = Err(\"error\")\nprint(await err.map_err_await_or_else_await(default, function))  # 5\n\nok = Ok(\"ok\")\nprint(await ok.map_err_await_or_else_await(default, function))  # 0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>AsyncNullary[F]</code> <p>The asynchronous default-computing function to use.</p> required <code>function</code> <code>AsyncUnary[E, F]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The resulting or the default computed value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def map_err_await_or_else_await(\n    self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n) -&gt; F:\n    \"\"\"Computes the default value (if succeeded), or applies the asynchronous `function`\n    to the contained value (if errored).\n\n    Example:\n        ```python\n        async def default() -&gt; int:\n            return 0\n\n        async def function(value: str) -&gt; int:\n            return len(value)\n\n        err = Err(\"error\")\n        print(await err.map_err_await_or_else_await(default, function))  # 5\n\n        ok = Ok(\"ok\")\n        print(await ok.map_err_await_or_else_await(default, function))  # 0\n        ```\n\n    Arguments:\n        default: The asynchronous default-computing function to use.\n        function: The asynchronous function to apply.\n\n    Returns:\n        The resulting or the default computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.iter","title":"<code>iter() -&gt; Iterator[T]</code>","text":"<p>Returns an iterator over the possibly contained value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; next(ok.iter(), 0)\n42\n&gt;&gt;&gt; err = Err(13)\n&gt;&gt;&gt; next(err.iter(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>An iterator over the possibly contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef iter(self) -&gt; Iterator[T]:\n    \"\"\"Returns an iterator over the possibly contained value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; next(ok.iter(), 0)\n        42\n        &gt;&gt;&gt; err = Err(13)\n        &gt;&gt;&gt; next(err.iter(), 0)\n        0\n        ```\n\n    Returns:\n        An iterator over the possibly contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.iter_err","title":"<code>iter_err() -&gt; Iterator[E]</code>","text":"<p>Returns an iterator over the possibly contained error value.</p> Example <pre><code>&gt;&gt;&gt; err = Err(13)\n&gt;&gt;&gt; next(err.iter_err(), 0)\n13\n&gt;&gt;&gt; ok = Ok(1)\n&gt;&gt;&gt; next(ok.iter_err(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>Iterator[E]</code> <p>An iterator over the possibly contained error value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef iter_err(self) -&gt; Iterator[E]:\n    \"\"\"Returns an iterator over the possibly contained error value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; err = Err(13)\n        &gt;&gt;&gt; next(err.iter_err(), 0)\n        13\n        &gt;&gt;&gt; ok = Ok(1)\n        &gt;&gt;&gt; next(ok.iter_err(), 0)\n        0\n        ```\n\n    Returns:\n        An iterator over the possibly contained error value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.async_iter","title":"<code>async_iter() -&gt; AsyncIterator[T]</code>","text":"<p>Returns an asynchronous iterator over the possibly contained <code>Ok[T]</code> value.</p> Example <pre><code>&gt;&gt;&gt; ok = Ok(42)\n&gt;&gt;&gt; await async_next(ok.async_iter(), 0)\n42\n&gt;&gt;&gt; err = Err(13)\n&gt;&gt;&gt; await async_next(err.async_iter(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>AsyncIterator[T]</code> <p>An asynchronous iterator over the possibly contained value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef async_iter(self) -&gt; AsyncIterator[T]:\n    \"\"\"Returns an asynchronous iterator over the possibly contained\n    [`Ok[T]`][wraps.result.Ok] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; ok = Ok(42)\n        &gt;&gt;&gt; await async_next(ok.async_iter(), 0)\n        42\n        &gt;&gt;&gt; err = Err(13)\n        &gt;&gt;&gt; await async_next(err.async_iter(), 0)\n        0\n        ```\n\n    Returns:\n        An asynchronous iterator over the possibly contained value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.async_iter_err","title":"<code>async_iter_err() -&gt; AsyncIterator[E]</code>","text":"<p>Returns an asynchronous iterator over the possibly contained <code>Err[E]</code> value.</p> Example <pre><code>&gt;&gt;&gt; err = Err(42)\n&gt;&gt;&gt; await async_next(err.async_iter_err(), 0)\n42\n&gt;&gt;&gt; ok = Ok(13)\n&gt;&gt;&gt; await async_next(ok.async_iter_err(), 0)\n0\n</code></pre> <p>Returns:</p> Type Description <code>AsyncIterator[E]</code> <p>An asynchronous iterator over the possibly contained error value.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef async_iter_err(self) -&gt; AsyncIterator[E]:\n    \"\"\"Returns an asynchronous iterator over the possibly contained\n    [`Err[E]`][wraps.result.Err] value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; err = Err(42)\n        &gt;&gt;&gt; await async_next(err.async_iter_err(), 0)\n        42\n        &gt;&gt;&gt; ok = Ok(13)\n        &gt;&gt;&gt; await async_next(ok.async_iter_err(), 0)\n        0\n        ```\n\n    Returns:\n        An asynchronous iterator over the possibly contained error value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.and_then","title":"<code>and_then(function: Unary[T, Result[U, E]]) -&gt; Result[U, E]</code>","text":"<p>Returns the result if it is an <code>Err[E]</code>, otherwise calls the <code>function</code> with the wrapped value and returns the result.</p> <p>This function is also known as bind in functional programming.</p> Example <pre><code>def inverse(value: float) -&gt; Result[float, str]:\n    return Ok(1.0 / value) if value else Err(\"division by zero\")\n\ntwo = Ok(2.0)\nprint(two.and_then(inverse).unwrap())  # 0.5\n\nzero = Ok(0.0)\nprint(zero.and_then(inverse).unwrap_err())  # division by zero\n\nerr = Err(1.0)\nprint(err.and_then(inverse).unwrap_err())  # 1.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, Result[U, E]]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>The bound result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef and_then(self, function: Unary[T, Result[U, E]]) -&gt; Result[U, E]:\n    \"\"\"Returns the result if it is an [`Err[E]`][wraps.result.Err],\n    otherwise calls the `function` with the wrapped value and returns the result.\n\n    This function is also known as *bind* in functional programming.\n\n    Example:\n        ```python\n        def inverse(value: float) -&gt; Result[float, str]:\n            return Ok(1.0 / value) if value else Err(\"division by zero\")\n\n        two = Ok(2.0)\n        print(two.and_then(inverse).unwrap())  # 0.5\n\n        zero = Ok(0.0)\n        print(zero.and_then(inverse).unwrap_err())  # division by zero\n\n        err = Err(1.0)\n        print(err.and_then(inverse).unwrap_err())  # 1.0\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The bound result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.and_then_await","title":"<code>and_then_await(function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]</code>  <code>async</code>","text":"<p>Returns the result if it is an <code>Err[E]</code>, otherwise calls the asynchronous <code>function</code> with the wrapped value and returns the result.</p> Example <pre><code>async def inverse(value: float) -&gt; Result[float, str]:\n    return Ok(1.0 / value) if value else Err(\"division by zero\")\n\ntwo = Ok(2.0)\nprint((await two.and_then_await(inverse)).unwrap())  # 0.5\n\nzero = Ok(0.0)\nprint((await zero.and_then_await(inverse)).unwrap_err())  # division by zero\n\nerr = Err(1.0)\nprint((await err.and_then_await(inverse)).unwrap_err())  # 1.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, Result[U, E]]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>The bound result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]:\n    \"\"\"Returns the result if it is an [`Err[E]`][wraps.result.Err],\n    otherwise calls the asynchronous `function` with the wrapped value and returns the result.\n\n    Example:\n        ```python\n        async def inverse(value: float) -&gt; Result[float, str]:\n            return Ok(1.0 / value) if value else Err(\"division by zero\")\n\n        two = Ok(2.0)\n        print((await two.and_then_await(inverse)).unwrap())  # 0.5\n\n        zero = Ok(0.0)\n        print((await zero.and_then_await(inverse)).unwrap_err())  # division by zero\n\n        err = Err(1.0)\n        print((await err.and_then_await(inverse)).unwrap_err())  # 1.0\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The bound result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.or_else","title":"<code>or_else(function: Unary[E, Result[T, F]]) -&gt; Result[T, F]</code>","text":"<p>Returns the result if it is <code>Ok[T]</code>, otherwise calls the <code>function</code> with the wrapped error value and returns the result.</p> Example <pre><code>def check_non_zero(value: int) -&gt; Result[int, str]:\n    return Ok(value) if value else Err(\"the value is zero\")\n\nerr = Err(5)\nprint(err.or_else(check_non_zero).unwrap())  # 5\n\nzero = Err(0)\nprint(zero.or_else(check_non_zero).unwrap_err())  # the value is zero\n\nok = Ok(1)\nprint(ok.or_else(check_non_zero).unwrap())  # 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[E, Result[T, F]]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>The bound result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef or_else(self, function: Unary[E, Result[T, F]]) -&gt; Result[T, F]:\n    \"\"\"Returns the result if it is [`Ok[T]`][wraps.result.Ok], otherwise calls the `function`\n    with the wrapped error value and returns the result.\n\n    Example:\n        ```python\n        def check_non_zero(value: int) -&gt; Result[int, str]:\n            return Ok(value) if value else Err(\"the value is zero\")\n\n        err = Err(5)\n        print(err.or_else(check_non_zero).unwrap())  # 5\n\n        zero = Err(0)\n        print(zero.or_else(check_non_zero).unwrap_err())  # the value is zero\n\n        ok = Ok(1)\n        print(ok.or_else(check_non_zero).unwrap())  # 1\n        ```\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The bound result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.or_else_await","title":"<code>or_else_await(function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]</code>  <code>async</code>","text":"<p>Returns the result if it is <code>Ok[T]</code>, otherwise calls the asynchronous <code>function</code> with the wrapped error value and returns the result.</p> Example <pre><code>async def check_non_zero(value: int) -&gt; Result[int, str]:\n    return Ok(value) if value else Err(\"the value is zero\")\n\nerr = Err(5)\n\nprint((await err.or_else_await(check_non_zero)).unwrap())  # 5\n\nzero = Err(0)\nprint((await zero.or_else_await(check_non_zero)).unwrap_err())  # the value is zero\n\nok = Ok(1)\nprint((await ok.or_else_await(check_non_zero)).unwrap())  # 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[E, Result[T, F]]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>The bound result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\nasync def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]:\n    \"\"\"Returns the result if it is [`Ok[T]`][wraps.result.Ok], otherwise calls the asynchronous\n    `function` with the wrapped error value and returns the result.\n\n    Example:\n        ```python\n        async def check_non_zero(value: int) -&gt; Result[int, str]:\n            return Ok(value) if value else Err(\"the value is zero\")\n\n        err = Err(5)\n\n        print((await err.or_else_await(check_non_zero)).unwrap())  # 5\n\n        zero = Err(0)\n        print((await zero.or_else_await(check_non_zero)).unwrap_err())  # the value is zero\n\n        ok = Ok(1)\n        print((await ok.or_else_await(check_non_zero)).unwrap())  # 1\n        ```\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The bound result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.try_flatten","title":"<code>try_flatten() -&gt; Result[T, E]</code>","text":"<p>Flattens a <code>Result[Result[T, E], E]</code> into a <code>Result[T, E]</code>.</p> <p>This is equivalent to <code>result.and_then(identity)</code>.</p> Example <pre><code>ok = Ok(42)\nok_nested = Ok(ok)\nassert ok_nested.try_flatten() == ok\n\nerr = Err(13)\nerr_nested = Ok(err)\nassert err_nested.try_flatten() == err\n\nassert err.try_flatten() == err\n</code></pre> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The flattened result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>def try_flatten(self: ResultProtocol[ResultProtocol[T, E], E]) -&gt; Result[T, E]:\n    \"\"\"Flattens a [`Result[Result[T, E], E]`][wraps.result.Result]\n    into a [`Result[T, E]`][wraps.result.Result].\n\n    This is equivalent to [`result.and_then(identity)`][wraps.result.ResultProtocol.and_then].\n\n    Example:\n        ```python\n        ok = Ok(42)\n        ok_nested = Ok(ok)\n        assert ok_nested.try_flatten() == ok\n\n        err = Err(13)\n        err_nested = Ok(err)\n        assert err_nested.try_flatten() == err\n\n        assert err.try_flatten() == err\n        ```\n\n    Returns:\n        The flattened result.\n    \"\"\"\n    return self.and_then(identity)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.try_flatten_err","title":"<code>try_flatten_err() -&gt; Result[T, E]</code>","text":"<p>Flattens a <code>Result[T, Result[T, E]]</code> into a <code>Result[T, E]</code>.</p> <p>This is equivalent to <code>result.or_else(identity)</code>.</p> Example <pre><code>ok = Ok(42)\nok_nested = Err(ok)\nassert ok_nested.try_flatten_err() == err\n\nerr = Err(13)\nerr_nested = Err(err)\nassert err_nested.try_flatten_err() == err\n\nassert ok.try_flatten_err() == ok\n</code></pre> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>The flattened result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>def try_flatten_err(self: ResultProtocol[T, ResultProtocol[T, E]]) -&gt; Result[T, E]:\n    \"\"\"Flattens a [`Result[T, Result[T, E]]`][wraps.result.Result]\n    into a [`Result[T, E]`][wraps.result.Result].\n\n    This is equivalent to [`result.or_else(identity)`][wraps.result.ResultProtocol.or_else].\n\n    Example:\n        ```python\n        ok = Ok(42)\n        ok_nested = Err(ok)\n        assert ok_nested.try_flatten_err() == err\n\n        err = Err(13)\n        err_nested = Err(err)\n        assert err_nested.try_flatten_err() == err\n\n        assert ok.try_flatten_err() == ok\n        ```\n\n    Returns:\n        The flattened result.\n    \"\"\"\n    return self.or_else(identity)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.contains","title":"<code>contains(value: U) -&gt; bool</code>","text":"<p>Checks if the contained value is equal to the <code>value</code>.</p> Example <pre><code>value = 42\nother = 69\n\nok = Ok(value)\nassert ok.contains(value)\nassert not ok.contains(other)\n\nerr = Err(value)\nassert not err.contains(value)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>U</code> <p>The value to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the contained value is equal to the <code>value</code>.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef contains(self, value: U) -&gt; bool:\n    \"\"\"Checks if the contained value is equal to the `value`.\n\n    Example:\n        ```python\n        value = 42\n        other = 69\n\n        ok = Ok(value)\n        assert ok.contains(value)\n        assert not ok.contains(other)\n\n        err = Err(value)\n        assert not err.contains(value)\n        ```\n\n    Arguments:\n        value: The value to check against.\n\n    Returns:\n        Whether the contained value is equal to the `value`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.contains_err","title":"<code>contains_err(error: F) -&gt; bool</code>","text":"<p>Checks if the contained error value is equal to the <code>error</code>.</p> Example <pre><code>value = 42\nother = 69\n\nerr = Err(value)\nassert err.contains_err(value)\nassert not err.contains_err(other)\n\nok = Ok(value)\nassert not ok.contains_err(value)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>F</code> <p>The error value to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the contained error value is equal to the <code>error</code>.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef contains_err(self, error: F) -&gt; bool:\n    \"\"\"Checks if the contained error value is equal to the `error`.\n\n    Example:\n        ```python\n        value = 42\n        other = 69\n\n        err = Err(value)\n        assert err.contains_err(value)\n        assert not err.contains_err(other)\n\n        ok = Ok(value)\n        assert not ok.contains_err(value)\n        ```\n\n    Arguments:\n        error: The error value to check against.\n\n    Returns:\n        Whether the contained error value is equal to the `error`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.flip","title":"<code>flip() -&gt; Result[E, T]</code>","text":"<p>Converts a <code>Result[T, E]</code> into a <code>Result[E, T]</code>.</p> <p><code>Ok(value)</code> and <code>Err(error)</code> get swapped to <code>Err(value)</code> and <code>Ok(error)</code> respectively.</p> Example <pre><code>value = 42\n\nresult = Ok(value)\nflipped = Err(value)\n\nassert result.flip() == flipped\n</code></pre> <p>Returns:</p> Type Description <code>Result[E, T]</code> <p>The flipped result.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef flip(self) -&gt; Result[E, T]:\n    \"\"\"Converts a [`Result[T, E]`][wraps.result.Result]\n    into a [`Result[E, T]`][wraps.result.Result].\n\n    [`Ok(value)`][wraps.result.Ok] and [`Err(error)`][wraps.result.Err] get swapped to\n    [`Err(value)`][wraps.result.Err] and [`Ok(error)`][wraps.result.Ok] respectively.\n\n    Example:\n        ```python\n        value = 42\n\n        result = Ok(value)\n        flipped = Err(value)\n\n        assert result.flip() == flipped\n        ```\n\n    Returns:\n        The flipped result.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.into_ok_or_err","title":"<code>into_ok_or_err() -&gt; V</code>","text":"<p>Returns the value contained within <code>Result[V, V]</code>, regardless of whether or not that result is <code>Ok[V]</code> or <code>Err[V]</code>.</p> Example <pre><code>result: Result[int, int] = Ok(69)\n\nprint(result.into_ok_or_err())  # 69; inferred `int`\n\nresult = Err(42)\n\nprint(result.into_ok_or_err())  # 42; inferred `int`\n</code></pre> <p>Returns:</p> Type Description <code>V</code> <p>The contained value, regardless of whether or not it is an error one.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef into_ok_or_err(self: ResultProtocol[V, V]) -&gt; V:\n    \"\"\"Returns the value contained within [`Result[V, V]`][wraps.result.Result], regardless\n    of whether or not that result is [`Ok[V]`][wraps.result.Ok]\n    or [`Err[V]`][wraps.result.Err].\n\n    Example:\n        ```python\n        result: Result[int, int] = Ok(69)\n\n        print(result.into_ok_or_err())  # 69; inferred `int`\n\n        result = Err(42)\n\n        print(result.into_ok_or_err())  # 42; inferred `int`\n        ```\n\n    Returns:\n        The contained value, regardless of whether or not it is an error one.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.into_either","title":"<code>into_either() -&gt; Either[T, E]</code>","text":"<p>Converts a <code>Result[T, E]</code> into an <code>Either[T, E]</code>.</p> <p><code>Ok(value)</code> is mapped to <code>Left(value)</code> and <code>Err(error)</code> is mapped to <code>Right(error)</code>.</p> Example <pre><code>value = 42\n\nok = Ok(value)\nleft = Left(value)\n\nassert ok.into_either() == left\n\nerr = Err(value)\nright = Right(value)\n\nassert err.into_either() == right\n</code></pre> <p>Returns:</p> Type Description <code>Either[T, E]</code> <p>The mapped either.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef into_either(self) -&gt; Either[T, E]:\n    \"\"\"Converts a [`Result[T, E]`][wraps.result.Result]\n    into an [`Either[T, E]`][wraps.either.Either].\n\n    [`Ok(value)`][wraps.result.Ok] is mapped to [`Left(value)`][wraps.either.Left]\n    and [`Err(error)`][wraps.result.Err] is mapped to [`Right(error)`][wraps.either.Right].\n\n    Example:\n        ```python\n        value = 42\n\n        ok = Ok(value)\n        left = Left(value)\n\n        assert ok.into_either() == left\n\n        err = Err(value)\n        right = Right(value)\n\n        assert err.into_either() == right\n        ```\n\n    Returns:\n        The mapped either.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.ResultProtocol.early","title":"<code>early() -&gt; T</code>","text":"<p>Functionally similar to the question-mark (<code>?</code>) operator in Rust.</p> <p>Calls to this method are to be combined with <code>@early_result</code> decorators to work properly.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@required\ndef early(self) -&gt; T:\n    \"\"\"Functionally similar to the *question-mark* (`?`) operator in Rust.\n\n    Calls to this method are to be combined with\n    [`@early_result`][wraps.early.decorators.early_result] decorators to work properly.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/result/#wraps.result.Ok","title":"<code>Ok</code>","text":"<p>               Bases: <code>ResultProtocol[T, Never]</code></p> <p><code>Ok[T]</code> variant of <code>Result[T, E]</code>.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@final\n@frozen()\nclass Ok(ResultProtocol[T, Never]):\n    \"\"\"[`Ok[T]`][wraps.result.Ok] variant of [`Result[T, E]`][wraps.result.Result].\"\"\"\n\n    value: T\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, value: U) -&gt; Ok[U]:\n        return cls(value)  # type: ignore[arg-type, return-value]\n\n    def is_ok(self) -&gt; Literal[True]:\n        return True\n\n    def is_ok_and(self, predicate: Predicate[T]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        return await predicate(self.value)\n\n    def is_err(self) -&gt; Literal[False]:\n        return False\n\n    def is_err_and(self, predicate: Predicate[E]) -&gt; Literal[False]:\n        return False\n\n    async def is_err_and_await(self, predicate: AsyncPredicate[E]) -&gt; Literal[False]:\n        return False\n\n    def expect(self, message: str) -&gt; T:\n        return self.value\n\n    def expect_err(self, message: str) -&gt; Never:\n        panic(message)\n\n    def unwrap(self) -&gt; T:\n        return self.value\n\n    def unwrap_or(self, default: U) -&gt; T:\n        return self.value\n\n    def unwrap_or_else(self, default: Nullary[U]) -&gt; T:\n        return self.value\n\n    async def unwrap_or_else_await(self, default: AsyncNullary[U]) -&gt; T:\n        return self.value\n\n    def or_raise(self, error: AnyError) -&gt; T:\n        return self.value\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        return self.value\n\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        return self.value\n\n    def or_raise_from(self, error: Unary[E, AnyError]) -&gt; T:\n        return self.value\n\n    async def or_raise_from_await(self, error: AsyncUnary[E, AnyError]) -&gt; T:\n        return self.value\n\n    def unwrap_err(self) -&gt; Never:\n        panic(UNWRAP_ERR_ON_OK)\n\n    def unwrap_err_or(self, default: F) -&gt; F:\n        return default\n\n    def unwrap_err_or_else(self, default: Nullary[F]) -&gt; F:\n        return default()\n\n    async def unwrap_err_or_else_await(self, default: AsyncNullary[F]) -&gt; F:\n        return await default()\n\n    def raising(self) -&gt; T:\n        return self.value\n\n    def ok(self) -&gt; Some[T]:\n        return Some(self.value)\n\n    def err(self) -&gt; Null:\n        return NULL\n\n    def inspect(self, function: Inspect[T]) -&gt; Ok[T]:\n        function(self.value)\n\n        return self\n\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Ok[T]:\n        await function(self.value)\n\n        return self\n\n    def inspect_err(self, function: Inspect[E]) -&gt; Ok[T]:\n        return self\n\n    async def inspect_err_await(self, function: AsyncInspect[E]) -&gt; Ok[T]:\n        return self\n\n    def map(self, function: Unary[T, U]) -&gt; Ok[U]:\n        return self.create(function(self.value))\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    def map_err(self, function: Unary[E, F]) -&gt; Ok[T]:\n        return self\n\n    def map_err_or(self, default: F, function: Unary[E, F]) -&gt; F:\n        return default\n\n    def map_err_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n        return default()\n\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return function(self.value)\n\n    async def map_err_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n        return await default()\n\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Ok[U]:\n        return self.create(await function(self.value))\n\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return await function(self.value)\n\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return await function(self.value)\n\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await function(self.value)\n\n    async def map_err_await(self, function: AsyncUnary[E, F]) -&gt; Ok[T]:\n        return self\n\n    async def map_err_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n        return default\n\n    async def map_err_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n        return default()\n\n    async def map_err_await_or_else_await(\n        self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n    ) -&gt; F:\n        return await default()\n\n    def iter(self) -&gt; Iterator[T]:\n        return once(self.value)\n\n    def iter_err(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def async_iter(self) -&gt; AsyncIterator[T]:\n        return async_once(self.value)\n\n    def async_iter_err(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def and_then(self, function: Unary[T, Result[U, E]]) -&gt; Result[U, E]:\n        return function(self.value)\n\n    async def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]:\n        return await function(self.value)\n\n    def or_else(self, function: Unary[E, Result[T, F]]) -&gt; Ok[T]:\n        return self\n\n    async def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Ok[T]:\n        return self\n\n    def contains(self, value: U) -&gt; bool:\n        return self.value == value\n\n    def contains_err(self, error: F) -&gt; Literal[False]:\n        return False\n\n    def flip(self) -&gt; Err[T]:\n        return Err(self.value)\n\n    def into_ok_or_err(self: Ok[V]) -&gt; V:\n        return self.value\n\n    def into_either(self) -&gt; Left[T]:\n        return Left(self.value)\n\n    def early(self) -&gt; T:\n        return self.value\n</code></pre>"},{"location":"reference/result/#wraps.result.Err","title":"<code>Err</code>","text":"<p>               Bases: <code>ResultProtocol[Never, E]</code></p> <p><code>Err[E]</code> variant of <code>Result[T, E]</code>.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@final\n@frozen()\nclass Err(ResultProtocol[Never, E]):\n    \"\"\"[`Err[E]`][wraps.result.Err] variant of [`Result[T, E]`][wraps.result.Result].\"\"\"\n\n    value: E\n\n    def __bool__(self) -&gt; Literal[False]:\n        return False\n\n    def __repr__(self) -&gt; str:\n        return wrap_repr(self, self.value)\n\n    @classmethod\n    def create(cls, error: F) -&gt; Err[F]:\n        return cls(error)  # type: ignore[arg-type, return-value]\n\n    def is_ok(self) -&gt; Literal[False]:\n        return False\n\n    def is_ok_and(self, predicate: Predicate[T]) -&gt; Literal[False]:\n        return False\n\n    async def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; Literal[False]:\n        return False\n\n    def is_err(self) -&gt; Literal[True]:\n        return True\n\n    def is_err_and(self, predicate: Predicate[E]) -&gt; bool:\n        return predicate(self.value)\n\n    async def is_err_and_await(self, predicate: AsyncPredicate[E]) -&gt; bool:\n        return await predicate(self.value)\n\n    def ok(self) -&gt; Null:\n        return NULL\n\n    def err(self) -&gt; Some[E]:\n        return Some(self.value)\n\n    def expect(self, message: str) -&gt; Never:\n        panic(message)\n\n    def unwrap(self) -&gt; Never:\n        panic(UNWRAP_ON_ERR)\n\n    def expect_err(self, message: str) -&gt; E:\n        return self.value\n\n    def unwrap_err(self) -&gt; E:\n        return self.value\n\n    def unwrap_or(self, default: U) -&gt; U:\n        return default\n\n    def unwrap_or_else(self, default: Nullary[U]) -&gt; U:\n        return default()\n\n    async def unwrap_or_else_await(self, default: AsyncNullary[U]) -&gt; U:\n        return await default()\n\n    def or_raise(self, error: AnyError) -&gt; Never:\n        raise error\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; Never:\n        raise error()\n\n    async def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; Never:\n        raise await error()\n\n    def or_raise_from(self, error: Unary[E, AnyError]) -&gt; Never:\n        raise error(self.value)\n\n    async def or_raise_from_await(self, error: AsyncUnary[E, AnyError]) -&gt; Never:\n        raise await error(self.value)\n\n    def unwrap_err_or(self, default: F) -&gt; E:\n        return self.value\n\n    def unwrap_err_or_else(self, default: Nullary[F]) -&gt; E:\n        return self.value\n\n    async def unwrap_err_or_else_await(self, default: AsyncNullary[F]) -&gt; E:\n        return self.value\n\n    def raising(self: Err[AnyError]) -&gt; Never:\n        raise self.value\n\n    def inspect(self, function: Inspect[T]) -&gt; Err[E]:\n        return self\n\n    async def inspect_await(self, function: AsyncInspect[T]) -&gt; Err[E]:\n        return self\n\n    def inspect_err(self, function: Inspect[E]) -&gt; Err[E]:\n        function(self.value)\n\n        return self\n\n    async def inspect_err_await(self, function: AsyncInspect[E]) -&gt; Err[E]:\n        await function(self.value)\n\n        return self\n\n    def map(self, function: Unary[T, U]) -&gt; Err[E]:\n        return self\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return default\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return default()\n\n    def map_err(self, function: Unary[E, F]) -&gt; Err[F]:\n        return self.create(function(self.value))\n\n    def map_err_or(self, default: F, function: Unary[E, F]) -&gt; F:\n        return function(self.value)\n\n    def map_err_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n        return function(self.value)\n\n    async def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return await default()\n\n    async def map_err_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n        return function(self.value)\n\n    async def map_await(self, function: AsyncUnary[T, U]) -&gt; Err[E]:\n        return self\n\n    async def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return default\n\n    async def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return default()\n\n    async def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await default()\n\n    async def map_err_await(self, function: AsyncUnary[E, F]) -&gt; Err[F]:\n        return self.create(await function(self.value))\n\n    async def map_err_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n        return await function(self.value)\n\n    async def map_err_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n        return await function(self.value)\n\n    async def map_err_await_or_else_await(\n        self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n    ) -&gt; F:\n        return await function(self.value)\n\n    def iter(self) -&gt; Iterator[Never]:\n        return empty()\n\n    def iter_err(self) -&gt; Iterator[E]:\n        return once(self.value)\n\n    def async_iter(self) -&gt; AsyncIterator[Never]:\n        return async_empty()\n\n    def async_iter_err(self) -&gt; AsyncIterator[E]:\n        return async_once(self.value)\n\n    def and_then(self, function: Unary[T, Result[U, E]]) -&gt; Err[E]:\n        return self\n\n    async def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Err[E]:\n        return self\n\n    def or_else(self, function: Unary[E, Result[T, F]]) -&gt; Result[T, F]:\n        return function(self.value)\n\n    async def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]:\n        return await function(self.value)\n\n    def contains(self, value: U) -&gt; Literal[False]:\n        return False\n\n    def contains_err(self, error: F) -&gt; bool:\n        return self.value == error\n\n    def flip(self) -&gt; Ok[E]:\n        return Ok(self.value)\n\n    def into_ok_or_err(self: Err[V]) -&gt; V:\n        return self.value\n\n    def into_either(self) -&gt; Right[E]:\n        return Right(self.value)\n\n    def early(self) -&gt; Never:\n        raise EarlyResult(self.value)\n</code></pre>"},{"location":"reference/result/#wraps.result.WrapResult","title":"<code>WrapResult</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Wraps functions returning <code>T</code> into functions returning <code>Result[T, E]</code>.</p> <p>Errors are handled via returning <code>Err(error)</code> on <code>error</code> of <code>error_types</code>, wrapping the resulting <code>value</code> into <code>Ok(value)</code>.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@final\n@frozen()\nclass WrapResult(Generic[A]):\n    \"\"\"Wraps functions returning `T` into functions returning\n    [`Result[T, E]`][wraps.result.Result].\n\n    Errors are handled via returning [`Err(error)`][wraps.result.Err] on `error` of\n    [`error_types`][wraps.result.WrapResult.error_types], wrapping the resulting\n    `value` into [`Ok(value)`][wraps.result.Ok].\n    \"\"\"\n\n    error_types: ErrorTypes[A]\n    \"\"\"The error types to handle. See [`ErrorTypes[A]`][wraps.errors.ErrorTypes].\"\"\"\n\n    def __call__(self, function: Callable[P, T]) -&gt; ResultCallable[P, T, A]:\n        @wraps(function)\n        def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, A]:\n            try:\n                return Ok(function(*args, **kwargs))\n\n            except self.error_types.extract() as error:\n                return Err(error)\n\n        return wrap\n</code></pre>"},{"location":"reference/result/#wraps.result.WrapResult.error_types","title":"<code>error_types: ErrorTypes[A]</code>  <code>instance-attribute</code>","text":"<p>The error types to handle. See <code>ErrorTypes[A]</code>.</p>"},{"location":"reference/result/#wraps.result.WrapResultAwait","title":"<code>WrapResultAwait</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Wraps asynchronous functions returning <code>T</code> into asynchronous functions returning <code>Result[T, E]</code>.</p> <p>Errors are handled via returning <code>Err(error)</code> on <code>error</code> of <code>error_types</code>, wrapping the resulting <code>value</code> into <code>Ok(value)</code>.</p> Source code in <code>src/wraps/result.py</code> <pre><code>@final\n@frozen()\nclass WrapResultAwait(Generic[A]):\n    \"\"\"Wraps asynchronous functions returning `T` into asynchronous functions returning\n    [`Result[T, E]`][wraps.result.Result].\n\n    Errors are handled via returning [`Err(error)`][wraps.result.Err] on `error` of\n    [`error_types`][wraps.result.WrapResult.error_types], wrapping the resulting\n    `value` into [`Ok(value)`][wraps.result.Ok].\n    \"\"\"\n\n    error_types: ErrorTypes[A]\n    \"\"\"The error types to handle. See [`ErrorTypes[A]`][wraps.errors.ErrorTypes].\"\"\"\n\n    def __call__(self, function: AsyncCallable[P, T]) -&gt; ResultAsyncCallable[P, T, A]:\n        @wraps(function)\n        async def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, A]:\n            try:\n                return Ok(await function(*args, **kwargs))\n\n            except self.error_types.extract() as error:\n                return Err(error)\n\n        return wrap\n</code></pre>"},{"location":"reference/result/#wraps.result.WrapResultAwait.error_types","title":"<code>error_types: ErrorTypes[A]</code>  <code>instance-attribute</code>","text":"<p>The error types to handle. See <code>ErrorTypes[A]</code>.</p>"},{"location":"reference/result/#wraps.result.is_ok","title":"<code>is_ok(result: Result[T, E]) -&gt; TypeIs[Ok[T]]</code>","text":"<p>This is the same as <code>Result.is_ok</code>, except it works as a type guard.</p> Source code in <code>src/wraps/result.py</code> <pre><code>def is_ok(result: Result[T, E]) -&gt; TypeIs[Ok[T]]:\n    \"\"\"This is the same as [`Result.is_ok`][wraps.result.ResultProtocol.is_ok],\n    except it works as a *type guard*.\n    \"\"\"\n    return result.is_ok()\n</code></pre>"},{"location":"reference/result/#wraps.result.is_err","title":"<code>is_err(result: Result[T, E]) -&gt; TypeIs[Err[E]]</code>","text":"<p>This is the same as <code>Result.is_err</code>, except it works as a type guard.</p> Source code in <code>src/wraps/result.py</code> <pre><code>def is_err(result: Result[T, E]) -&gt; TypeIs[Err[E]]:\n    \"\"\"This is the same as [`Result.is_err`][wraps.result.ResultProtocol.is_err],\n    except it works as a *type guard*.\n    \"\"\"\n    return result.is_err()\n</code></pre>"},{"location":"reference/result/#wraps.result.wrap_result_on","title":"<code>wrap_result_on(head: Type[A], *tail: Type[A]) -&gt; WrapResult[A]</code>","text":"<p>Creates <code>WrapResult[A]</code> decorators.</p> <p>This function enforces at least one error type to be provided.</p> Example <pre><code>@wrap_result_on(ValueError)\ndef parse(string: str) -&gt; int:\n    return int(string)\n\nassert parse(\"128\").is_ok()\nassert parse(\"owo\").is_err()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>Type[A]</code> <p>The head of the error types to handle.</p> required <code>*tail</code> <code>Type[A]</code> <p>The tail of the error types to handle.</p> <code>()</code> <p>Returns:</p> Type Description <code>WrapResult[A]</code> <p>The <code>WrapResult[A]</code> decorator created.</p> Source code in <code>src/wraps/result.py</code> <pre><code>def wrap_result_on(head: Type[A], *tail: Type[A]) -&gt; WrapResult[A]:\n    \"\"\"Creates [`WrapResult[A]`][wraps.result.WrapResult] decorators.\n\n    This function enforces at least one error type to be provided.\n\n    Example:\n        ```python\n        @wrap_result_on(ValueError)\n        def parse(string: str) -&gt; int:\n            return int(string)\n\n        assert parse(\"128\").is_ok()\n        assert parse(\"owo\").is_err()\n        ```\n\n    Arguments:\n        head: The head of the error types to handle.\n        *tail: The tail of the error types to handle.\n\n    Returns:\n        The [`WrapResult[A]`][wraps.result.WrapResult] decorator created.\n    \"\"\"\n    return WrapResult(ErrorTypes[A].from_head_and_tail(head, *tail))\n</code></pre>"},{"location":"reference/result/#wraps.result.wrap_result_await_on","title":"<code>wrap_result_await_on(head: Type[A], *tail: Type[A]) -&gt; WrapResultAwait[A]</code>","text":"<p>Creates <code>WrapResultAwait[A]</code> decorators.</p> <p>This function enforces at least one error type to be provided.</p> Example <pre><code>@wrap_result_await_on(ValueError)\nasync def parse(string: str) -&gt; int:\n    return int(string)\n\nassert (await parse(\"128\")).is_ok()\nassert (await parse(\"owo\")).is_err()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>Type[A]</code> <p>The head of the error types to handle.</p> required <code>*tail</code> <code>Type[A]</code> <p>The tail of the error types to handle.</p> <code>()</code> <p>Returns:</p> Type Description <code>WrapResultAwait[A]</code> <p>The <code>WrapResultAwait[A]</code> decorator created.</p> Source code in <code>src/wraps/result.py</code> <pre><code>def wrap_result_await_on(head: Type[A], *tail: Type[A]) -&gt; WrapResultAwait[A]:\n    \"\"\"Creates [`WrapResultAwait[A]`][wraps.result.WrapResultAwait] decorators.\n\n    This function enforces at least one error type to be provided.\n\n    Example:\n        ```python\n        @wrap_result_await_on(ValueError)\n        async def parse(string: str) -&gt; int:\n            return int(string)\n\n        assert (await parse(\"128\")).is_ok()\n        assert (await parse(\"owo\")).is_err()\n        ```\n\n    Arguments:\n        head: The head of the error types to handle.\n        *tail: The tail of the error types to handle.\n\n    Returns:\n        The [`WrapResultAwait[A]`][wraps.result.WrapResultAwait] decorator created.\n    \"\"\"\n    return WrapResultAwait(ErrorTypes[A].from_head_and_tail(head, *tail))\n</code></pre>"},{"location":"reference/typing/","title":"Typing","text":"<p>Various type aliases.</p>"},{"location":"reference/typing/#wraps.typing.OptionCallable","title":"<code>OptionCallable = Callable[P, Option[T]]</code>  <code>module-attribute</code>","text":"<p>Represents option callables <code>(**P) -&gt; Option[T]</code>.</p>"},{"location":"reference/typing/#wraps.typing.OptionAsyncCallable","title":"<code>OptionAsyncCallable = AsyncCallable[P, Option[T]]</code>  <code>module-attribute</code>","text":"<p>Represents option async callables <code>async (**P) -&gt; Option[T]</code>.</p>"},{"location":"reference/typing/#wraps.typing.ResultCallable","title":"<code>ResultCallable = Callable[P, Result[T, E]]</code>  <code>module-attribute</code>","text":"<p>Represents result callables <code>(**P) -&gt; Result[T, E]</code>.</p>"},{"location":"reference/typing/#wraps.typing.ResultAsyncCallable","title":"<code>ResultAsyncCallable = AsyncCallable[P, Result[T, E]]</code>  <code>module-attribute</code>","text":"<p>Represents result async callables <code>async (**P) -&gt; Result[T, E]</code>.</p>"},{"location":"reference/typing/#wraps.typing.EitherCallable","title":"<code>EitherCallable = Callable[P, Either[L, R]]</code>  <code>module-attribute</code>","text":"<p>Represents either callables <code>(**P) -&gt; Either[L, R]</code>.</p>"},{"location":"reference/typing/#wraps.typing.EitherAsyncCallable","title":"<code>EitherAsyncCallable = AsyncCallable[P, Either[L, R]]</code>  <code>module-attribute</code>","text":"<p>Represents either async callables <code>async (**P) -&gt; Either[L, R]</code>.</p>"},{"location":"reference/early/decorators/","title":"Decorators","text":"<p>Early return decorators.</p>"},{"location":"reference/early/decorators/#wraps.early.decorators.early_option","title":"<code>early_option(function: OptionCallable[P, T]) -&gt; OptionCallable[P, T]</code>","text":"<p>Decorates the <code>function</code> returning <code>Option[T]</code> to handle early returns via the <code>early</code> (<code>?</code> in Rust) operator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>OptionCallable[P, T]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>OptionCallable[P, T]</code> <p>The wrapping function.</p> Source code in <code>src/wraps/early/decorators.py</code> <pre><code>def early_option(function: OptionCallable[P, T]) -&gt; OptionCallable[P, T]:\n    \"\"\"Decorates the `function` returning [`Option[T]`][wraps.option.Option]\n    to handle *early returns* via the `early` (`?` in Rust) operator.\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Option[T]:\n        try:\n            return function(*args, **kwargs)\n\n        except EarlyOption:\n            return NULL\n\n    return wrap\n</code></pre>"},{"location":"reference/early/decorators/#wraps.early.decorators.early_option_await","title":"<code>early_option_await(function: OptionAsyncCallable[P, T]) -&gt; OptionAsyncCallable[P, T]</code>","text":"<p>Decorates the asynchronous <code>function</code> returning <code>Option[T]</code> to handle early returns via the <code>early</code> (<code>?</code> in Rust) operator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>OptionAsyncCallable[P, T]</code> <p>The asynchronous function to wrap.</p> required <p>Returns:</p> Type Description <code>OptionAsyncCallable[P, T]</code> <p>The asynchronous wrapping function.</p> Source code in <code>src/wraps/early/decorators.py</code> <pre><code>def early_option_await(function: OptionAsyncCallable[P, T]) -&gt; OptionAsyncCallable[P, T]:\n    \"\"\"Decorates the asynchronous `function` returning [`Option[T]`][wraps.option.Option]\n    to handle *early returns* via the `early` (`?` in Rust) operator.\n\n    Arguments:\n        function: The asynchronous function to wrap.\n\n    Returns:\n        The asynchronous wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    async def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Option[T]:\n        try:\n            return await function(*args, **kwargs)\n\n        except EarlyOption:\n            return NULL\n\n    return wrap\n</code></pre>"},{"location":"reference/early/decorators/#wraps.early.decorators.early_result","title":"<code>early_result(function: ResultCallable[P, T, E]) -&gt; ResultCallable[P, T, E]</code>","text":"<p>Decorates the <code>function</code> returning <code>Result[T, E]</code> to handle early returns via the <code>early</code> (<code>?</code> in Rust) operator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>ResultCallable[P, T, E]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>ResultCallable[P, T, E]</code> <p>The wrapping function.</p> Source code in <code>src/wraps/early/decorators.py</code> <pre><code>def early_result(function: ResultCallable[P, T, E]) -&gt; ResultCallable[P, T, E]:\n    \"\"\"Decorates the `function` returning [`Result[T, E]`][wraps.result.Result]\n    to handle *early returns* via the `early` (`?` in Rust) operator.\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, E]:\n        try:\n            return function(*args, **kwargs)\n\n        except EarlyResult[E] as early:\n            return Err(early.error)\n\n    return wrap\n</code></pre>"},{"location":"reference/early/decorators/#wraps.early.decorators.early_result_await","title":"<code>early_result_await(function: ResultAsyncCallable[P, T, E]) -&gt; ResultAsyncCallable[P, T, E]</code>","text":"<p>Decorates the asynchronous <code>function</code> returning <code>Result[T, E]</code> to handle early returns via the <code>early</code> (<code>?</code> in Rust) operator.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>ResultAsyncCallable[P, T, E]</code> <p>The asynchronous function to wrap.</p> required <p>Returns:</p> Type Description <code>ResultAsyncCallable[P, T, E]</code> <p>The asynchronous wrapping function.</p> Source code in <code>src/wraps/early/decorators.py</code> <pre><code>def early_result_await(function: ResultAsyncCallable[P, T, E]) -&gt; ResultAsyncCallable[P, T, E]:\n    \"\"\"Decorates the asynchronous `function` returning [`Result[T, E]`][wraps.result.Result]\n    to handle *early returns* via the `early` (`?` in Rust) operator.\n\n    Arguments:\n        function: The asynchronous function to wrap.\n\n    Returns:\n        The asynchronous wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    async def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Result[T, E]:\n        try:\n            return await function(*args, **kwargs)\n\n        except EarlyResult[E] as early:\n            return Err(early.error)\n\n    return wrap\n</code></pre>"},{"location":"reference/early/errors/","title":"Errors","text":"<p>Early return errors used for propagation.</p>"},{"location":"reference/early/errors/#wraps.early.errors.EarlyOption","title":"<code>EarlyOption</code>","text":"<p>               Bases: <code>AnyError</code></p> <p>The internal error raised by the <code>early</code> method.</p> Source code in <code>src/wraps/early/errors.py</code> <pre><code>class EarlyOption(AnyError):\n    \"\"\"The internal error raised by the [`early`][wraps.option.OptionProtocol.early] method.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(EARLY_OPTION_WITHOUT_DECORATOR)\n</code></pre>"},{"location":"reference/early/errors/#wraps.early.errors.EarlyResult","title":"<code>EarlyResult</code>","text":"<p>               Bases: <code>AnyError</code>, <code>Generic[E]</code></p> <p>The internal error raised by the <code>early</code> method.</p> Source code in <code>src/wraps/early/errors.py</code> <pre><code>class EarlyResult(AnyError, Generic[E]):\n    \"\"\"The internal error raised by the [`early`][wraps.result.ResultProtocol.early] method.\"\"\"\n\n    def __init__(self, error: E) -&gt; None:\n        super().__init__(EARLY_RESULT_WITHOUT_DECORATOR)\n\n        self._error = error\n\n    @property\n    def error(self) -&gt; E:\n        \"\"\"The error to return early.\"\"\"\n        return self._error\n</code></pre>"},{"location":"reference/early/errors/#wraps.early.errors.EarlyResult.error","title":"<code>error: E</code>  <code>property</code>","text":"<p>The error to return early.</p>"},{"location":"reference/futures/either/","title":"Either","text":"<p>Future either values.</p>"},{"location":"reference/futures/either/#wraps.futures.either.future_either","title":"<code>future_either = FutureEither.from_either</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureEither.from_either</code>.</p>"},{"location":"reference/futures/either/#wraps.futures.either.future_left","title":"<code>future_left = FutureEither.from_left</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureEither.from_left</code>.</p>"},{"location":"reference/futures/either/#wraps.futures.either.future_right","title":"<code>future_right = FutureEither.from_right</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureEither.from_right</code>.</p>"},{"location":"reference/futures/either/#wraps.futures.either.FutureEither","title":"<code>FutureEither</code>","text":"<p>               Bases: <code>Future[Either[L, R]]</code></p> <p><code>Future[Either[L, R]]</code>, adapted to leverage future functionality.</p> Source code in <code>src/wraps/futures/either.py</code> <pre><code>@final\n@frozen()\nclass FutureEither(Future[Either[L, R]]):\n    \"\"\"[`Future[Either[L, R]]`][wraps.futures.future.Future],\n    adapted to leverage future functionality.\n    \"\"\"\n\n    awaitable: ReAwaitable[Either[L, R]] = field(converter=ReAwaitable[Either[L, R]])\n\n    @classmethod\n    def create(cls, awaitable: Awaitable[Either[M, S]]) -&gt; FutureEither[M, S]:  # type: ignore[override]\n        return cls(awaitable)  # type: ignore[arg-type, return-value]\n\n    @classmethod\n    def from_either(cls, either: Either[M, S]) -&gt; FutureEither[M, S]:\n        return cls.from_value(either)  # type: ignore[return-value]\n\n    @classmethod\n    def from_left(cls, value: M) -&gt; FutureEither[M, Never]:\n        return cls.from_either(Left(value))\n\n    @classmethod\n    def from_right(cls, value: S) -&gt; FutureEither[Never, S]:\n        return cls.from_either(Right(value))\n\n    def is_left(self) -&gt; Future[bool]:\n        return super().create(self.raw_is_left())\n\n    def is_left_and(self, predicate: Predicate[L]) -&gt; Future[bool]:\n        return super().create(self.raw_is_left_and(predicate))\n\n    def is_left_and_await(self, predicate: AsyncPredicate[L]) -&gt; Future[bool]:\n        return super().create(self.raw_is_left_and_await(predicate))\n\n    def is_right(self) -&gt; Future[bool]:\n        return super().create(self.raw_is_right())\n\n    def is_right_and(self, predicate: Predicate[R]) -&gt; Future[bool]:\n        return super().create(self.raw_is_right_and(predicate))\n\n    def is_right_and_await(self, predicate: AsyncPredicate[R]) -&gt; Future[bool]:\n        return super().create(self.raw_is_right_and_await(predicate))\n\n    async def raw_is_left(self) -&gt; bool:\n        return (await self.awaitable).is_left()\n\n    async def raw_is_left_and(self, predicate: Predicate[L]) -&gt; bool:\n        return (await self.awaitable).is_left_and(predicate)\n\n    async def raw_is_left_and_await(self, predicate: AsyncPredicate[L]) -&gt; bool:\n        return await (await self.awaitable).is_left_and_await(predicate)\n\n    async def raw_is_right(self) -&gt; bool:\n        return (await self.awaitable).is_right()\n\n    async def raw_is_right_and(self, predicate: Predicate[R]) -&gt; bool:\n        return (await self.awaitable).is_right_and(predicate)\n\n    async def raw_is_right_and_await(self, predicate: AsyncPredicate[R]) -&gt; bool:\n        return await (await self.awaitable).is_right_and_await(predicate)\n\n    def expect_left(self, message: str) -&gt; Future[L]:\n        return super().create(self.raw_expect_left(message))\n\n    def expect_right(self, message: str) -&gt; Future[R]:\n        return super().create(self.raw_expect_right(message))\n\n    async def raw_expect_left(self, message: str) -&gt; L:\n        return (await self.awaitable).expect_left(message)\n\n    async def raw_expect_right(self, message: str) -&gt; R:\n        return (await self.awaitable).expect_right(message)\n\n    def unwrap_left(self) -&gt; Future[L]:\n        return super().create(self.raw_unwrap_left())\n\n    def unwrap_right(self) -&gt; Future[R]:\n        return super().create(self.raw_unwrap_right())\n\n    async def raw_unwrap_left(self) -&gt; L:\n        return (await self.awaitable).unwrap_left()\n\n    async def raw_unwrap_right(self) -&gt; R:\n        return (await self.awaitable).unwrap_right()\n\n    def left(self) -&gt; FutureOption[L]:\n        return FutureOption(self.raw_left())\n\n    def left_or(self, default: L) -&gt; Future[L]:  # type: ignore[misc]\n        return super().create(self.raw_left_or(default))\n\n    def left_or_else(self, default: Nullary[L]) -&gt; Future[L]:\n        return super().create(self.raw_left_or_else(default))\n\n    def left_or_else_await(self, default: AsyncNullary[L]) -&gt; Future[L]:\n        return super().create(self.raw_left_or_else_await(default))\n\n    async def raw_left(self) -&gt; Option[L]:\n        return (await self.awaitable).left()\n\n    async def raw_left_or(self, default: L) -&gt; L:  # type: ignore[misc]\n        return (await self.awaitable).left_or(default)\n\n    async def raw_left_or_else(self, default: Nullary[L]) -&gt; L:\n        return (await self.awaitable).left_or_else(default)\n\n    async def raw_left_or_else_await(self, default: AsyncNullary[L]) -&gt; L:\n        return await (await self.awaitable).left_or_else_await(default)\n\n    def right(self) -&gt; FutureOption[R]:\n        return FutureOption(self.raw_right())\n\n    def right_or(self, default: R) -&gt; Future[R]:  # type: ignore[misc]\n        return super().create(self.raw_right_or(default))\n\n    def right_or_else(self, default: Nullary[R]) -&gt; Future[R]:\n        return super().create(self.raw_right_or_else(default))\n\n    def right_or_else_await(self, default: AsyncNullary[R]) -&gt; Future[R]:\n        return super().create(self.raw_right_or_else_await(default))\n\n    async def raw_right(self) -&gt; Option[R]:\n        return (await self.awaitable).right()\n\n    async def raw_right_or(self, default: R) -&gt; R:  # type: ignore[misc]\n        return (await self.awaitable).right_or(default)\n\n    async def raw_right_or_else(self, default: Nullary[R]) -&gt; R:\n        return (await self.awaitable).right_or_else(default)\n\n    async def raw_right_or_else_await(self, default: AsyncNullary[R]) -&gt; R:\n        return await (await self.awaitable).right_or_else_await(default)\n\n    def into_either(self: FutureEither[T, T]) -&gt; Future[T]:\n        return super().create(self.raw_into_either())\n\n    async def raw_into_either(self: FutureEither[T, T]) -&gt; T:\n        return (await self.awaitable).into_either()\n\n    def inspect_left(self, inspect: Inspect[L]) -&gt; FutureEither[L, R]:\n        return self.create(self.raw_inspect_left(inspect))\n\n    def inspect_left_await(self, inspect: AsyncInspect[L]) -&gt; FutureEither[L, R]:\n        return self.create(self.raw_inspect_left_await(inspect))\n\n    def inspect_right(self, inspect: Inspect[R]) -&gt; FutureEither[L, R]:\n        return self.create(self.raw_inspect_right(inspect))\n\n    def inspect_right_await(self, inspect: AsyncInspect[R]) -&gt; FutureEither[L, R]:\n        return self.create(self.raw_inspect_right_await(inspect))\n\n    async def raw_inspect_left(self, inspect: Inspect[L]) -&gt; Either[L, R]:\n        return (await self.awaitable).inspect_left(inspect)\n\n    async def raw_inspect_left_await(self, inspect: AsyncInspect[L]) -&gt; Either[L, R]:\n        return await (await self.awaitable).inspect_left_await(inspect)\n\n    async def raw_inspect_right(self, inspect: Inspect[R]) -&gt; Either[L, R]:\n        return (await self.awaitable).inspect_right(inspect)\n\n    async def raw_inspect_right_await(self, inspect: AsyncInspect[R]) -&gt; Either[L, R]:\n        return await (await self.awaitable).inspect_right_await(inspect)\n\n    async def flip(self) -&gt; FutureEither[R, L]:\n        return self.create(self.raw_flip())\n\n    async def raw_flip(self) -&gt; Either[R, L]:\n        return (await self.awaitable).flip()\n\n    def map_left(self, function: Unary[L, M]) -&gt; FutureEither[M, R]:\n        return self.create(self.raw_map_left(function))\n\n    def map_left_await(self, function: AsyncUnary[L, M]) -&gt; FutureEither[M, R]:\n        return self.create(self.raw_map_left_await(function))\n\n    def map_right(self, function: Unary[R, S]) -&gt; FutureEither[L, S]:\n        return self.create(self.raw_map_right(function))\n\n    def map_right_await(self, function: AsyncUnary[R, S]) -&gt; FutureEither[L, S]:\n        return self.create(self.raw_map_right_await(function))\n\n    async def raw_map_left(self, function: Unary[L, M]) -&gt; Either[M, R]:\n        return (await self.awaitable).map_left(function)\n\n    async def raw_map_left_await(self, function: AsyncUnary[L, M]) -&gt; Either[M, R]:\n        return await (await self.awaitable).map_left_await(function)\n\n    async def raw_map_right(self, function: Unary[R, S]) -&gt; Either[L, S]:\n        return (await self.awaitable).map_right(function)\n\n    async def raw_map_right_await(self, function: AsyncUnary[R, S]) -&gt; Either[L, S]:\n        return await (await self.awaitable).map_right_await(function)\n\n    def map(self: FutureEither[T, T], function: Unary[T, U]) -&gt; FutureEither[U, U]:\n        return self.create(self.raw_map(function))\n\n    def map_await(self: FutureEither[T, T], function: AsyncUnary[T, U]) -&gt; FutureEither[U, U]:\n        return self.create(self.raw_map_await(function))\n\n    async def raw_map(self: FutureEither[T, T], function: Unary[T, U]) -&gt; Either[U, U]:\n        return (await self.awaitable).map(function)\n\n    async def raw_map_await(self: FutureEither[T, T], function: AsyncUnary[T, U]) -&gt; Either[U, U]:\n        return await (await self.awaitable).map_await(function)\n\n    def map_either(self, left: Unary[L, M], right: Unary[R, S]) -&gt; FutureEither[M, S]:\n        return self.create(self.raw_map_either(left, right))\n\n    def map_either_await(\n        self, left: AsyncUnary[L, M], right: AsyncUnary[R, S]\n    ) -&gt; FutureEither[M, S]:\n        return self.create(self.raw_map_either_await(left, right))\n\n    async def raw_map_either(self, left: Unary[L, M], right: Unary[R, S]) -&gt; Either[M, S]:\n        return (await self.awaitable).map_either(left, right)\n\n    async def raw_map_either_await(\n        self, left: AsyncUnary[L, M], right: AsyncUnary[R, S]\n    ) -&gt; Either[M, S]:\n        return await (await self.awaitable).map_either_await(left, right)\n\n    def either(self, left: Unary[L, T], right: Unary[R, T]) -&gt; Future[T]:\n        return super().create(self.raw_either(left, right))\n\n    def either_await(self, left: AsyncUnary[L, T], right: AsyncUnary[R, T]) -&gt; Future[T]:\n        return super().create(self.raw_either_await(left, right))\n\n    async def raw_either(self, left: Unary[L, T], right: Unary[R, T]) -&gt; T:\n        return (await self.awaitable).either(left, right)\n\n    async def raw_either_await(self, left: AsyncUnary[L, T], right: AsyncUnary[R, T]) -&gt; T:\n        return await (await self.awaitable).either_await(left, right)\n\n    def left_and_then(self, function: Unary[L, Either[M, R]]) -&gt; FutureEither[M, R]:\n        return self.create(self.raw_left_and_then(function))\n\n    def left_and_then_await(self, function: AsyncUnary[L, Either[M, R]]) -&gt; FutureEither[M, R]:\n        return self.create(self.raw_left_and_then_await(function))\n\n    def right_and_then(self, function: Unary[R, Either[L, S]]) -&gt; FutureEither[L, S]:\n        return self.create(self.raw_right_and_then(function))\n\n    def right_and_then_await(self, function: AsyncUnary[R, Either[L, S]]) -&gt; FutureEither[L, S]:\n        return self.create(self.raw_right_and_then_await(function))\n\n    async def raw_left_and_then(self, function: Unary[L, Either[M, R]]) -&gt; Either[M, R]:\n        return (await self.awaitable).left_and_then(function)\n\n    async def raw_left_and_then_await(self, function: AsyncUnary[L, Either[M, R]]) -&gt; Either[M, R]:\n        return await (await self.awaitable).left_and_then_await(function)\n\n    async def raw_right_and_then(self, function: Unary[R, Either[L, S]]) -&gt; Either[L, S]:\n        return (await self.awaitable).right_and_then(function)\n\n    async def raw_right_and_then_await(self, function: AsyncUnary[R, Either[L, S]]) -&gt; Either[L, S]:\n        return await (await self.awaitable).right_and_then_await(function)\n\n    def flatten_left(self: FutureEither[FutureEither[L, R], R]) -&gt; FutureEither[L, R]:\n        return self.left_and_then(identity)  # type: ignore[arg-type]\n\n    def flatten_right(self: FutureEither[L, FutureEither[L, R]]) -&gt; FutureEither[L, R]:\n        return self.right_and_then(identity)  # type: ignore[arg-type]\n\n    def contains_left(self, value: M) -&gt; Future[bool]:\n        return super().create(self.raw_contains_left(value))\n\n    def contains_right(self, value: S) -&gt; Future[bool]:\n        return super().create(self.raw_contains_right(value))\n\n    async def raw_contains_left(self, value: M) -&gt; bool:\n        return (await self.awaitable).contains_left(value)\n\n    async def raw_contains_right(self, value: S) -&gt; bool:\n        return (await self.awaitable).contains_right(value)\n\n    def contains(self: FutureEither[T, T], value: U) -&gt; Future[bool]:\n        return super().create(self.raw_contains(value))\n\n    async def raw_contains(self: FutureEither[T, T], value: U) -&gt; bool:\n        return (await self.awaitable).contains(value)\n\n    def into_result(self) -&gt; FutureResult[L, R]:\n        return FutureResult(self.raw_into_result())\n\n    async def raw_into_result(self) -&gt; Result[L, R]:\n        return (await self.awaitable).into_result()\n</code></pre>"},{"location":"reference/futures/either/#wraps.futures.either.wrap_future_either","title":"<code>wrap_future_either(function: EitherAsyncCallable[P, L, R]) -&gt; FutureEitherCallable[P, L, R]</code>","text":"<p>Wraps an asynchronous <code>function</code> returning <code>Either[L, R]</code> into a function returning <code>FutureEither[L, R]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>EitherAsyncCallable[P, L, R]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>FutureEitherCallable[P, L, R]</code> <p>The wrapping function.</p> Source code in <code>src/wraps/futures/either.py</code> <pre><code>def wrap_future_either(function: EitherAsyncCallable[P, L, R]) -&gt; FutureEitherCallable[P, L, R]:\n    \"\"\"Wraps an asynchronous `function` returning [`Either[L, R]`][wraps.either.Either]\n    into a function returning [`FutureEither[L, R]`][wraps.futures.either.FutureEither].\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; FutureEither[L, R]:\n        return FutureEither(function(*args, **kwargs))\n\n    return wrap\n</code></pre>"},{"location":"reference/futures/future/","title":"Future","text":"<p>Asynchronous computation using futures.</p>"},{"location":"reference/futures/future/#wraps.futures.future.future_value","title":"<code>future_value = Future.from_value</code>  <code>module-attribute</code>","text":"<p>An alias of <code>Future.from_value</code>.</p>"},{"location":"reference/futures/future/#wraps.futures.future.Future","title":"<code>Future</code>","text":"<p>               Bases: <code>Awaitable[T]</code></p> <p>Represents future computations.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>@frozen()\nclass Future(Awaitable[T]):\n    \"\"\"Represents future computations.\"\"\"\n\n    awaitable: ReAwaitable[T] = field(converter=ReAwaitable)\n\n    def __repr__(self) -&gt; str:\n        return empty_repr(self)\n\n    def __await__(self) -&gt; Generator[None, None, T]:\n        return self.awaitable.__await__()\n\n    @classmethod\n    def create(cls, awaitable: Awaitable[U]) -&gt; Future[U]:\n        \"\"\"Creates a [`Future[U]`][wraps.futures.future.Future]\n        from an [`Awaitable[U]`][typing.Awaitable].\n\n        Arguments:\n            awaitable: The awaitable to wrap.\n\n        Returns:\n            The future wrapping the given awaitable.\n        \"\"\"\n        return cls(awaitable)  # type: ignore[arg-type, return-value]\n\n    def future_map(self, function: Unary[T, U]) -&gt; Future[U]:\n        \"\"\"Maps a [`Future[T]`][wraps.futures.future.Future] to a [`Future[U]`][wraps.futures.future.Future]\n        by applying the `function` to its result.\n\n        Arguments:\n            function: The function to apply.\n\n        Returns:\n            The mapped future.\n        \"\"\"\n        return self.create(self.raw_future_map(function))\n\n    def future_map_await(self, function: AsyncUnary[T, U]) -&gt; Future[U]:\n        \"\"\"Maps a [`Future[T]`][wraps.futures.future.Future]\n        to a [`Future[U]`][wraps.futures.future.Future]\n        by applying the asynchronous `function` to its result.\n\n        Arguments:\n            function: The asynchronous function to apply.\n\n        Returns:\n            The mapped future.\n        \"\"\"\n        return self.create(self.raw_future_map_await(function))\n\n    async def raw_future_map(self, function: Unary[T, U]) -&gt; U:\n        return function(await self.awaitable)\n\n    async def raw_future_map_await(self, function: AsyncUnary[T, U]) -&gt; U:\n        return await function(await self.awaitable)\n\n    def then(self, function: FutureUnary[T, U]) -&gt; Future[U]:\n        \"\"\"Chains computation by applying the `function` to the result, returning the resulting\n        [`Future[U]`][wraps.futures.future.Future].\n\n        Arguments:\n            function: The future-returning function to apply.\n\n        Returns:\n            The resulting future.\n        \"\"\"\n        return self.create(self.raw_then(function))\n\n    async def raw_then(self, function: FutureUnary[T, U]) -&gt; U:\n        return await function(await self.awaitable).awaitable\n\n    def future_flatten(self: Future[Future[U]]) -&gt; Future[U]:\n        \"\"\"Flattens a [`Future[Future[U]]`][wraps.futures.future.Future]\n        to a [`Future[U]`][wraps.futures.future.Future].\n\n        This is identical to:\n\n        ```python\n        future.then(identity)\n        ```\n\n        Returns:\n            The flattened future.\n        \"\"\"\n        return self.then(identity)\n\n    def __aiter__(self) -&gt; AsyncIterator[T]:\n        return self.async_iter()\n\n    async def async_iter(self) -&gt; AsyncIterator[T]:\n        \"\"\"Creates an asynchronous iterator yielding the result of this\n        [`Future[T]`][wraps.futures.future.Future].\n\n        Returns:\n            An asynchronous iterator yielding the result of the future.\n        \"\"\"\n        yield await self.awaitable\n\n    @classmethod\n    def from_value(cls, value: U) -&gt; Future[U]:\n        \"\"\"Wraps the `value` of type `U` into a [`Future[U]`][wraps.futures.future.Future].\n\n        This is functionally the same as:\n\n        ```python\n        async def async_identity(value: T) -&gt; T:\n            return value\n\n        value = 42\n\n        future = Future(async_identity(value))\n        ```\n\n        Example:\n            ```python\n            value = 42\n\n            future = Future.from_value(value)\n\n            assert await future is value\n            ```\n\n        Arguments:\n            value: The value to wrap.\n\n        Returns:\n            The future wrapping the given value.\n        \"\"\"\n        return cls.create(async_identity(value))\n</code></pre>"},{"location":"reference/futures/future/#wraps.futures.future.Future.create","title":"<code>create(awaitable: Awaitable[U]) -&gt; Future[U]</code>  <code>classmethod</code>","text":"<p>Creates a <code>Future[U]</code> from an <code>Awaitable[U]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>awaitable</code> <code>Awaitable[U]</code> <p>The awaitable to wrap.</p> required <p>Returns:</p> Type Description <code>Future[U]</code> <p>The future wrapping the given awaitable.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>@classmethod\ndef create(cls, awaitable: Awaitable[U]) -&gt; Future[U]:\n    \"\"\"Creates a [`Future[U]`][wraps.futures.future.Future]\n    from an [`Awaitable[U]`][typing.Awaitable].\n\n    Arguments:\n        awaitable: The awaitable to wrap.\n\n    Returns:\n        The future wrapping the given awaitable.\n    \"\"\"\n    return cls(awaitable)  # type: ignore[arg-type, return-value]\n</code></pre>"},{"location":"reference/futures/future/#wraps.futures.future.Future.future_map","title":"<code>future_map(function: Unary[T, U]) -&gt; Future[U]</code>","text":"<p>Maps a <code>Future[T]</code> to a <code>Future[U]</code> by applying the <code>function</code> to its result.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[T, U]</code> <p>The function to apply.</p> required <p>Returns:</p> Type Description <code>Future[U]</code> <p>The mapped future.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>def future_map(self, function: Unary[T, U]) -&gt; Future[U]:\n    \"\"\"Maps a [`Future[T]`][wraps.futures.future.Future] to a [`Future[U]`][wraps.futures.future.Future]\n    by applying the `function` to its result.\n\n    Arguments:\n        function: The function to apply.\n\n    Returns:\n        The mapped future.\n    \"\"\"\n    return self.create(self.raw_future_map(function))\n</code></pre>"},{"location":"reference/futures/future/#wraps.futures.future.Future.future_map_await","title":"<code>future_map_await(function: AsyncUnary[T, U]) -&gt; Future[U]</code>","text":"<p>Maps a <code>Future[T]</code> to a <code>Future[U]</code> by applying the asynchronous <code>function</code> to its result.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncUnary[T, U]</code> <p>The asynchronous function to apply.</p> required <p>Returns:</p> Type Description <code>Future[U]</code> <p>The mapped future.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>def future_map_await(self, function: AsyncUnary[T, U]) -&gt; Future[U]:\n    \"\"\"Maps a [`Future[T]`][wraps.futures.future.Future]\n    to a [`Future[U]`][wraps.futures.future.Future]\n    by applying the asynchronous `function` to its result.\n\n    Arguments:\n        function: The asynchronous function to apply.\n\n    Returns:\n        The mapped future.\n    \"\"\"\n    return self.create(self.raw_future_map_await(function))\n</code></pre>"},{"location":"reference/futures/future/#wraps.futures.future.Future.then","title":"<code>then(function: FutureUnary[T, U]) -&gt; Future[U]</code>","text":"<p>Chains computation by applying the <code>function</code> to the result, returning the resulting <code>Future[U]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>FutureUnary[T, U]</code> <p>The future-returning function to apply.</p> required <p>Returns:</p> Type Description <code>Future[U]</code> <p>The resulting future.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>def then(self, function: FutureUnary[T, U]) -&gt; Future[U]:\n    \"\"\"Chains computation by applying the `function` to the result, returning the resulting\n    [`Future[U]`][wraps.futures.future.Future].\n\n    Arguments:\n        function: The future-returning function to apply.\n\n    Returns:\n        The resulting future.\n    \"\"\"\n    return self.create(self.raw_then(function))\n</code></pre>"},{"location":"reference/futures/future/#wraps.futures.future.Future.future_flatten","title":"<code>future_flatten() -&gt; Future[U]</code>","text":"<p>Flattens a <code>Future[Future[U]]</code> to a <code>Future[U]</code>.</p> <p>This is identical to:</p> <pre><code>future.then(identity)\n</code></pre> <p>Returns:</p> Type Description <code>Future[U]</code> <p>The flattened future.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>def future_flatten(self: Future[Future[U]]) -&gt; Future[U]:\n    \"\"\"Flattens a [`Future[Future[U]]`][wraps.futures.future.Future]\n    to a [`Future[U]`][wraps.futures.future.Future].\n\n    This is identical to:\n\n    ```python\n    future.then(identity)\n    ```\n\n    Returns:\n        The flattened future.\n    \"\"\"\n    return self.then(identity)\n</code></pre>"},{"location":"reference/futures/future/#wraps.futures.future.Future.async_iter","title":"<code>async_iter() -&gt; AsyncIterator[T]</code>  <code>async</code>","text":"<p>Creates an asynchronous iterator yielding the result of this <code>Future[T]</code>.</p> <p>Returns:</p> Type Description <code>AsyncIterator[T]</code> <p>An asynchronous iterator yielding the result of the future.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>async def async_iter(self) -&gt; AsyncIterator[T]:\n    \"\"\"Creates an asynchronous iterator yielding the result of this\n    [`Future[T]`][wraps.futures.future.Future].\n\n    Returns:\n        An asynchronous iterator yielding the result of the future.\n    \"\"\"\n    yield await self.awaitable\n</code></pre>"},{"location":"reference/futures/future/#wraps.futures.future.Future.from_value","title":"<code>from_value(value: U) -&gt; Future[U]</code>  <code>classmethod</code>","text":"<p>Wraps the <code>value</code> of type <code>U</code> into a <code>Future[U]</code>.</p> <p>This is functionally the same as:</p> <pre><code>async def async_identity(value: T) -&gt; T:\n    return value\n\nvalue = 42\n\nfuture = Future(async_identity(value))\n</code></pre> Example <pre><code>value = 42\n\nfuture = Future.from_value(value)\n\nassert await future is value\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>U</code> <p>The value to wrap.</p> required <p>Returns:</p> Type Description <code>Future[U]</code> <p>The future wrapping the given value.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>@classmethod\ndef from_value(cls, value: U) -&gt; Future[U]:\n    \"\"\"Wraps the `value` of type `U` into a [`Future[U]`][wraps.futures.future.Future].\n\n    This is functionally the same as:\n\n    ```python\n    async def async_identity(value: T) -&gt; T:\n        return value\n\n    value = 42\n\n    future = Future(async_identity(value))\n    ```\n\n    Example:\n        ```python\n        value = 42\n\n        future = Future.from_value(value)\n\n        assert await future is value\n        ```\n\n    Arguments:\n        value: The value to wrap.\n\n    Returns:\n        The future wrapping the given value.\n    \"\"\"\n    return cls.create(async_identity(value))\n</code></pre>"},{"location":"reference/futures/future/#wraps.futures.future.wrap_future","title":"<code>wrap_future(function: AsyncCallable[P, T]) -&gt; FutureCallable[P, T]</code>","text":"<p>Wraps the asynchronous <code>function</code> returning <code>T</code> into the function returning <code>Future[T]</code>.</p> Example <pre><code>@wrap_future\nasync def function() -&gt; int:\n    return 42\n\nstring = \"42\"\n\nresult = await function().future_map(str)\n\nassert result == string\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncCallable[P, T]</code> <p>The asynchronous function to wrap.</p> required <p>Returns:</p> Type Description <code>FutureCallable[P, T]</code> <p>The wrapping function.</p> Source code in <code>src/wraps/futures/future.py</code> <pre><code>def wrap_future(function: AsyncCallable[P, T]) -&gt; FutureCallable[P, T]:\n    \"\"\"Wraps the asynchronous `function` returning `T` into the function\n    returning [`Future[T]`][wraps.futures.future.Future].\n\n    Example:\n        ```python\n        @wrap_future\n        async def function() -&gt; int:\n            return 42\n\n        string = \"42\"\n\n        result = await function().future_map(str)\n\n        assert result == string\n        ```\n\n    Arguments:\n        function: The asynchronous function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; Future[T]:\n        return Future(function(*args, **kwargs))\n\n    return wrap\n</code></pre>"},{"location":"reference/futures/option/","title":"Option","text":"<p>Future optional values.</p>"},{"location":"reference/futures/option/#wraps.futures.option.future_option","title":"<code>future_option = FutureOption.from_option</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureOption.from_option</code>.</p>"},{"location":"reference/futures/option/#wraps.futures.option.future_some","title":"<code>future_some = FutureOption.from_some</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureOption.from_some</code>.</p>"},{"location":"reference/futures/option/#wraps.futures.option.future_null","title":"<code>future_null = FutureOption.from_null</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureOption.from_null</code>.</p>"},{"location":"reference/futures/option/#wraps.futures.option.FutureOption","title":"<code>FutureOption</code>","text":"<p>               Bases: <code>Future[Option[T]]</code></p> <p><code>Future[Option[T]]</code>, adapted to leverage future functionality.</p> Source code in <code>src/wraps/futures/option.py</code> <pre><code>@final\n@frozen()\nclass FutureOption(Future[Option[T]]):\n    \"\"\"[`Future[Option[T]]`][wraps.futures.future.Future],\n    adapted to leverage future functionality.\n    \"\"\"\n\n    awaitable: ReAwaitable[Option[T]] = field(converter=ReAwaitable[Option[T]])\n\n    @classmethod\n    def create(cls, awaitable: Awaitable[Option[U]]) -&gt; FutureOption[U]:  # type: ignore[override]\n        return cls(awaitable)  # type: ignore[arg-type, return-value]\n\n    @classmethod\n    def from_option(cls, option: Option[U]) -&gt; FutureOption[U]:\n        return cls.from_value(option)  # type: ignore[return-value]\n\n    @classmethod\n    def from_some(cls, value: U) -&gt; FutureOption[U]:\n        return cls.from_option(Some(value))\n\n    @classmethod\n    def from_null(cls) -&gt; FutureOption[Never]:\n        return cls.from_option(NULL)\n\n    def is_some(self) -&gt; Future[bool]:\n        return super().create(self.raw_is_some())\n\n    def is_some_and(self, predicate: Predicate[T]) -&gt; Future[bool]:\n        return super().create(self.raw_is_some_and(predicate))\n\n    def is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; Future[bool]:\n        return super().create(self.raw_is_some_and_await(predicate))\n\n    def is_null(self) -&gt; Future[bool]:\n        return super().create(self.raw_is_null())\n\n    async def raw_is_some(self) -&gt; bool:\n        return (await self.awaitable).is_some()\n\n    async def raw_is_some_and(self, predicate: Predicate[T]) -&gt; bool:\n        return (await self.awaitable).is_some_and(predicate)\n\n    async def raw_is_some_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        return await (await self.awaitable).is_some_and_await(predicate)\n\n    async def raw_is_null(self) -&gt; bool:\n        return (await self.awaitable).is_null()\n\n    def expect(self, message: str) -&gt; Future[T]:\n        return super().create(self.raw_expect(message))\n\n    async def raw_expect(self, message: str) -&gt; T:\n        return (await self.awaitable).expect(message)\n\n    def extract(self) -&gt; Future[Optional[T]]:\n        return super().create(self.raw_extract())\n\n    async def raw_extract(self) -&gt; Optional[T]:\n        return (await self.awaitable).extract()\n\n    def unwrap(self) -&gt; Future[T]:\n        return super().create(self.raw_unwrap())\n\n    def unwrap_or(self, default: T) -&gt; Future[T]:  # type: ignore[misc]\n        return super().create(self.raw_unwrap_or(default))\n\n    def unwrap_or_else(self, default: Nullary[T]) -&gt; Future[T]:\n        return super().create(self.raw_unwrap_or_else(default))\n\n    def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; Future[T]:\n        return super().create(self.raw_unwrap_or_else_await(default))\n\n    async def raw_unwrap(self) -&gt; T:\n        return (await self.awaitable).unwrap()\n\n    async def raw_unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n        return (await self.awaitable).unwrap_or(default)\n\n    async def raw_unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n        return (await self.awaitable).unwrap_or_else(default)\n\n    async def raw_unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n        return await (await self.awaitable).unwrap_or_else_await(default)\n\n    def or_raise(self, error: AnyError) -&gt; Future[T]:\n        return super().create(self.raw_or_raise(error))\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; Future[T]:\n        return super().create(self.raw_or_raise_with(error))\n\n    def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; Future[T]:\n        return super().create(self.raw_or_raise_with_await(error))\n\n    async def raw_or_raise(self, error: AnyError) -&gt; T:\n        return (await self.awaitable).or_raise(error)\n\n    async def raw_or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        return (await self.awaitable).or_raise_with(error)\n\n    async def raw_or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        return await (await self.awaitable).or_raise_with_await(error)\n\n    def inspect(self, function: Inspect[T]) -&gt; FutureOption[T]:\n        return self.create(self.raw_inspect(function))\n\n    def inspect_await(self, function: AsyncInspect[T]) -&gt; FutureOption[T]:\n        return self.create(self.raw_inspect_await(function))\n\n    async def raw_inspect(self, function: Inspect[T]) -&gt; Option[T]:\n        return (await self.awaitable).inspect(function)\n\n    async def raw_inspect_await(self, function: AsyncInspect[T]) -&gt; Option[T]:\n        return await (await self.awaitable).inspect_await(function)\n\n    def map(self, function: Unary[T, U]) -&gt; FutureOption[U]:\n        return self.create(self.raw_map(function))\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_or(default, function))\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_or_else(default, function))\n\n    def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_or_else_await(default, function))\n\n    def map_await(self, function: AsyncUnary[T, U]) -&gt; FutureOption[U]:\n        return self.create(self.raw_map_await(function))\n\n    def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_await_or(default, function))\n\n    def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_await_or_else(default, function))\n\n    def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; Future[U]:\n        return super().create(self.raw_map_await_or_else_await(default, function))\n\n    async def raw_map(self, function: Unary[T, U]) -&gt; Option[U]:\n        return (await self.awaitable).map(function)\n\n    async def raw_map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return (await self.awaitable).map_or(default, function)\n\n    async def raw_map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return (await self.awaitable).map_or_else(default, function)\n\n    async def raw_map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return await (await self.awaitable).map_or_else_await(default, function)\n\n    async def raw_map_await(self, function: AsyncUnary[T, U]) -&gt; Option[U]:\n        return await (await self.awaitable).map_await(function)\n\n    async def raw_map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return await (await self.awaitable).map_await_or(default, function)\n\n    async def raw_map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return await (await self.awaitable).map_await_or_else(default, function)\n\n    async def raw_map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await (await self.awaitable).map_await_or_else_await(default, function)\n\n    def ok_or(self, error: F) -&gt; FutureResult[T, F]:\n        return FutureResult(self.raw_ok_or(error))\n\n    def ok_or_else(self, error: Nullary[E]) -&gt; FutureResult[T, E]:\n        return FutureResult(self.raw_ok_or_else(error))\n\n    def ok_or_else_await(self, error: AsyncNullary[E]) -&gt; FutureResult[T, E]:\n        return FutureResult(self.raw_ok_or_else_await(error))\n\n    async def raw_ok_or(self, error: E) -&gt; Result[T, E]:  # type: ignore[misc]\n        return (await self.awaitable).ok_or(error)\n\n    async def raw_ok_or_else(self, error: Nullary[E]) -&gt; Result[T, E]:\n        return (await self.awaitable).ok_or_else(error)\n\n    async def raw_ok_or_else_await(self, error: AsyncNullary[E]) -&gt; Result[T, E]:\n        return await (await self.awaitable).ok_or_else_await(error)\n\n    def and_then(self, function: Unary[T, Option[U]]) -&gt; FutureOption[U]:\n        return self.create(self.raw_and_then(function))\n\n    def and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; FutureOption[U]:\n        return self.create(self.raw_and_then_await(function))\n\n    def or_else(self, function: Nullary[Option[T]]) -&gt; FutureOption[T]:\n        return self.create(self.raw_or_else(function))\n\n    def or_else_await(self, function: AsyncNullary[Option[T]]) -&gt; FutureOption[T]:\n        return self.create(self.raw_or_else_await(function))\n\n    async def raw_and_then(self, function: Unary[T, Option[U]]) -&gt; Option[U]:\n        return (await self.awaitable).and_then(function)\n\n    async def raw_and_then_await(self, function: AsyncUnary[T, Option[U]]) -&gt; Option[U]:\n        return await (await self.awaitable).and_then_await(function)\n\n    async def raw_or_else(self, function: Nullary[Option[T]]) -&gt; Option[T]:\n        return (await self.awaitable).or_else(function)\n\n    async def raw_or_else_await(self, function: AsyncNullary[Option[T]]) -&gt; Option[T]:\n        return await (await self.awaitable).or_else_await(function)\n\n    def filter(self, predicate: Predicate[T]) -&gt; FutureOption[T]:\n        return self.create(self.raw_filter(predicate))\n\n    def filter_await(self, predicate: AsyncPredicate[T]) -&gt; FutureOption[T]:\n        return self.create(self.raw_filter_await(predicate))\n\n    async def raw_filter(self, predicate: Predicate[T]) -&gt; Option[T]:\n        return (await self.awaitable).filter(predicate)\n\n    async def raw_filter_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n        return await (await self.awaitable).filter_await(predicate)\n\n    def xor(self, option: FutureOption[T]) -&gt; FutureOption[T]:\n        return self.create(self.raw_xor(option))\n\n    async def raw_xor(self, option: FutureOption[T]) -&gt; Option[T]:\n        return (await self.awaitable).xor(await option.awaitable)\n\n    def zip(self, option: FutureOption[U]) -&gt; FutureOption[Tuple[T, U]]:\n        return self.create(self.raw_zip(option))\n\n    def zip_with(self, option: FutureOption[U], function: Binary[T, U, V]) -&gt; FutureOption[V]:\n        return self.create(self.raw_zip_with(option, function))\n\n    def zip_with_await(\n        self, option: FutureOption[U], function: AsyncBinary[T, U, V]\n    ) -&gt; FutureOption[V]:\n        return self.create(self.raw_zip_with_await(option, function))\n\n    async def raw_zip(self, option: FutureOption[U]) -&gt; Option[Tuple[T, U]]:\n        return (await self.awaitable).zip(await option.awaitable)\n\n    async def raw_zip_with(self, option: FutureOption[U], function: Binary[T, U, V]) -&gt; Option[V]:\n        return (await self.awaitable).zip_with(await option.awaitable, function)\n\n    async def raw_zip_with_await(\n        self, option: FutureOption[U], function: AsyncBinary[T, U, V]\n    ) -&gt; Option[V]:\n        return await (await self.awaitable).zip_with_await(await option.awaitable, function)\n\n    def unzip(self: FutureOption[Tuple[U, V]]) -&gt; Tuple[FutureOption[U], FutureOption[V]]:\n        async def unzipper() -&gt; Tuple[Option[U], Option[V]]:\n            return (await self.awaitable).unzip()\n\n        async def former() -&gt; Option[U]:\n            u, _ = await unzipper()\n\n            return u\n\n        async def latter() -&gt; Option[V]:\n            _, v = await unzipper()\n\n            return v\n\n        return (self.create(former()), self.create(latter()))\n\n    def flatten(self: FutureOption[FutureOption[U]]) -&gt; FutureOption[U]:\n        return self.create(self.raw_flatten())\n\n    async def raw_flatten(self: FutureOption[FutureOption[U]]) -&gt; Option[U]:\n        return await self.and_then_await(identity)\n\n    def contains(self, value: U) -&gt; Future[bool]:\n        return super().create(self.raw_contains(value))\n\n    async def raw_contains(self, value: U) -&gt; bool:\n        return (await self.awaitable).contains(value)\n\n    def early(self) -&gt; Future[T]:\n        return super().create(self.raw_early())\n\n    async def raw_early(self) -&gt; T:\n        return (await self.awaitable).early()\n</code></pre>"},{"location":"reference/futures/option/#wraps.futures.option.wrap_future_option","title":"<code>wrap_future_option(function: OptionAsyncCallable[P, T]) -&gt; FutureOptionCallable[P, T]</code>","text":"<p>Wraps an asynchronous <code>function</code> returning <code>Option[T]</code> into a function returning <code>FutureOption[T]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>OptionAsyncCallable[P, T]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>FutureOptionCallable[P, T]</code> <p>The wrapping function.</p> Source code in <code>src/wraps/futures/option.py</code> <pre><code>def wrap_future_option(function: OptionAsyncCallable[P, T]) -&gt; FutureOptionCallable[P, T]:\n    \"\"\"Wraps an asynchronous `function` returning [`Option[T]`][wraps.option.Option] into a function\n    returning [`FutureOption[T]`][wraps.futures.option.FutureOption].\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; FutureOption[T]:\n        return FutureOption(function(*args, **kwargs))\n\n    return wrap\n</code></pre>"},{"location":"reference/futures/reawaitable/","title":"ReAwaitable","text":""},{"location":"reference/futures/reawaitable/#wraps.futures.reawaitable.ReAwaitable","title":"<code>ReAwaitable</code>","text":"<p>               Bases: <code>Awaitable[T]</code></p> <p>Wraps the given awaitable to allow re-awaiting.</p> Source code in <code>src/wraps/futures/reawaitable.py</code> <pre><code>@final\n@define()\nclass ReAwaitable(Awaitable[T]):\n    \"\"\"Wraps the given awaitable to allow re-awaiting.\"\"\"\n\n    _awaitable: Awaitable[T] = field()\n    _result: Option[T] = field(default=NULL, init=False)\n\n    def __repr__(self) -&gt; str:\n        return empty_repr(self)\n\n    def __await__(self) -&gt; Generator[None, None, T]:\n        return self.execute().__await__()\n\n    async def execute(self) -&gt; T:\n        \"\"\"Returns the cached result or executes the contained awaitable and caches its result.\n\n        Returns:\n            The execution result.\n        \"\"\"\n        result = self._result\n\n        if result.is_null():\n            value = await self._awaitable\n\n            self._result = Some(value)\n\n            return value\n\n        return result.unwrap()\n\n    @property\n    def result(self) -&gt; Option[T]:\n        \"\"\"The cached result.\"\"\"\n        return self._result\n</code></pre>"},{"location":"reference/futures/reawaitable/#wraps.futures.reawaitable.ReAwaitable.result","title":"<code>result: Option[T]</code>  <code>property</code>","text":"<p>The cached result.</p>"},{"location":"reference/futures/reawaitable/#wraps.futures.reawaitable.ReAwaitable.execute","title":"<code>execute() -&gt; T</code>  <code>async</code>","text":"<p>Returns the cached result or executes the contained awaitable and caches its result.</p> <p>Returns:</p> Type Description <code>T</code> <p>The execution result.</p> Source code in <code>src/wraps/futures/reawaitable.py</code> <pre><code>async def execute(self) -&gt; T:\n    \"\"\"Returns the cached result or executes the contained awaitable and caches its result.\n\n    Returns:\n        The execution result.\n    \"\"\"\n    result = self._result\n\n    if result.is_null():\n        value = await self._awaitable\n\n        self._result = Some(value)\n\n        return value\n\n    return result.unwrap()\n</code></pre>"},{"location":"reference/futures/reawaitable/#wraps.futures.reawaitable.wrap_reawaitable","title":"<code>wrap_reawaitable(function: AsyncCallable[P, T]) -&gt; ReAsyncCallable[P, T]</code>","text":"<p>Wraps the asynchronous <code>function</code> to allow re-awaiting.</p> Example <p>Wrap the <code>function</code> to make it re-awaitable:</p> <pre><code>@wrap_reawaitable\nasync def function() -&gt; int:\n    return 42\n</code></pre> <p>Now the <code>function</code> can be re-awaited:</p> <pre><code>&gt;&gt;&gt; awaitable = function()\n&gt;&gt;&gt; await awaitable\n42\n&gt;&gt;&gt; await awaitable\n42\n&gt;&gt;&gt; await awaitable\n42\n&gt;&gt;&gt; # ad infinitum...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>AsyncCallable[P, T]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>ReAsyncCallable[P, T]</code> <p>The wrapping function.</p> Source code in <code>src/wraps/futures/reawaitable.py</code> <pre><code>def wrap_reawaitable(function: AsyncCallable[P, T]) -&gt; ReAsyncCallable[P, T]:\n    \"\"\"Wraps the asynchronous `function` to allow re-awaiting.\n\n    Example:\n        Wrap the `function` to make it re-awaitable:\n\n        ```python\n        @wrap_reawaitable\n        async def function() -&gt; int:\n            return 42\n        ```\n\n        Now the `function` can be re-awaited:\n\n        ```python\n        &gt;&gt;&gt; awaitable = function()\n        &gt;&gt;&gt; await awaitable\n        42\n        &gt;&gt;&gt; await awaitable\n        42\n        &gt;&gt;&gt; await awaitable\n        42\n        &gt;&gt;&gt; # ad infinitum...\n        ```\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; ReAwaitable[T]:\n        return ReAwaitable(function(*args, **kwargs))\n\n    return wrap\n</code></pre>"},{"location":"reference/futures/result/","title":"Result","text":"<p>Future error handling.</p>"},{"location":"reference/futures/result/#wraps.futures.result.future_result","title":"<code>future_result = FutureResult.from_result</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureResult.from_result</code>.</p>"},{"location":"reference/futures/result/#wraps.futures.result.future_ok","title":"<code>future_ok = FutureResult.from_ok</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureResult.from_ok</code>.</p>"},{"location":"reference/futures/result/#wraps.futures.result.future_err","title":"<code>future_err = FutureResult.from_err</code>  <code>module-attribute</code>","text":"<p>An alias of <code>FutureResult.from_err</code>.</p>"},{"location":"reference/futures/result/#wraps.futures.result.FutureResult","title":"<code>FutureResult</code>","text":"<p>               Bases: <code>Future[Result[T, E]]</code></p> <p><code>Future[Result[T, E]]</code>, adapted to leverage future functionality.</p> Source code in <code>src/wraps/futures/result.py</code> <pre><code>@final\n@frozen()\nclass FutureResult(Future[Result[T, E]]):\n    \"\"\"[`Future[Result[T, E]]`][wraps.futures.future.Future],\n    adapted to leverage future functionality.\n    \"\"\"\n\n    awaitable: ReAwaitable[Result[T, E]] = field(converter=ReAwaitable[Result[T, E]])\n\n    @classmethod\n    def create(cls, awaitable: Awaitable[Result[U, F]]) -&gt; FutureResult[U, F]:  # type: ignore[override]\n        return cls(awaitable)  # type: ignore[arg-type, return-value]\n\n    @classmethod\n    def from_result(cls, result: Result[U, F]) -&gt; FutureResult[U, F]:\n        return cls.from_value(result)  # type: ignore[return-value]\n\n    @classmethod\n    def from_ok(cls, value: U) -&gt; FutureResult[U, Never]:\n        return cls.from_result(Ok(value))\n\n    @classmethod\n    def from_err(cls, error: F) -&gt; FutureResult[Never, F]:\n        return cls.from_result(Err(error))\n\n    def is_ok(self) -&gt; Future[bool]:\n        return super().create(self.raw_is_ok())\n\n    def is_ok_and(self, predicate: Predicate[T]) -&gt; Future[bool]:\n        return super().create(self.raw_is_ok_and(predicate))\n\n    def is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; Future[bool]:\n        return super().create(self.raw_is_ok_and_await(predicate))\n\n    async def raw_is_ok(self) -&gt; bool:\n        return (await self.awaitable).is_ok()\n\n    async def raw_is_ok_and(self, predicate: Predicate[T]) -&gt; bool:\n        return (await self.awaitable).is_ok_and(predicate)\n\n    async def raw_is_ok_and_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        return await (await self.awaitable).is_ok_and_await(predicate)\n\n    def is_err(self) -&gt; Future[bool]:\n        return super().create(self.raw_is_err())\n\n    def is_err_and(self, predicate: Predicate[E]) -&gt; Future[bool]:\n        return super().create(self.raw_is_err_and(predicate))\n\n    def is_err_and_await(self, predicate: AsyncPredicate[E]) -&gt; Future[bool]:\n        return super().create(self.raw_is_err_and_await(predicate))\n\n    async def raw_is_err(self) -&gt; bool:\n        return (await self.awaitable).is_err()\n\n    async def raw_is_err_and(self, predicate: Predicate[E]) -&gt; bool:\n        return (await self.awaitable).is_err_and(predicate)\n\n    async def raw_is_err_and_await(self, predicate: AsyncPredicate[E]) -&gt; bool:\n        return await (await self.awaitable).is_err_and_await(predicate)\n\n    def expect(self, message: str) -&gt; Future[T]:\n        return super().create(self.raw_expect(message))\n\n    def expect_err(self, message: str) -&gt; Future[E]:\n        return super().create(self.raw_expect_err(message))\n\n    async def raw_expect(self, message: str) -&gt; T:\n        return (await self.awaitable).expect(message)\n\n    async def raw_expect_err(self, message: str) -&gt; E:\n        return (await self.awaitable).expect_err(message)\n\n    def unwrap(self) -&gt; Future[T]:\n        return super().create(self.raw_unwrap())\n\n    def unwrap_or(self, default: T) -&gt; Future[T]:  # type: ignore[misc]\n        return super().create(self.raw_unwrap_or(default))\n\n    def unwrap_or_else(self, default: Nullary[T]) -&gt; Future[T]:\n        return super().create(self.raw_unwrap_or_else(default))\n\n    def unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; Future[T]:\n        return super().create(self.raw_unwrap_or_else_await(default))\n\n    async def raw_unwrap(self) -&gt; T:\n        return (await self.awaitable).unwrap()\n\n    async def raw_unwrap_or(self, default: T) -&gt; T:  # type: ignore[misc]\n        return (await self.awaitable).unwrap_or(default)\n\n    async def raw_unwrap_or_else(self, default: Nullary[T]) -&gt; T:\n        return (await self.awaitable).unwrap_or_else(default)\n\n    async def raw_unwrap_or_else_await(self, default: AsyncNullary[T]) -&gt; T:\n        return await (await self.awaitable).unwrap_or_else_await(default)\n\n    def or_raise(self, error: AnyError) -&gt; Future[T]:\n        return super().create(self.raw_or_raise(error))\n\n    def or_raise_with(self, error: Nullary[AnyError]) -&gt; Future[T]:\n        return super().create(self.raw_or_raise_with(error))\n\n    def or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; Future[T]:\n        return super().create(self.raw_or_raise_with_await(error))\n\n    async def raw_or_raise(self, error: AnyError) -&gt; T:\n        return (await self.awaitable).or_raise(error)\n\n    async def raw_or_raise_with(self, error: Nullary[AnyError]) -&gt; T:\n        return (await self.awaitable).or_raise_with(error)\n\n    async def raw_or_raise_with_await(self, error: AsyncNullary[AnyError]) -&gt; T:\n        return await (await self.awaitable).or_raise_with_await(error)\n\n    def or_raise_from(self, error: Unary[E, AnyError]) -&gt; Future[T]:\n        return super().create(self.raw_or_raise_from(error))\n\n    def or_raise_from_await(self, error: AsyncUnary[E, AnyError]) -&gt; Future[T]:\n        return super().create(self.raw_or_raise_from_await(error))\n\n    async def raw_or_raise_from(self, error: Unary[E, AnyError]) -&gt; T:\n        return (await self.awaitable).or_raise_from(error)\n\n    async def raw_or_raise_from_await(self, error: AsyncUnary[E, AnyError]) -&gt; T:\n        return await (await self.awaitable).or_raise_from_await(error)\n\n    def unwrap_err(self) -&gt; Future[E]:\n        return super().create(self.raw_unwrap_err())\n\n    def unwrap_err_or(self, default: E) -&gt; Future[E]:  # type: ignore[misc]\n        return super().create(self.raw_unwrap_err_or(default))\n\n    def unwrap_err_or_else(self, default: Nullary[E]) -&gt; Future[E]:\n        return super().create(self.raw_unwrap_err_or_else(default))\n\n    def unwrap_err_or_else_await(self, default: AsyncNullary[E]) -&gt; Future[E]:\n        return super().create(self.raw_unwrap_err_or_else_await(default))\n\n    async def raw_unwrap_err(self) -&gt; E:\n        return (await self.awaitable).unwrap_err()\n\n    async def raw_unwrap_err_or(self, default: E) -&gt; E:  # type: ignore[misc]\n        return (await self.awaitable).unwrap_err_or(default)\n\n    async def raw_unwrap_err_or_else(self, default: Nullary[E]) -&gt; E:\n        return (await self.awaitable).unwrap_err_or_else(default)\n\n    async def raw_unwrap_err_or_else_await(self, default: AsyncNullary[E]) -&gt; E:\n        return await (await self.awaitable).unwrap_err_or_else_await(default)\n\n    def raising(self: FutureResult[T, AnyError]) -&gt; Future[T]:\n        return super().create(self.raw_raising())\n\n    async def raw_raising(self: FutureResult[T, AnyError]) -&gt; T:\n        return (await self.awaitable).raising()\n\n    def ok(self) -&gt; FutureOption[T]:\n        return FutureOption(self.raw_ok())\n\n    def err(self) -&gt; FutureOption[E]:\n        return FutureOption(self.raw_err())\n\n    async def raw_ok(self) -&gt; Option[T]:\n        return (await self.awaitable).ok()\n\n    async def raw_err(self) -&gt; Option[E]:\n        return (await self.awaitable).err()\n\n    def inspect(self, function: Inspect[T]) -&gt; FutureResult[T, E]:\n        return self.create(self.raw_inspect(function))\n\n    def inspect_err(self, function: Inspect[E]) -&gt; FutureResult[T, E]:\n        return self.create(self.raw_inspect_err(function))\n\n    def inspect_await(self, function: AsyncInspect[T]) -&gt; FutureResult[T, E]:\n        return self.create(self.raw_inspect_await(function))\n\n    def inspect_err_await(self, function: AsyncInspect[E]) -&gt; FutureResult[T, E]:\n        return self.create(self.raw_inspect_err_await(function))\n\n    async def raw_inspect(self, function: Inspect[T]) -&gt; Result[T, E]:\n        return (await self.awaitable).inspect(function)\n\n    async def raw_inspect_err(self, function: Inspect[E]) -&gt; Result[T, E]:\n        return (await self.awaitable).inspect_err(function)\n\n    async def raw_inspect_await(self, function: AsyncInspect[T]) -&gt; Result[T, E]:\n        return await (await self.awaitable).inspect_await(function)\n\n    async def raw_inspect_err_await(self, function: AsyncInspect[E]) -&gt; Result[T, E]:\n        return await (await self.awaitable).inspect_err_await(function)\n\n    def map(self, function: Unary[T, U]) -&gt; FutureResult[U, E]:\n        return self.create(self.raw_map(function))\n\n    def map_or(self, default: U, function: Unary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_or(default, function))\n\n    def map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_or_else(default, function))\n\n    def map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_or_else_await(default, function))\n\n    def map_err(self, function: Unary[E, F]) -&gt; FutureResult[T, F]:\n        return self.create(self.raw_map_err(function))\n\n    def map_err_or(self, default: F, function: Unary[E, F]) -&gt; Future[F]:\n        return super().create(self.raw_map_err_or(default, function))\n\n    def map_err_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; Future[F]:\n        return super().create(self.raw_map_err_or_else(default, function))\n\n    def map_err_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; Future[F]:\n        return super().create(self.raw_map_err_or_else_await(default, function))\n\n    async def raw_map(self, function: Unary[T, U]) -&gt; Result[U, E]:\n        return (await self.awaitable).map(function)\n\n    async def raw_map_or(self, default: U, function: Unary[T, U]) -&gt; U:\n        return (await self.awaitable).map_or(default, function)\n\n    async def raw_map_or_else(self, default: Nullary[U], function: Unary[T, U]) -&gt; U:\n        return (await self.awaitable).map_or_else(default, function)\n\n    async def raw_map_or_else_await(self, default: AsyncNullary[U], function: Unary[T, U]) -&gt; U:\n        return await (await self.awaitable).map_or_else_await(default, function)\n\n    async def raw_map_err(self, function: Unary[E, F]) -&gt; Result[T, F]:\n        return (await self.awaitable).map_err(function)\n\n    async def raw_map_err_or(self, default: F, function: Unary[E, F]) -&gt; F:\n        return (await self.awaitable).map_err_or(default, function)\n\n    async def raw_map_err_or_else(self, default: Nullary[F], function: Unary[E, F]) -&gt; F:\n        return (await self.awaitable).map_err_or_else(default, function)\n\n    async def raw_map_err_or_else_await(self, default: AsyncNullary[F], function: Unary[E, F]) -&gt; F:\n        return await (await self.awaitable).map_err_or_else_await(default, function)\n\n    def map_await(self, function: AsyncUnary[T, U]) -&gt; FutureResult[U, E]:\n        return self.create(self.raw_map_await(function))\n\n    def map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_await_or(default, function))\n\n    def map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; Future[U]:\n        return super().create(self.raw_map_await_or_else(default, function))\n\n    def map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; Future[U]:\n        return super().create(self.raw_map_await_or_else_await(default, function))\n\n    def map_err_await(self, function: AsyncUnary[E, F]) -&gt; FutureResult[T, F]:\n        return self.create(self.raw_map_err_await(function))\n\n    def map_err_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; Future[F]:\n        return super().create(self.raw_map_err_await_or(default, function))\n\n    def map_err_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; Future[F]:\n        return super().create(self.raw_map_err_await_or_else(default, function))\n\n    def map_err_await_or_else_await(\n        self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n    ) -&gt; Future[F]:\n        return super().create(self.raw_map_err_await_or_else_await(default, function))\n\n    async def raw_map_await(self, function: AsyncUnary[T, U]) -&gt; Result[U, E]:\n        return await (await self.awaitable).map_await(function)\n\n    async def raw_map_await_or(self, default: U, function: AsyncUnary[T, U]) -&gt; U:\n        return await (await self.awaitable).map_await_or(default, function)\n\n    async def raw_map_await_or_else(self, default: Nullary[U], function: AsyncUnary[T, U]) -&gt; U:\n        return await (await self.awaitable).map_await_or_else(default, function)\n\n    async def raw_map_await_or_else_await(\n        self, default: AsyncNullary[U], function: AsyncUnary[T, U]\n    ) -&gt; U:\n        return await (await self.awaitable).map_await_or_else_await(default, function)\n\n    async def raw_map_err_await(self, function: AsyncUnary[E, F]) -&gt; Result[T, F]:\n        return await (await self.awaitable).map_err_await(function)\n\n    async def raw_map_err_await_or(self, default: F, function: AsyncUnary[E, F]) -&gt; F:\n        return await (await self.awaitable).map_err_await_or(default, function)\n\n    async def raw_map_err_await_or_else(self, default: Nullary[F], function: AsyncUnary[E, F]) -&gt; F:\n        return await (await self.awaitable).map_err_await_or_else(default, function)\n\n    async def raw_map_err_await_or_else_await(\n        self, default: AsyncNullary[F], function: AsyncUnary[E, F]\n    ) -&gt; F:\n        return await (await self.awaitable).map_err_await_or_else_await(default, function)\n\n    def and_then(self, function: Unary[T, Result[U, E]]) -&gt; FutureResult[U, E]:\n        return self.create(self.raw_and_then(function))\n\n    def and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; FutureResult[U, E]:\n        return self.create(self.raw_and_then_await(function))\n\n    def or_else(self, function: Unary[E, Result[T, F]]) -&gt; FutureResult[T, F]:\n        return self.create(self.raw_or_else(function))\n\n    def or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; FutureResult[T, F]:\n        return self.create(self.raw_or_else_await(function))\n\n    async def raw_and_then(self, function: Unary[T, Result[U, E]]) -&gt; Result[U, E]:\n        return (await self.awaitable).and_then(function)\n\n    async def raw_and_then_await(self, function: AsyncUnary[T, Result[U, E]]) -&gt; Result[U, E]:\n        return await (await self.awaitable).and_then_await(function)\n\n    async def raw_or_else(self, function: Unary[E, Result[T, F]]) -&gt; Result[T, F]:\n        return (await self.awaitable).or_else(function)\n\n    async def raw_or_else_await(self, function: AsyncUnary[E, Result[T, F]]) -&gt; Result[T, F]:\n        return await (await self.awaitable).or_else_await(function)\n\n    def try_flatten(self: FutureResult[FutureResult[T, E], E]) -&gt; FutureResult[T, E]:\n        return self.and_then_await(identity)\n\n    def try_flatten_err(self: FutureResult[T, FutureResult[T, E]]) -&gt; FutureResult[T, E]:\n        return self.or_else_await(identity)\n\n    def contains(self, value: U) -&gt; Future[bool]:\n        return super().create(self.raw_contains(value))\n\n    async def raw_contains(self, value: U) -&gt; bool:\n        return (await self.awaitable).contains(value)\n\n    def contains_err(self, error: F) -&gt; Future[bool]:\n        return super().create(self.raw_contains_err(error))\n\n    async def raw_contains_err(self, error: F) -&gt; bool:\n        return (await self.awaitable).contains_err(error)\n\n    def flip(self) -&gt; FutureResult[E, T]:\n        return self.create(self.raw_flip())\n\n    async def raw_flip(self) -&gt; Result[E, T]:\n        return (await self.awaitable).flip()\n\n    def into_ok_or_err(self: FutureResult[T, T]) -&gt; Future[T]:\n        return super().create(self.raw_into_ok_or_err())\n\n    async def raw_into_ok_or_err(self: FutureResult[T, T]) -&gt; T:\n        return (await self.awaitable).into_ok_or_err()\n\n    def into_either(self) -&gt; FutureEither[T, E]:\n        return FutureEither.create(self.raw_into_either())\n\n    async def raw_into_either(self) -&gt; Either[T, E]:\n        return (await self.awaitable).into_either()\n\n    def early(self) -&gt; Future[T]:\n        return super().create(self.raw_early())\n\n    async def raw_early(self) -&gt; T:\n        return (await self.awaitable).early()\n\n    def into_future(self) -&gt; Future[Result[T, E]]:\n        return super().create(self.awaitable)\n</code></pre>"},{"location":"reference/futures/result/#wraps.futures.result.wrap_future_result","title":"<code>wrap_future_result(function: ResultAsyncCallable[P, T, E]) -&gt; FutureResultCallable[P, T, E]</code>","text":"<p>Wraps an asynchronous <code>function</code> returning <code>Result[T, E]</code> into a function returning <code>FutureResult[T, E]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>ResultAsyncCallable[P, T, E]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>FutureResultCallable[P, T, E]</code> <p>The wrapping function.</p> Source code in <code>src/wraps/futures/result.py</code> <pre><code>def wrap_future_result(function: ResultAsyncCallable[P, T, E]) -&gt; FutureResultCallable[P, T, E]:\n    \"\"\"Wraps an asynchronous `function` returning [`Result[T, E]`][wraps.result.Result]\n    into a function returning [`FutureResult[T, E]`][wraps.futures.result.FutureResult].\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: P.args, **kwargs: P.kwargs) -&gt; FutureResult[T, E]:\n        return FutureResult(function(*args, **kwargs))\n\n    return wrap\n</code></pre>"},{"location":"reference/futures/typing/","title":"Typing","text":""},{"location":"reference/futures/typing/#wraps.futures.typing.ReAsyncCallable","title":"<code>ReAsyncCallable = Callable[P, ReAwaitable[R]]</code>  <code>module-attribute</code>","text":"<p>Represents re-awaitable callables <code>(**P) -&gt; ReAwaitable[R]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureCallable","title":"<code>FutureCallable = Callable[P, Future[R]]</code>  <code>module-attribute</code>","text":"<p>Represents future callables <code>(**P) -&gt; Future[R]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureNullary","title":"<code>FutureNullary = Nullary[Future[R]]</code>  <code>module-attribute</code>","text":"<p>Represents future nullary functions <code>() -&gt; Future[R]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureUnary","title":"<code>FutureUnary = Unary[T, Future[R]]</code>  <code>module-attribute</code>","text":"<p>Represents future unary functions <code>(T) -&gt; Future[R]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureBinary","title":"<code>FutureBinary = Binary[T, U, Future[R]]</code>  <code>module-attribute</code>","text":"<p>Represents future binary functions <code>(T, U) -&gt; Future[R]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureTernary","title":"<code>FutureTernary = Ternary[T, U, V, Future[R]]</code>  <code>module-attribute</code>","text":"<p>Represents future ternary functions <code>(T, U, V) -&gt; Future[R]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureQuaternary","title":"<code>FutureQuaternary = Quaternary[T, U, V, W, Future[R]]</code>  <code>module-attribute</code>","text":"<p>Represents future quaternary functions <code>(T, U, V, W) -&gt; Future[R]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureOptionCallable","title":"<code>FutureOptionCallable = Callable[P, FutureOption[T]]</code>  <code>module-attribute</code>","text":"<p>Represents future option callables <code>(**P) -&gt; FutureOption[T]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureResultCallable","title":"<code>FutureResultCallable = Callable[P, FutureResult[T, E]]</code>  <code>module-attribute</code>","text":"<p>Represents future result callables <code>(**P) -&gt; FutureResult[T, E]</code>.</p>"},{"location":"reference/futures/typing/#wraps.futures.typing.FutureEitherCallable","title":"<code>FutureEitherCallable = Callable[P, FutureEither[L, R]]</code>  <code>module-attribute</code>","text":"<p>Represents future either callables <code>(**P) -&gt; FutureEither[L, R]</code>.</p>"},{"location":"reference/parse/format/","title":"Format","text":""},{"location":"reference/parse/format/#wraps.parse.format.ToString","title":"<code>ToString</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Represents types that can be converted to strings.</p> Source code in <code>src/wraps/parse/format.py</code> <pre><code>@runtime_checkable\nclass ToString(Protocol):\n    \"\"\"Represents types that can be converted to strings.\"\"\"\n\n    @required\n    def to_string(self) -&gt; str:\n        \"\"\"Converts `self` to its string representation.\n\n        Returns:\n            The string representation of `self`.\n        \"\"\"\n        ...\n\n    def to_short_string(self) -&gt; str:\n        \"\"\"Converts `self` to its (short) string representation.\n\n        The default implementation simply calls [`to_string`][wraps.parse.format.ToString.to_string].\n\n        Returns:\n            The (short) string representation of `self`.\n        \"\"\"\n        return self.to_string()\n\n    def __str__(self) -&gt; str:\n        \"\"\"Calls [`to_string`][wraps.parse.format.ToString.to_string] and returns the result.\n\n        Returns:\n            The string representation of `self`.\n        \"\"\"\n        return self.to_string()\n</code></pre>"},{"location":"reference/parse/format/#wraps.parse.format.ToString.to_string","title":"<code>to_string() -&gt; str</code>","text":"<p>Converts <code>self</code> to its string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of <code>self</code>.</p> Source code in <code>src/wraps/parse/format.py</code> <pre><code>@required\ndef to_string(self) -&gt; str:\n    \"\"\"Converts `self` to its string representation.\n\n    Returns:\n        The string representation of `self`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/parse/format/#wraps.parse.format.ToString.to_short_string","title":"<code>to_short_string() -&gt; str</code>","text":"<p>Converts <code>self</code> to its (short) string representation.</p> <p>The default implementation simply calls <code>to_string</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>The (short) string representation of <code>self</code>.</p> Source code in <code>src/wraps/parse/format.py</code> <pre><code>def to_short_string(self) -&gt; str:\n    \"\"\"Converts `self` to its (short) string representation.\n\n    The default implementation simply calls [`to_string`][wraps.parse.format.ToString.to_string].\n\n    Returns:\n        The (short) string representation of `self`.\n    \"\"\"\n    return self.to_string()\n</code></pre>"},{"location":"reference/parse/format/#wraps.parse.format.ToString.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Calls <code>to_string</code> and returns the result.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of <code>self</code>.</p> Source code in <code>src/wraps/parse/format.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Calls [`to_string`][wraps.parse.format.ToString.to_string] and returns the result.\n\n    Returns:\n        The string representation of `self`.\n    \"\"\"\n    return self.to_string()\n</code></pre>"},{"location":"reference/parse/format/#wraps.parse.format.to_string","title":"<code>to_string(value: ToString) -&gt; str</code>","text":"<p>Calls <code>to_string</code> method on the given value and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ToString</code> <p>The value to convert to string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string representation of <code>value</code>.</p> Source code in <code>src/wraps/parse/format.py</code> <pre><code>def to_string(value: ToString) -&gt; str:\n    \"\"\"Calls [`to_string`][wraps.parse.format.ToString.to_string] method on the given value\n    and returns the result.\n\n    Arguments:\n        value: The value to convert to string.\n\n    Returns:\n        The string representation of `value`.\n    \"\"\"\n    return value.to_string()\n</code></pre>"},{"location":"reference/parse/format/#wraps.parse.format.to_short_string","title":"<code>to_short_string(value: ToString) -&gt; str</code>","text":"<p>Calls <code>to_short_string</code> method on the given value and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ToString</code> <p>The value to convert to string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The (short) string representation of <code>value</code>.</p> Source code in <code>src/wraps/parse/format.py</code> <pre><code>def to_short_string(value: ToString) -&gt; str:\n    \"\"\"Calls [`to_short_string`][wraps.parse.format.ToString.to_short_string] method\n    on the given value and returns the result.\n\n    Arguments:\n        value: The value to convert to string.\n\n    Returns:\n        The (short) string representation of `value`.\n    \"\"\"\n    return value.to_short_string()\n</code></pre>"},{"location":"reference/parse/normal/","title":"Normal","text":""},{"location":"reference/parse/normal/#wraps.parse.normal.ParseError","title":"<code>ParseError</code>","text":"<p>               Bases: <code>ValueError</code>, <code>Generic[T, E]</code></p> <p>Represents parse errors.</p> Source code in <code>src/wraps/parse/normal.py</code> <pre><code>class ParseError(ValueError, Generic[T, E]):\n    \"\"\"Represents parse errors.\"\"\"\n\n    def __init__(self, string: str, type: Type[T], error: E) -&gt; None:\n        self._string = string\n        self._type = type\n        self._error = error\n\n        super().__init__(parse_failed(string, get_name(type), error))  # type: ignore[arg-type]\n\n    @property\n    def string(self) -&gt; str:\n        \"\"\"The string that could not be parsed.\"\"\"\n        return self._string\n\n    @property\n    def type(self) -&gt; Type[T]:\n        \"\"\"The type parsing into which failed.\"\"\"\n        return self._type\n\n    @property\n    def error(self) -&gt; E:\n        \"\"\"The error returned by the\n        [`from_string`][wraps.parse.normal.FromString.from_string] function.\n        \"\"\"\n        return self._error\n</code></pre>"},{"location":"reference/parse/normal/#wraps.parse.normal.ParseError.string","title":"<code>string: str</code>  <code>property</code>","text":"<p>The string that could not be parsed.</p>"},{"location":"reference/parse/normal/#wraps.parse.normal.ParseError.type","title":"<code>type: Type[T]</code>  <code>property</code>","text":"<p>The type parsing into which failed.</p>"},{"location":"reference/parse/normal/#wraps.parse.normal.ParseError.error","title":"<code>error: E</code>  <code>property</code>","text":"<p>The error returned by the <code>from_string</code> function.</p>"},{"location":"reference/parse/normal/#wraps.parse.normal.FromString","title":"<code>FromString</code>","text":"<p>               Bases: <code>Protocol[E]</code></p> <p>Represents types that can be parsed from strings.</p> Source code in <code>src/wraps/parse/normal.py</code> <pre><code>@runtime_checkable\nclass FromString(Protocol[E]):\n    \"\"\"Represents types that can be parsed from strings.\"\"\"\n\n    @classmethod\n    @required\n    def from_string(cls, string: str) -&gt; Result[Self, E]:\n        \"\"\"Parses the given string to return some value of type `Self`.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parse result, [`Ok[Self]`][wraps.result.Ok] if parsing was successful,\n                and [`Error[E]`][wraps.result.Error] otherwise.\n        \"\"\"\n        ...\n\n    @classmethod\n    def parse(cls, string: str) -&gt; Self:\n        \"\"\"Calls [`from_string`][wraps.parse.normal.FromString.from_string] and raises\n        [`ParseError[Self, E]`][wraps.parse.normal.ParseError] if parsing fails.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parsed value.\n\n        Raises:\n            ParseError[Self, E]: In case parsing fails.\n        \"\"\"\n        result = cls.from_string(string)\n\n        if result.is_ok():\n            return result.unwrap()\n\n        raise ParseError(string, cls, result.unwrap_err())\n</code></pre>"},{"location":"reference/parse/normal/#wraps.parse.normal.FromString.from_string","title":"<code>from_string(string: str) -&gt; Result[Self, E]</code>  <code>classmethod</code>","text":"<p>Parses the given string to return some value of type <code>Self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>The parse result, <code>Ok[Self]</code> if parsing was successful, and <code>Error[E]</code> otherwise.</p> Source code in <code>src/wraps/parse/normal.py</code> <pre><code>@classmethod\n@required\ndef from_string(cls, string: str) -&gt; Result[Self, E]:\n    \"\"\"Parses the given string to return some value of type `Self`.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parse result, [`Ok[Self]`][wraps.result.Ok] if parsing was successful,\n            and [`Error[E]`][wraps.result.Error] otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/parse/normal/#wraps.parse.normal.FromString.parse","title":"<code>parse(string: str) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Calls <code>from_string</code> and raises <code>ParseError[Self, E]</code> if parsing fails.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The parsed value.</p> <p>Raises:</p> Type Description <code>ParseError[Self, E]</code> <p>In case parsing fails.</p> Source code in <code>src/wraps/parse/normal.py</code> <pre><code>@classmethod\ndef parse(cls, string: str) -&gt; Self:\n    \"\"\"Calls [`from_string`][wraps.parse.normal.FromString.from_string] and raises\n    [`ParseError[Self, E]`][wraps.parse.normal.ParseError] if parsing fails.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parsed value.\n\n    Raises:\n        ParseError[Self, E]: In case parsing fails.\n    \"\"\"\n    result = cls.from_string(string)\n\n    if result.is_ok():\n        return result.unwrap()\n\n    raise ParseError(string, cls, result.unwrap_err())\n</code></pre>"},{"location":"reference/parse/simple/","title":"Simple","text":""},{"location":"reference/parse/simple/#wraps.parse.simple.SimpleParseError","title":"<code>SimpleParseError</code>","text":"<p>               Bases: <code>ValueError</code>, <code>Generic[T]</code></p> <p>Represents simple parse errors.</p> Source code in <code>src/wraps/parse/simple.py</code> <pre><code>class SimpleParseError(ValueError, Generic[T]):\n    \"\"\"Represents simple parse errors.\"\"\"\n\n    def __init__(self, string: str, type: Type[T]) -&gt; None:\n        self._string = string\n        self._type = type\n\n        super().__init__(simple_parse_failed(string, get_name(type)))  # type: ignore[arg-type]\n\n    @property\n    def string(self) -&gt; str:\n        \"\"\"The string that could not be parsed.\"\"\"\n        return self._string\n\n    @property\n    def type(self) -&gt; Type[T]:\n        \"\"\"The type parsing into which failed.\"\"\"\n        return self._type\n</code></pre>"},{"location":"reference/parse/simple/#wraps.parse.simple.SimpleParseError.string","title":"<code>string: str</code>  <code>property</code>","text":"<p>The string that could not be parsed.</p>"},{"location":"reference/parse/simple/#wraps.parse.simple.SimpleParseError.type","title":"<code>type: Type[T]</code>  <code>property</code>","text":"<p>The type parsing into which failed.</p>"},{"location":"reference/parse/simple/#wraps.parse.simple.SimpleFromString","title":"<code>SimpleFromString</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Represents types that can be parsed from strings.</p> Source code in <code>src/wraps/parse/simple.py</code> <pre><code>@runtime_checkable\nclass SimpleFromString(Protocol):\n    \"\"\"Represents types that can be parsed from strings.\"\"\"\n\n    @classmethod\n    @required\n    def from_string(cls, string: str) -&gt; Option[Self]:\n        \"\"\"Parses the given string to return some value of type `Self`.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parse result, [`Some[Self]`][wraps.option.Some] if parsing was successful,\n                and [`Null`][wraps.option.Null] otherwise.\n        \"\"\"\n        ...\n\n    @classmethod\n    def parse(cls, string: str) -&gt; Self:\n        \"\"\"Calls [`from_string`][wraps.parse.simple.SimpleFromString.from_string] and raises\n        [`SimpleParseError[Self]`][wraps.parse.simple.SimpleParseError] if parsing fails.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parsed value.\n\n        Raises:\n            SimpleParseError[Self]: In case parsing fails.\n        \"\"\"\n        return cls.from_string(string).or_raise(SimpleParseError(string, cls))\n</code></pre>"},{"location":"reference/parse/simple/#wraps.parse.simple.SimpleFromString.from_string","title":"<code>from_string(string: str) -&gt; Option[Self]</code>  <code>classmethod</code>","text":"<p>Parses the given string to return some value of type <code>Self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>Option[Self]</code> <p>The parse result, <code>Some[Self]</code> if parsing was successful, and <code>Null</code> otherwise.</p> Source code in <code>src/wraps/parse/simple.py</code> <pre><code>@classmethod\n@required\ndef from_string(cls, string: str) -&gt; Option[Self]:\n    \"\"\"Parses the given string to return some value of type `Self`.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parse result, [`Some[Self]`][wraps.option.Some] if parsing was successful,\n            and [`Null`][wraps.option.Null] otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/parse/simple/#wraps.parse.simple.SimpleFromString.parse","title":"<code>parse(string: str) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Calls <code>from_string</code> and raises <code>SimpleParseError[Self]</code> if parsing fails.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The parsed value.</p> <p>Raises:</p> Type Description <code>SimpleParseError[Self]</code> <p>In case parsing fails.</p> Source code in <code>src/wraps/parse/simple.py</code> <pre><code>@classmethod\ndef parse(cls, string: str) -&gt; Self:\n    \"\"\"Calls [`from_string`][wraps.parse.simple.SimpleFromString.from_string] and raises\n    [`SimpleParseError[Self]`][wraps.parse.simple.SimpleParseError] if parsing fails.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parsed value.\n\n    Raises:\n        SimpleParseError[Self]: In case parsing fails.\n    \"\"\"\n    return cls.from_string(string).or_raise(SimpleParseError(string, cls))\n</code></pre>"}]}